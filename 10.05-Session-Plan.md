# Session 10.05: Configuration Extensions for Resilience

**Parent Plan**: `10-Session-Plan-Production.md`
**Target**: ~20-30k tokens
**Prerequisites**: Existing codebase compiles (`cargo check --workspace`)

---

## Scope

This session adds configuration sections to `pm-config` for resilience features that will be used in Sessions 10.1-10.3:

1. **Circuit Breaker Config** - Database resilience settings
2. **Retry Config** - Exponential backoff settings
3. **Handler Config** - Request timeout settings
4. **Validation Config** - Field length limits

These configs will have sensible defaults, so existing code continues to work. Sessions 10.1+ will then use these configs instead of hardcoding values.

---

## Implementation Order

### Step 1: Create Circuit Breaker Config

**Create**: `backend/crates/pm-config/src/circuit_breaker_config.rs`

```rust
use crate::{ConfigError, ConfigErrorResult};
use serde::Deserialize;

// Circuit breaker constraints
pub const MIN_FAILURE_THRESHOLD: u32 = 1;
pub const MAX_FAILURE_THRESHOLD: u32 = 100;
pub const DEFAULT_FAILURE_THRESHOLD: u32 = 5;

pub const MIN_OPEN_DURATION_SECS: u64 = 1;
pub const MAX_OPEN_DURATION_SECS: u64 = 300;
pub const DEFAULT_OPEN_DURATION_SECS: u64 = 30;

pub const MIN_HALF_OPEN_SUCCESS_THRESHOLD: u32 = 1;
pub const MAX_HALF_OPEN_SUCCESS_THRESHOLD: u32 = 50;
pub const DEFAULT_HALF_OPEN_SUCCESS_THRESHOLD: u32 = 3;

pub const MIN_FAILURE_WINDOW_SECS: u64 = 1;
pub const MAX_FAILURE_WINDOW_SECS: u64 = 600;
pub const DEFAULT_FAILURE_WINDOW_SECS: u64 = 60;

/// Circuit breaker configuration for database resilience.
///
/// The circuit breaker prevents cascading failures by temporarily
/// blocking requests when the database is unhealthy.
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct CircuitBreakerConfig {
    /// Number of failures before opening the circuit
    pub failure_threshold: u32,
    /// Seconds to keep circuit open before testing recovery
    pub open_duration_secs: u64,
    /// Successful requests needed in half-open state to close circuit
    pub half_open_success_threshold: u32,
    /// Window in seconds for counting failures
    pub failure_window_secs: u64,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: DEFAULT_FAILURE_THRESHOLD,
            open_duration_secs: DEFAULT_OPEN_DURATION_SECS,
            half_open_success_threshold: DEFAULT_HALF_OPEN_SUCCESS_THRESHOLD,
            failure_window_secs: DEFAULT_FAILURE_WINDOW_SECS,
        }
    }
}

impl CircuitBreakerConfig {
    pub fn validate(&self) -> ConfigErrorResult<()> {
        if self.failure_threshold < MIN_FAILURE_THRESHOLD
            || self.failure_threshold > MAX_FAILURE_THRESHOLD
        {
            return Err(ConfigError::config(format!(
                "circuit_breaker.failure_threshold must be {}-{}, got {}",
                MIN_FAILURE_THRESHOLD, MAX_FAILURE_THRESHOLD, self.failure_threshold
            )));
        }

        if self.open_duration_secs < MIN_OPEN_DURATION_SECS
            || self.open_duration_secs > MAX_OPEN_DURATION_SECS
        {
            return Err(ConfigError::config(format!(
                "circuit_breaker.open_duration_secs must be {}-{}, got {}",
                MIN_OPEN_DURATION_SECS, MAX_OPEN_DURATION_SECS, self.open_duration_secs
            )));
        }

        if self.half_open_success_threshold < MIN_HALF_OPEN_SUCCESS_THRESHOLD
            || self.half_open_success_threshold > MAX_HALF_OPEN_SUCCESS_THRESHOLD
        {
            return Err(ConfigError::config(format!(
                "circuit_breaker.half_open_success_threshold must be {}-{}, got {}",
                MIN_HALF_OPEN_SUCCESS_THRESHOLD,
                MAX_HALF_OPEN_SUCCESS_THRESHOLD,
                self.half_open_success_threshold
            )));
        }

        if self.failure_window_secs < MIN_FAILURE_WINDOW_SECS
            || self.failure_window_secs > MAX_FAILURE_WINDOW_SECS
        {
            return Err(ConfigError::config(format!(
                "circuit_breaker.failure_window_secs must be {}-{}, got {}",
                MIN_FAILURE_WINDOW_SECS, MAX_FAILURE_WINDOW_SECS, self.failure_window_secs
            )));
        }

        Ok(())
    }
}
```

---

### Step 2: Create Retry Config

**Create**: `backend/crates/pm-config/src/retry_config.rs`

```rust
use crate::{ConfigError, ConfigErrorResult};
use serde::Deserialize;

// Retry constraints
pub const MIN_MAX_ATTEMPTS: u32 = 1;
pub const MAX_MAX_ATTEMPTS: u32 = 10;
pub const DEFAULT_MAX_ATTEMPTS: u32 = 3;

pub const MIN_INITIAL_DELAY_MS: u64 = 10;
pub const MAX_INITIAL_DELAY_MS: u64 = 10000;
pub const DEFAULT_INITIAL_DELAY_MS: u64 = 100;

pub const MIN_MAX_DELAY_SECS: u64 = 1;
pub const MAX_MAX_DELAY_SECS: u64 = 60;
pub const DEFAULT_MAX_DELAY_SECS: u64 = 5;

pub const MIN_BACKOFF_MULTIPLIER: f64 = 1.0;
pub const MAX_BACKOFF_MULTIPLIER: f64 = 10.0;
pub const DEFAULT_BACKOFF_MULTIPLIER: f64 = 2.0;

pub const DEFAULT_JITTER: bool = true;

/// Retry configuration for transient failure handling.
///
/// Uses exponential backoff with optional jitter to prevent
/// thundering herd problems during recovery.
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct RetryConfig {
    /// Maximum number of retry attempts (including initial attempt)
    pub max_attempts: u32,
    /// Initial delay before first retry in milliseconds
    pub initial_delay_ms: u64,
    /// Maximum delay between retries in seconds
    pub max_delay_secs: u64,
    /// Multiplier for exponential backoff (e.g., 2.0 = double each time)
    pub backoff_multiplier: f64,
    /// Add random jitter to delays to prevent thundering herd
    pub jitter: bool,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: DEFAULT_MAX_ATTEMPTS,
            initial_delay_ms: DEFAULT_INITIAL_DELAY_MS,
            max_delay_secs: DEFAULT_MAX_DELAY_SECS,
            backoff_multiplier: DEFAULT_BACKOFF_MULTIPLIER,
            jitter: DEFAULT_JITTER,
        }
    }
}

impl RetryConfig {
    pub fn validate(&self) -> ConfigErrorResult<()> {
        if self.max_attempts < MIN_MAX_ATTEMPTS || self.max_attempts > MAX_MAX_ATTEMPTS {
            return Err(ConfigError::config(format!(
                "retry.max_attempts must be {}-{}, got {}",
                MIN_MAX_ATTEMPTS, MAX_MAX_ATTEMPTS, self.max_attempts
            )));
        }

        if self.initial_delay_ms < MIN_INITIAL_DELAY_MS
            || self.initial_delay_ms > MAX_INITIAL_DELAY_MS
        {
            return Err(ConfigError::config(format!(
                "retry.initial_delay_ms must be {}-{}, got {}",
                MIN_INITIAL_DELAY_MS, MAX_INITIAL_DELAY_MS, self.initial_delay_ms
            )));
        }

        if self.max_delay_secs < MIN_MAX_DELAY_SECS || self.max_delay_secs > MAX_MAX_DELAY_SECS {
            return Err(ConfigError::config(format!(
                "retry.max_delay_secs must be {}-{}, got {}",
                MIN_MAX_DELAY_SECS, MAX_MAX_DELAY_SECS, self.max_delay_secs
            )));
        }

        if self.backoff_multiplier < MIN_BACKOFF_MULTIPLIER
            || self.backoff_multiplier > MAX_BACKOFF_MULTIPLIER
        {
            return Err(ConfigError::config(format!(
                "retry.backoff_multiplier must be {}-{}, got {}",
                MIN_BACKOFF_MULTIPLIER, MAX_BACKOFF_MULTIPLIER, self.backoff_multiplier
            )));
        }

        Ok(())
    }
}
```

---

### Step 3: Create Handler Config

**Create**: `backend/crates/pm-config/src/handler_config.rs`

```rust
use crate::{ConfigError, ConfigErrorResult};
use serde::Deserialize;

// Handler constraints
pub const MIN_TIMEOUT_SECS: u64 = 1;
pub const MAX_TIMEOUT_SECS: u64 = 300;
pub const DEFAULT_TIMEOUT_SECS: u64 = 30;

/// Handler configuration for request processing.
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct HandlerConfig {
    /// Maximum time in seconds for a handler to complete
    pub timeout_secs: u64,
}

impl Default for HandlerConfig {
    fn default() -> Self {
        Self {
            timeout_secs: DEFAULT_TIMEOUT_SECS,
        }
    }
}

impl HandlerConfig {
    pub fn validate(&self) -> ConfigErrorResult<()> {
        if self.timeout_secs < MIN_TIMEOUT_SECS || self.timeout_secs > MAX_TIMEOUT_SECS {
            return Err(ConfigError::config(format!(
                "handler.timeout_secs must be {}-{}, got {}",
                MIN_TIMEOUT_SECS, MAX_TIMEOUT_SECS, self.timeout_secs
            )));
        }

        Ok(())
    }
}
```

---

### Step 4: Create Validation Config

**Create**: `backend/crates/pm-config/src/validation_config.rs`

```rust
use crate::{ConfigError, ConfigErrorResult};
use serde::Deserialize;

// Validation constraints
pub const MIN_TITLE_LENGTH: usize = 1;
pub const MAX_TITLE_LENGTH: usize = 500;
pub const DEFAULT_MAX_TITLE_LENGTH: usize = 200;

pub const MIN_DESCRIPTION_LENGTH: usize = 0;
pub const MAX_DESCRIPTION_LENGTH: usize = 100000;
pub const DEFAULT_MAX_DESCRIPTION_LENGTH: usize = 10000;

pub const MIN_STORY_POINTS: i32 = 0;
pub const MAX_STORY_POINTS: i32 = 1000;
pub const DEFAULT_MAX_STORY_POINTS: i32 = 100;

pub const MIN_ERROR_MESSAGE_LENGTH: usize = 50;
pub const MAX_ERROR_MESSAGE_LENGTH: usize = 1000;
pub const DEFAULT_MAX_ERROR_MESSAGE_LENGTH: usize = 200;

/// Validation configuration for field limits.
///
/// These limits are applied during input validation to prevent
/// abuse and ensure reasonable data sizes.
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct ValidationConfig {
    /// Maximum length for work item titles
    pub max_title_length: usize,
    /// Maximum length for work item descriptions
    pub max_description_length: usize,
    /// Maximum story points allowed
    pub max_story_points: i32,
    /// Maximum length for error messages returned to clients
    pub max_error_message_length: usize,
}

impl Default for ValidationConfig {
    fn default() -> Self {
        Self {
            max_title_length: DEFAULT_MAX_TITLE_LENGTH,
            max_description_length: DEFAULT_MAX_DESCRIPTION_LENGTH,
            max_story_points: DEFAULT_MAX_STORY_POINTS,
            max_error_message_length: DEFAULT_MAX_ERROR_MESSAGE_LENGTH,
        }
    }
}

impl ValidationConfig {
    pub fn validate(&self) -> ConfigErrorResult<()> {
        if self.max_title_length < MIN_TITLE_LENGTH || self.max_title_length > MAX_TITLE_LENGTH {
            return Err(ConfigError::config(format!(
                "validation.max_title_length must be {}-{}, got {}",
                MIN_TITLE_LENGTH, MAX_TITLE_LENGTH, self.max_title_length
            )));
        }

        if self.max_description_length < MIN_DESCRIPTION_LENGTH
            || self.max_description_length > MAX_DESCRIPTION_LENGTH
        {
            return Err(ConfigError::config(format!(
                "validation.max_description_length must be {}-{}, got {}",
                MIN_DESCRIPTION_LENGTH, MAX_DESCRIPTION_LENGTH, self.max_description_length
            )));
        }

        if self.max_story_points < MIN_STORY_POINTS || self.max_story_points > MAX_STORY_POINTS {
            return Err(ConfigError::config(format!(
                "validation.max_story_points must be {}-{}, got {}",
                MIN_STORY_POINTS, MAX_STORY_POINTS, self.max_story_points
            )));
        }

        if self.max_error_message_length < MIN_ERROR_MESSAGE_LENGTH
            || self.max_error_message_length > MAX_ERROR_MESSAGE_LENGTH
        {
            return Err(ConfigError::config(format!(
                "validation.max_error_message_length must be {}-{}, got {}",
                MIN_ERROR_MESSAGE_LENGTH, MAX_ERROR_MESSAGE_LENGTH, self.max_error_message_length
            )));
        }

        Ok(())
    }
}
```

---

### Step 5: Update lib.rs

**File**: `backend/crates/pm-config/src/lib.rs`

Add module declarations and re-exports:

```rust
mod auth_config;
mod circuit_breaker_config;  // NEW
mod config;
mod database_config;
mod error;
mod handler_config;          // NEW
mod log_level;
mod logging_config;
mod rate_limit_config;
mod retry_config;            // NEW
mod server_config;
mod validation_config;       // NEW
mod websocket_config;

#[cfg(test)]
mod tests;

pub use auth_config::AuthConfig;
pub use circuit_breaker_config::CircuitBreakerConfig;  // NEW
pub use config::Config;
pub use database_config::DatabaseConfig;
pub use error::{ConfigError, ConfigErrorResult};
pub use handler_config::HandlerConfig;                  // NEW
pub use log_level::LogLevel;
pub use logging_config::LoggingConfig;
pub use rate_limit_config::RateLimitConfig;
pub use retry_config::RetryConfig;                      // NEW
pub use server_config::ServerConfig;
pub use validation_config::ValidationConfig;            // NEW
pub use websocket_config::WebSocketConfig;

// ... existing constants ...
```

---

### Step 6: Update Config struct

**File**: `backend/crates/pm-config/src/config.rs`

Add new fields to Config struct:

```rust
use crate::{
    AuthConfig, CircuitBreakerConfig, ConfigError, ConfigErrorResult, DatabaseConfig,
    HandlerConfig, LoggingConfig, RateLimitConfig, RetryConfig, ServerConfig,
    ValidationConfig, WebSocketConfig,
};

// ... existing imports ...

#[derive(Debug, Clone, Deserialize, Default)]
#[serde(default)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub auth: AuthConfig,
    pub logging: LoggingConfig,
    pub websocket: WebSocketConfig,
    pub rate_limit: RateLimitConfig,
    pub circuit_breaker: CircuitBreakerConfig,  // NEW
    pub retry: RetryConfig,                      // NEW
    pub handler: HandlerConfig,                  // NEW
    pub validation: ValidationConfig,            // NEW
}
```

Update `validate()` method:

```rust
pub fn validate(&self) -> ConfigErrorResult<()> {
    let config_dir = Self::config_dir()?;

    self.server.validate()?;
    self.auth.validate(&config_dir)?;
    self.websocket.validate()?;
    self.rate_limit.validate()?;
    self.circuit_breaker.validate()?;  // NEW
    self.retry.validate()?;             // NEW
    self.handler.validate()?;           // NEW
    self.validation.validate()?;        // NEW

    // ... existing database path validation ...

    Ok(())
}
```

Update `log_summary()` method to include new sections:

```rust
pub fn log_summary(&self) {
    // ... existing logging ...

    info!(
        "  circuit_breaker: threshold={}, open={}s, window={}s",
        self.circuit_breaker.failure_threshold,
        self.circuit_breaker.open_duration_secs,
        self.circuit_breaker.failure_window_secs
    );

    info!(
        "  retry: attempts={}, initial={}ms, max={}s, backoff={}x",
        self.retry.max_attempts,
        self.retry.initial_delay_ms,
        self.retry.max_delay_secs,
        self.retry.backoff_multiplier
    );

    info!("  handler: timeout={}s", self.handler.timeout_secs);

    info!(
        "  validation: title={}, desc={}, points={}",
        self.validation.max_title_length,
        self.validation.max_description_length,
        self.validation.max_story_points
    );
}
```

Update `apply_env_overrides()` method:

```rust
fn apply_env_overrides(&mut self) {
    // ... existing overrides ...

    // Circuit Breaker
    Self::apply_env_parse(
        "PM_CB_FAILURE_THRESHOLD",
        &mut self.circuit_breaker.failure_threshold,
    );
    Self::apply_env_parse(
        "PM_CB_OPEN_DURATION_SECS",
        &mut self.circuit_breaker.open_duration_secs,
    );
    Self::apply_env_parse(
        "PM_CB_HALF_OPEN_SUCCESS_THRESHOLD",
        &mut self.circuit_breaker.half_open_success_threshold,
    );
    Self::apply_env_parse(
        "PM_CB_FAILURE_WINDOW_SECS",
        &mut self.circuit_breaker.failure_window_secs,
    );

    // Retry
    Self::apply_env_parse("PM_RETRY_MAX_ATTEMPTS", &mut self.retry.max_attempts);
    Self::apply_env_parse("PM_RETRY_INITIAL_DELAY_MS", &mut self.retry.initial_delay_ms);
    Self::apply_env_parse("PM_RETRY_MAX_DELAY_SECS", &mut self.retry.max_delay_secs);
    Self::apply_env_parse("PM_RETRY_BACKOFF_MULTIPLIER", &mut self.retry.backoff_multiplier);
    Self::apply_env_bool("PM_RETRY_JITTER", &mut self.retry.jitter);

    // Handler
    Self::apply_env_parse("PM_HANDLER_TIMEOUT_SECS", &mut self.handler.timeout_secs);

    // Validation
    Self::apply_env_parse(
        "PM_VALIDATION_MAX_TITLE_LENGTH",
        &mut self.validation.max_title_length,
    );
    Self::apply_env_parse(
        "PM_VALIDATION_MAX_DESCRIPTION_LENGTH",
        &mut self.validation.max_description_length,
    );
    Self::apply_env_parse(
        "PM_VALIDATION_MAX_STORY_POINTS",
        &mut self.validation.max_story_points,
    );
    Self::apply_env_parse(
        "PM_VALIDATION_MAX_ERROR_MESSAGE_LENGTH",
        &mut self.validation.max_error_message_length,
    );
}
```

---

### Step 7: Add Tests

Following the existing test structure in `src/tests/`, create separate test files for each new config.

**Update**: `backend/crates/pm-config/src/tests/mod.rs`

Add new module declarations:

```rust
mod auth;
mod circuit_breaker;  // NEW
mod config;
mod desktop_id;
mod edge_cases;
mod handler;          // NEW
mod retry;            // NEW
mod server;
mod validation;       // NEW
mod web_socket;

// ... existing EnvGuard and setup_config_dir() ...
```

---

**Create**: `backend/crates/pm-config/src/tests/circuit_breaker.rs`

```rust
use crate::Config;
use crate::tests::{EnvGuard, setup_config_dir};

use googletest::assert_that;
use googletest::prelude::{anything, err, ok};
use serial_test::serial;

// =========================================================================
// Validation Tests - Circuit Breaker
// =========================================================================

#[test]
#[serial]
fn given_failure_threshold_zero_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _threshold = EnvGuard::set("PM_CB_FAILURE_THRESHOLD", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_failure_threshold_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _threshold = EnvGuard::set("PM_CB_FAILURE_THRESHOLD", "101");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_open_duration_zero_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _duration = EnvGuard::set("PM_CB_OPEN_DURATION_SECS", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_open_duration_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _duration = EnvGuard::set("PM_CB_OPEN_DURATION_SECS", "301");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_valid_circuit_breaker_config_when_validate_then_ok() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _threshold = EnvGuard::set("PM_CB_FAILURE_THRESHOLD", "10");
    let _duration = EnvGuard::set("PM_CB_OPEN_DURATION_SECS", "60");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, ok(anything()));
}
```

---

**Create**: `backend/crates/pm-config/src/tests/retry.rs`

```rust
use crate::Config;
use crate::tests::{EnvGuard, setup_config_dir};

use googletest::assert_that;
use googletest::prelude::{anything, err, ok};
use serial_test::serial;

// =========================================================================
// Validation Tests - Retry
// =========================================================================

#[test]
#[serial]
fn given_max_attempts_zero_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _attempts = EnvGuard::set("PM_RETRY_MAX_ATTEMPTS", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_max_attempts_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _attempts = EnvGuard::set("PM_RETRY_MAX_ATTEMPTS", "11");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_initial_delay_below_min_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _delay = EnvGuard::set("PM_RETRY_INITIAL_DELAY_MS", "5");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_backoff_multiplier_below_min_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _multiplier = EnvGuard::set("PM_RETRY_BACKOFF_MULTIPLIER", "0.5");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_backoff_multiplier_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _multiplier = EnvGuard::set("PM_RETRY_BACKOFF_MULTIPLIER", "11.0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_valid_retry_config_when_validate_then_ok() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _attempts = EnvGuard::set("PM_RETRY_MAX_ATTEMPTS", "5");
    let _delay = EnvGuard::set("PM_RETRY_INITIAL_DELAY_MS", "200");
    let _multiplier = EnvGuard::set("PM_RETRY_BACKOFF_MULTIPLIER", "3.0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, ok(anything()));
}
```

---

**Create**: `backend/crates/pm-config/src/tests/handler.rs`

```rust
use crate::Config;
use crate::tests::{EnvGuard, setup_config_dir};

use googletest::assert_that;
use googletest::prelude::{anything, err, ok};
use serial_test::serial;

// =========================================================================
// Validation Tests - Handler
// =========================================================================

#[test]
#[serial]
fn given_timeout_zero_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _timeout = EnvGuard::set("PM_HANDLER_TIMEOUT_SECS", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_timeout_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _timeout = EnvGuard::set("PM_HANDLER_TIMEOUT_SECS", "301");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_valid_timeout_when_validate_then_ok() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _timeout = EnvGuard::set("PM_HANDLER_TIMEOUT_SECS", "60");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, ok(anything()));
}
```

---

**Create**: `backend/crates/pm-config/src/tests/validation.rs`

```rust
use crate::Config;
use crate::tests::{EnvGuard, setup_config_dir};

use googletest::assert_that;
use googletest::prelude::{anything, err, ok};
use serial_test::serial;

// =========================================================================
// Validation Tests - Validation Config
// =========================================================================

#[test]
#[serial]
fn given_max_title_length_zero_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _length = EnvGuard::set("PM_VALIDATION_MAX_TITLE_LENGTH", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_max_title_length_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _length = EnvGuard::set("PM_VALIDATION_MAX_TITLE_LENGTH", "501");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_max_story_points_negative_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _points = EnvGuard::set("PM_VALIDATION_MAX_STORY_POINTS", "-1");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_max_story_points_over_max_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _points = EnvGuard::set("PM_VALIDATION_MAX_STORY_POINTS", "1001");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_max_error_message_length_below_min_when_validate_then_error() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _length = EnvGuard::set("PM_VALIDATION_MAX_ERROR_MESSAGE_LENGTH", "49");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_valid_validation_config_when_validate_then_ok() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    let _title = EnvGuard::set("PM_VALIDATION_MAX_TITLE_LENGTH", "300");
    let _desc = EnvGuard::set("PM_VALIDATION_MAX_DESCRIPTION_LENGTH", "50000");
    let _points = EnvGuard::set("PM_VALIDATION_MAX_STORY_POINTS", "200");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, ok(anything()));
}
```

---

## Session 10.05 Completion Checklist

After completing all steps:

- [ ] `cargo check -p pm-config` passes
- [ ] `cargo test -p pm-config` passes
- [ ] `cargo check --workspace` passes

### Files Created (8)
- `pm-config/src/circuit_breaker_config.rs`
- `pm-config/src/retry_config.rs`
- `pm-config/src/handler_config.rs`
- `pm-config/src/validation_config.rs`
- `pm-config/src/tests/circuit_breaker.rs`
- `pm-config/src/tests/retry.rs`
- `pm-config/src/tests/handler.rs`
- `pm-config/src/tests/validation.rs`

### Files Modified (3)
- `pm-config/src/lib.rs` - Add module declarations and re-exports
- `pm-config/src/config.rs` - Add new fields, validate(), log_summary(), env overrides
- `pm-config/src/tests/mod.rs` - Add module declarations for new test files

---

## Example config.toml

After this session, users can configure these values in `config.toml`:

```toml
[circuit_breaker]
failure_threshold = 5
open_duration_secs = 30
half_open_success_threshold = 3
failure_window_secs = 60

[retry]
max_attempts = 3
initial_delay_ms = 100
max_delay_secs = 5
backoff_multiplier = 2.0
jitter = true

[handler]
timeout_secs = 30

[validation]
max_title_length = 200
max_description_length = 10000
max_story_points = 100
max_error_message_length = 200
```

Or via environment variables:
```bash
PM_CB_FAILURE_THRESHOLD=10
PM_RETRY_MAX_ATTEMPTS=5
PM_HANDLER_TIMEOUT_SECS=60
PM_VALIDATION_MAX_DESCRIPTION_LENGTH=50000
```

---

## Next Session

**Session 10.1** will use these configs:
- `CircuitBreakerConfig` -> `pm_ws::CircuitBreaker::new()`
- `RetryConfig` -> `pm_ws::RetryConfig`
- `HandlerConfig` -> Dispatcher timeout
- `ValidationConfig` -> Work item validation
