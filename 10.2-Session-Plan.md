# Session 10.2: Handler Infrastructure & Business Logic

**Parent Plan**: `10-Session-Plan-Production.md`
**Prerequisite**: Session 10.1 completed
**Target**: ~60-70k tokens

---

## Scope

This session implements the handler infrastructure and business logic:

1. **Handler Context** (Part 6) - Enhanced context with circuit breaker
2. **DB Operations** (Part 7) - Circuit-breaker-aware database wrappers
3. **Error Boundary** (Part 5) - Panic recovery for handlers
4. **Work Item Handlers** (Part 9) - Create/Update/Delete handlers
5. **Query Handlers** (Part 9) - GetWorkItems handler
6. **Dispatcher** (Part 8) - Message routing

---

## Prerequisites Check

Before starting, verify Session 10.1 is complete:

```bash
cargo check -p pm-ws  # Should pass
```

Ensure these exports exist in `pm-ws/src/lib.rs`:
- `RequestContext`
- `RequestLogger`
- `CircuitBreaker`, `CircuitBreakerConfig`, `CircuitState`
- `RetryConfig`, `with_retry`, `IsRetryable`

---

## Implementation Order

### Step 1: Update Handler Context

**File**: `backend/crates/pm-ws/src/handlers/context.rs`

Replace the existing file with enhanced version that includes circuit breaker:

```rust
use crate::circuit_breaker::CircuitBreaker;
use crate::retry::RetryConfig;
use crate::RequestContext;
use sqlx::SqlitePool;
use std::sync::Arc;
use uuid::Uuid;

/// Context passed to all handlers containing request metadata and resources.
#[derive(Clone)]
pub struct HandlerContext {
    /// Unique message ID for request/response correlation
    pub message_id: String,
    /// User ID extracted from JWT
    pub user_id: Uuid,
    /// Database connection pool
    pub pool: SqlitePool,
    /// Circuit breaker for database operations
    pub circuit_breaker: Arc<CircuitBreaker>,
    /// Request context for tracing
    pub request_ctx: RequestContext,
    /// Retry configuration
    pub retry_config: RetryConfig,
}

impl HandlerContext {
    pub fn new(
        message_id: String,
        user_id: Uuid,
        pool: SqlitePool,
        circuit_breaker: Arc<CircuitBreaker>,
        connection_id: String,
    ) -> Self {
        let request_ctx = RequestContext::new(user_id, connection_id, &message_id);

        Self {
            message_id,
            user_id,
            pool,
            circuit_breaker,
            request_ctx,
            retry_config: RetryConfig::default(),
        }
    }

    /// Check circuit breaker before database operation
    pub fn check_circuit(&self) -> crate::Result<()> {
        self.circuit_breaker.allow_request()?;
        Ok(())
    }

    /// Record successful database operation
    pub fn record_db_success(&self) {
        self.circuit_breaker.record_success();
    }

    /// Record failed database operation
    pub fn record_db_failure(&self) {
        self.circuit_breaker.record_failure();
    }

    /// Get log prefix for structured logging
    pub fn log_prefix(&self) -> String {
        self.request_ctx.log_prefix()
    }
}

impl std::fmt::Debug for HandlerContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("HandlerContext")
            .field("message_id", &self.message_id)
            .field("user_id", &self.user_id)
            .field("correlation_id", &self.request_ctx.correlation_id)
            .finish()
    }
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 2: Create DB Operations Wrapper

**Create**: `backend/crates/pm-ws/src/handlers/db_ops.rs`

```rust
use crate::handlers::context::HandlerContext;
use crate::retry::{with_retry, RetryConfig};
use crate::{Result as WsErrorResult, WsError};
use std::future::Future;

/// Execute a database read operation with circuit breaker and retry
pub async fn db_read<F, Fut, T>(
    ctx: &HandlerContext,
    operation_name: &str,
    operation: F,
) -> WsErrorResult<T>
where
    F: Fn() -> Fut + Clone,
    Fut: Future<Output = WsErrorResult<T>>,
{
    // Check circuit breaker first
    ctx.check_circuit()?;

    let result = with_retry(&ctx.retry_config, operation_name, operation).await;

    match &result {
        Ok(_) => ctx.record_db_success(),
        Err(_) => ctx.record_db_failure(),
    }

    result
}

/// Execute a database write operation with circuit breaker (no retry for writes)
pub async fn db_write<F, Fut, T>(
    ctx: &HandlerContext,
    operation_name: &str,
    operation: F,
) -> WsErrorResult<T>
where
    F: FnOnce() -> Fut,
    Fut: Future<Output = WsErrorResult<T>>,
{
    // Check circuit breaker first
    ctx.check_circuit()?;

    log::debug!("{} Starting {}", ctx.log_prefix(), operation_name);

    let result = operation().await;

    match &result {
        Ok(_) => {
            ctx.record_db_success();
            log::debug!("{} {} succeeded", ctx.log_prefix(), operation_name);
        }
        Err(e) => {
            ctx.record_db_failure();
            log::warn!("{} {} failed: {}", ctx.log_prefix(), operation_name, e);
        }
    }

    result
}

/// Execute a database transaction with circuit breaker
pub async fn db_transaction<F, Fut, T>(
    ctx: &HandlerContext,
    operation_name: &str,
    operation: F,
) -> WsErrorResult<T>
where
    F: FnOnce(sqlx::Transaction<'_, sqlx::Sqlite>) -> Fut,
    Fut: Future<Output = WsErrorResult<(T, sqlx::Transaction<'static, sqlx::Sqlite>)>>,
{
    // Check circuit breaker first
    ctx.check_circuit()?;

    log::debug!("{} Starting transaction: {}", ctx.log_prefix(), operation_name);

    let tx = ctx.pool.begin().await?;

    match operation(tx).await {
        Ok((result, tx)) => {
            tx.commit().await?;
            ctx.record_db_success();
            log::debug!("{} Transaction {} committed", ctx.log_prefix(), operation_name);
            Ok(result)
        }
        Err(e) => {
            ctx.record_db_failure();
            log::warn!(
                "{} Transaction {} failed: {}",
                ctx.log_prefix(),
                operation_name,
                e
            );
            // Transaction automatically rolled back on drop
            Err(e)
        }
    }
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod db_ops;
```

**Verification**: `cargo check -p pm-ws`

---

### Step 3: Create Error Boundary

**Create**: `backend/crates/pm-ws/src/handlers/error_boundary.rs`

```rust
use crate::handlers::response_builder::build_error_response;
use crate::RequestContext;
use pm_proto::WebSocketMessage;

/// Execute a handler with panic recovery
pub async fn with_error_boundary<F, Fut>(
    ctx: &RequestContext,
    handler_name: &str,
    handler: F,
) -> WebSocketMessage
where
    F: FnOnce() -> Fut + Send + 'static,
    Fut: std::future::Future<Output = WebSocketMessage> + Send + 'static,
{
    // Spawn the handler in a separate task for panic isolation
    let correlation_id = ctx.correlation_id.clone();
    let handler_name_owned = handler_name.to_string();
    let log_prefix = ctx.log_prefix();

    let result = tokio::spawn(async move {
        handler().await
    })
    .await;

    match result {
        Ok(response) => response,
        Err(join_error) => {
            // Task panicked or was cancelled
            let panic_msg = if join_error.is_panic() {
                match join_error.into_panic().downcast::<String>() {
                    Ok(msg) => *msg,
                    Err(any) => match any.downcast::<&str>() {
                        Ok(msg) => msg.to_string(),
                        Err(_) => "Unknown panic".to_string(),
                    },
                }
            } else {
                "Task cancelled".to_string()
            };

            log::error!(
                "{} Handler {} panicked: {}",
                log_prefix,
                handler_name_owned,
                panic_msg
            );

            build_error_response(
                &correlation_id,
                pm_proto::Error {
                    code: "INTERNAL_ERROR".to_string(),
                    message: "An unexpected error occurred. Please try again.".to_string(),
                    field: None,
                },
            )
        }
    }
}

/// Wrapper that ensures we never leak internal error details to clients
pub fn sanitize_error_message(internal_error: &str) -> String {
    // Never expose internal details like file paths, SQL, stack traces
    if internal_error.contains("SQLITE")
        || internal_error.contains("sqlx")
        || internal_error.contains("panicked")
        || internal_error.contains("/Users")
        || internal_error.contains("\\Users")
        || internal_error.contains("/home")
    {
        "An internal error occurred. Please try again later.".to_string()
    } else {
        // Truncate to reasonable length
        internal_error.chars().take(200).collect()
    }
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod error_boundary;
```

**Verification**: `cargo check -p pm-ws`

---

### Step 4: Create Work Item Handlers

**Create**: `backend/crates/pm-ws/src/handlers/work_item.rs`

```rust
use crate::handlers::{
    context::HandlerContext,
    db_ops::{db_read, db_write},
    idempotency::{check_idempotency, store_idempotency},
    authorization::check_permission,
    hierarchy_validator::validate_hierarchy,
    change_tracker::track_changes,
    response_builder::*,
};
use crate::{MessageValidator, Result as WsErrorResult, WsError};
use pm_core::{Permission, WorkItem, WorkItemType, ActivityLog};
use pm_db::{WorkItemRepository, ActivityLogRepository};
use pm_proto::{
    CreateWorkItemRequest, UpdateWorkItemRequest, DeleteWorkItemRequest,
    WebSocketMessage, WorkItemType as ProtoWorkItemType,
};
use chrono::Utc;
use error_location::ErrorLocation;
use std::panic::Location;
use uuid::Uuid;

/// Convert proto WorkItemType (i32) to domain WorkItemType
fn proto_to_domain_item_type(proto_type: i32) -> Result<WorkItemType, WsError> {
    match proto_type {
        x if x == ProtoWorkItemType::Project as i32 => Ok(WorkItemType::Project),
        x if x == ProtoWorkItemType::Epic as i32 => Ok(WorkItemType::Epic),
        x if x == ProtoWorkItemType::Story as i32 => Ok(WorkItemType::Story),
        x if x == ProtoWorkItemType::Task as i32 => Ok(WorkItemType::Task),
        _ => Err(WsError::ValidationError {
            message: format!("Invalid item_type: {}", proto_type),
            field: Some("item_type".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }),
    }
}

/// Handle CreateWorkItemRequest with full production features
pub async fn handle_create(
    req: CreateWorkItemRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} CreateWorkItem starting", ctx.log_prefix());

    // 1. Convert and validate item_type
    let item_type = proto_to_domain_item_type(req.item_type)?;

    // 2. Validate input fields
    MessageValidator::validate_work_item_create(
        &req.title,
        req.description.as_deref(),
        item_type.as_str(),
    )?;

    // 3. Check idempotency BEFORE any mutations (with circuit breaker)
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;

    if let Some(cached_response) = cached {
        log::info!("{} Returning cached idempotent response", ctx.log_prefix());
        use prost::Message as ProstMessage;
        use base64::Engine;
        let bytes = base64::engine::general_purpose::STANDARD
            .decode(&cached_response)
            .map_err(|e| WsError::Internal {
                message: format!("Failed to decode cached response: {e}"),
                location: ErrorLocation::from(Location::caller()),
            })?;
        return WebSocketMessage::decode(&*bytes).map_err(|e| WsError::Internal {
            message: format!("Failed to decode cached protobuf: {e}"),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 4. Parse and validate IDs
    let project_id = parse_uuid(&req.project_id, "project_id")?;
    let parent_id = match &req.parent_id {
        Some(id) if !id.is_empty() => Some(parse_uuid(id, "parent_id")?),
        _ => None,
    };

    // 5. Authorization with circuit breaker
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, project_id, Permission::Edit).await
    })
    .await?;

    // 6. Validate hierarchy rules
    match (&item_type, parent_id) {
        (WorkItemType::Project, None) => {}
        (WorkItemType::Project, Some(_)) => {
            return Err(WsError::ValidationError {
                message: "Projects cannot have a parent".to_string(),
                field: Some("parent_id".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        (_, None) => {
            return Err(WsError::ValidationError {
                message: format!("{:?} must have a parent_id", item_type),
                field: Some("parent_id".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        (_, Some(pid)) => {
            db_read(&ctx, "validate_hierarchy", || async {
                validate_hierarchy(&ctx.pool, item_type.clone(), pid).await
            })
            .await?;
        }
    }

    // 7. Get next position
    let max_position = db_read(&ctx, "find_max_position", || async {
        WorkItemRepository::find_max_position(&ctx.pool, project_id, parent_id)
            .await
            .map_err(WsError::from)
    })
    .await?;

    // 8. Build work item
    let now = Utc::now();
    let work_item = WorkItem {
        id: Uuid::new_v4(),
        item_type: item_type.clone(),
        parent_id,
        project_id,
        position: max_position + 1,
        title: sanitize_string(&req.title),
        description: req.description.as_ref().map(|d| sanitize_string(d)),
        status: "todo".to_string(),
        priority: "medium".to_string(),
        assignee_id: None,
        story_points: None,
        sprint_id: None,
        version: 1,
        created_at: now,
        updated_at: now,
        created_by: ctx.user_id,
        updated_by: ctx.user_id,
        deleted_at: None,
    };

    // 9. Execute transaction with circuit breaker
    let work_item_clone = work_item.clone();
    db_write(&ctx, "create_work_item_tx", || async {
        let mut tx = ctx.pool.begin().await?;

        WorkItemRepository::create(&mut *tx, &work_item_clone).await?;

        let activity = ActivityLog {
            id: Uuid::new_v4(),
            entity_type: "work_item".to_string(),
            entity_id: work_item_clone.id,
            action: "created".to_string(),
            changes_json: Some(format!(
                r#"{{"item_type":"{}","title":"{}"}}"#,
                item_type.as_str(),
                work_item_clone.title.replace('"', r#"\""#)
            )),
            user_id: ctx.user_id,
            created_at: now,
        };
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    // 10. Build response
    let response = build_work_item_created_response(&ctx.message_id, &work_item, ctx.user_id);

    // 11. Store idempotency (after commit, failure here is non-fatal)
    use prost::Message as ProstMessage;
    use base64::Engine;
    let response_bytes = response.encode_to_vec();
    let response_b64 = base64::engine::general_purpose::STANDARD.encode(&response_bytes);

    if let Err(e) = store_idempotency(&ctx.pool, &ctx.message_id, "create_work_item", &response_b64).await {
        log::warn!("{} Failed to store idempotency (non-fatal): {}", ctx.log_prefix(), e);
    }

    log::info!(
        "{} Created work item {} ({:?}) in project {}",
        ctx.log_prefix(),
        work_item.id,
        item_type,
        project_id
    );

    Ok(response)
}

/// Handle UpdateWorkItemRequest
pub async fn handle_update(
    req: UpdateWorkItemRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} UpdateWorkItem starting", ctx.log_prefix());

    // 1. Parse work item ID
    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // 2. Fetch existing with circuit breaker
    let mut work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::find_by_id(&ctx.pool, work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        message: format!("Work item {} not found", work_item_id),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 3. Authorization
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::Edit).await
    })
    .await?;

    // 4. Optimistic locking
    if work_item.version != req.expected_version {
        return Err(WsError::ConflictError {
            current_version: work_item.version,
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 5. Track changes
    let changes = track_changes(&work_item, &req);

    if changes.is_empty() {
        return Ok(build_work_item_updated_response(
            &ctx.message_id,
            &work_item,
            &changes,
            ctx.user_id,
        ));
    }

    // 6. Apply updates with validation
    apply_updates(&mut work_item, &req)?;

    // 7. Update metadata
    let now = Utc::now();
    work_item.updated_at = now;
    work_item.updated_by = ctx.user_id;
    work_item.version += 1;

    // 8. Transaction with circuit breaker
    let work_item_clone = work_item.clone();
    let changes_clone = changes.clone();
    db_write(&ctx, "update_work_item_tx", || async {
        let mut tx = ctx.pool.begin().await?;

        WorkItemRepository::update(&mut *tx, &work_item_clone).await?;

        let changes_json = serde_json::to_string(&changes_clone).ok();
        let activity = ActivityLog {
            id: Uuid::new_v4(),
            entity_type: "work_item".to_string(),
            entity_id: work_item_clone.id,
            action: "updated".to_string(),
            changes_json,
            user_id: ctx.user_id,
            created_at: now,
        };
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    log::info!(
        "{} Updated work item {} (version {})",
        ctx.log_prefix(),
        work_item.id,
        work_item.version
    );

    Ok(build_work_item_updated_response(
        &ctx.message_id,
        &work_item,
        &changes,
        ctx.user_id,
    ))
}

/// Handle DeleteWorkItemRequest
pub async fn handle_delete(
    req: DeleteWorkItemRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} DeleteWorkItem starting", ctx.log_prefix());

    // 1. Parse work item ID
    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // 2. Fetch existing
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::find_by_id(&ctx.pool, work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        message: format!("Work item {} not found", work_item_id),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 3. Authorization - Admin required for delete
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::Admin).await
    })
    .await?;

    // 4. Check for children
    let children = db_read(&ctx, "find_children", || async {
        WorkItemRepository::find_children(&ctx.pool, work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?;

    if !children.is_empty() {
        return Err(WsError::DeleteBlocked {
            message: format!(
                "Cannot delete: has {} child item(s). Delete children first.",
                children.len()
            ),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 5. Transaction
    let now = Utc::now();
    db_write(&ctx, "delete_work_item_tx", || async {
        let mut tx = ctx.pool.begin().await?;

        WorkItemRepository::soft_delete(&mut *tx, work_item_id, ctx.user_id).await?;

        let activity = ActivityLog {
            id: Uuid::new_v4(),
            entity_type: "work_item".to_string(),
            entity_id: work_item_id,
            action: "deleted".to_string(),
            changes_json: None,
            user_id: ctx.user_id,
            created_at: now,
        };
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    log::info!("{} Deleted work item {}", ctx.log_prefix(), work_item_id);

    Ok(build_work_item_deleted_response(
        &ctx.message_id,
        work_item_id,
        ctx.user_id,
    ))
}

// === Helper Functions ===

fn parse_uuid(s: &str, field: &str) -> Result<Uuid, WsError> {
    Uuid::parse_str(s).map_err(|_| WsError::ValidationError {
        message: format!("Invalid UUID format for {}", field),
        field: Some(field.to_string()),
        location: ErrorLocation::from(Location::caller()),
    })
}

fn apply_updates(work_item: &mut WorkItem, req: &UpdateWorkItemRequest) -> Result<(), WsError> {
    if let Some(ref title) = req.title {
        MessageValidator::validate_string(title, "title", 1, 200)?;
        work_item.title = sanitize_string(title);
    }
    if let Some(ref desc) = req.description {
        if desc.len() > 10000 {
            return Err(WsError::ValidationError {
                message: "Description exceeds 10000 characters".to_string(),
                field: Some("description".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        work_item.description = Some(sanitize_string(desc));
    }
    if let Some(ref status) = req.status {
        validate_status(status)?;
        work_item.status = status.clone();
    }
    if let Some(ref priority) = req.priority {
        validate_priority(priority)?;
        work_item.priority = priority.clone();
    }
    if let Some(ref assignee_id) = req.assignee_id {
        work_item.assignee_id = if assignee_id.is_empty() {
            None
        } else {
            Some(parse_uuid(assignee_id, "assignee_id")?)
        };
    }
    if let Some(ref sprint_id) = req.sprint_id {
        work_item.sprint_id = if sprint_id.is_empty() {
            None
        } else {
            Some(parse_uuid(sprint_id, "sprint_id")?)
        };
    }
    if let Some(position) = req.position {
        if position < 0 {
            return Err(WsError::ValidationError {
                message: "Position must be non-negative".to_string(),
                field: Some("position".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        work_item.position = position;
    }
    if let Some(story_points) = req.story_points {
        if story_points < 0 || story_points > 100 {
            return Err(WsError::ValidationError {
                message: "Story points must be 0-100".to_string(),
                field: Some("story_points".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        work_item.story_points = Some(story_points);
    }
    Ok(())
}

// NOTE: These functions are `pub` so property tests can access them
pub fn validate_status(status: &str) -> Result<(), WsError> {
    match status {
        "todo" | "in_progress" | "review" | "done" | "blocked" => Ok(()),
        _ => Err(WsError::ValidationError {
            message: format!(
                "Invalid status: {}. Valid: todo, in_progress, review, done, blocked",
                status
            ),
            field: Some("status".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }),
    }
}

pub fn validate_priority(priority: &str) -> Result<(), WsError> {
    match priority {
        "low" | "medium" | "high" | "critical" => Ok(()),
        _ => Err(WsError::ValidationError {
            message: format!(
                "Invalid priority: {}. Valid: low, medium, high, critical",
                priority
            ),
            field: Some("priority".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }),
    }
}

pub fn sanitize_string(s: &str) -> String {
    s.replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('&', "&amp;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
        .trim()
        .to_string()
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod work_item;
```

**Verification**: `cargo check -p pm-ws`

---

### Step 5: Create Query Handlers

**Create**: `backend/crates/pm-ws/src/handlers/query.rs`

```rust
use crate::handlers::{
    context::HandlerContext,
    db_ops::db_read,
    authorization::check_permission,
    response_builder::build_work_items_response,
};
use crate::{Result as WsErrorResult, WsError};
use pm_core::Permission;
use pm_db::WorkItemRepository;
use pm_proto::{GetWorkItemsRequest, WebSocketMessage};
use error_location::ErrorLocation;
use std::panic::Location;
use uuid::Uuid;

/// Handle GetWorkItemsRequest
pub async fn handle_get_work_items(
    req: GetWorkItemsRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} GetWorkItems starting", ctx.log_prefix());

    // 1. Parse project ID
    let project_id = Uuid::parse_str(&req.project_id).map_err(|_| WsError::ValidationError {
        message: format!("Invalid project_id: {}", req.project_id),
        field: Some("project_id".to_string()),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 2. Authorization - View permission required
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, project_id, Permission::View).await
    })
    .await?;

    // 3. Parse optional parent_id filter
    let parent_id = match &req.parent_id {
        Some(id) if !id.is_empty() => {
            Some(Uuid::parse_str(id).map_err(|_| WsError::ValidationError {
                message: format!("Invalid parent_id: {}", id),
                field: Some("parent_id".to_string()),
                location: ErrorLocation::from(Location::caller()),
            })?)
        }
        _ => None,
    };

    // 4. Fetch work items with circuit breaker
    let work_items = db_read(&ctx, "find_work_items", || async {
        if let Some(pid) = parent_id {
            WorkItemRepository::find_children(&ctx.pool, pid)
                .await
                .map_err(WsError::from)
        } else {
            WorkItemRepository::find_by_project(&ctx.pool, project_id)
                .await
                .map_err(WsError::from)
        }
    })
    .await?;

    log::info!(
        "{} Found {} work items for project {}",
        ctx.log_prefix(),
        work_items.len(),
        project_id
    );

    Ok(build_work_items_response(&ctx.message_id, &work_items))
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod query;
```

**Verification**: `cargo check -p pm-ws`

---

### Step 6: Create Dispatcher

**Create**: `backend/crates/pm-ws/src/handlers/dispatcher.rs`

```rust
use crate::handlers::{
    context::HandlerContext,
    work_item,
    query,
    response_builder::build_error_response,
};
use crate::{log_handler_entry, WsError};
use pm_proto::{WebSocketMessage, web_socket_message::Payload, Pong};
use error_location::ErrorLocation;
use std::panic::Location;

/// Dispatch incoming WebSocket message to appropriate handler.
/// Includes:
/// - Correlation ID tracking
/// - Structured logging
/// - Timeout protection
/// - Circuit breaker awareness
pub async fn dispatch(msg: WebSocketMessage, ctx: HandlerContext) -> WebSocketMessage {
    let message_id = msg.message_id.clone();
    let handler_name = payload_to_handler_name(&msg.payload);

    log_handler_entry!(ctx.request_ctx, handler_name);

    // Wrap handler execution with timeout
    let response = tokio::time::timeout(
        std::time::Duration::from_secs(30),
        dispatch_inner(msg, ctx.clone()),
    )
    .await;

    let final_response = match response {
        Ok(resp) => resp,
        Err(_elapsed) => {
            log::error!(
                "{} Handler {} timed out after 30s",
                ctx.log_prefix(),
                handler_name
            );
            build_error_response(
                &message_id,
                pm_proto::Error {
                    code: "TIMEOUT".to_string(),
                    message: "Request timed out. Please try again.".to_string(),
                    field: None,
                },
            )
        }
    };

    log::info!(
        "{} <- {} completed in {}ms",
        ctx.log_prefix(),
        handler_name,
        ctx.request_ctx.elapsed_ms()
    );

    final_response
}

async fn dispatch_inner(msg: WebSocketMessage, ctx: HandlerContext) -> WebSocketMessage {
    let message_id = msg.message_id.clone();

    let result = match msg.payload {
        Some(Payload::CreateWorkItemRequest(req)) => {
            work_item::handle_create(req, ctx).await
        }
        Some(Payload::UpdateWorkItemRequest(req)) => {
            work_item::handle_update(req, ctx).await
        }
        Some(Payload::DeleteWorkItemRequest(req)) => {
            work_item::handle_delete(req, ctx).await
        }
        Some(Payload::GetWorkItemsRequest(req)) => {
            query::handle_get_work_items(req, ctx).await
        }
        Some(Payload::Ping(ping)) => {
            return WebSocketMessage {
                message_id,
                timestamp: chrono::Utc::now().timestamp(),
                payload: Some(Payload::Pong(Pong {
                    timestamp: ping.timestamp,
                })),
            };
        }
        Some(Payload::Subscribe(_)) | Some(Payload::Unsubscribe(_)) => {
            return build_error_response(
                &message_id,
                pm_proto::Error {
                    code: "NOT_IMPLEMENTED".to_string(),
                    message: "Subscription handling coming in Session 20".to_string(),
                    field: None,
                },
            );
        }
        _ => {
            Err(WsError::InvalidMessage {
                message: "Unsupported or missing message payload".to_string(),
                location: ErrorLocation::from(Location::caller()),
            })
        }
    };

    match result {
        Ok(response) => response,
        Err(e) => build_error_response(&message_id, e.to_proto_error()),
    }
}

fn payload_to_handler_name(payload: &Option<Payload>) -> &'static str {
    match payload {
        Some(Payload::CreateWorkItemRequest(_)) => "CreateWorkItem",
        Some(Payload::UpdateWorkItemRequest(_)) => "UpdateWorkItem",
        Some(Payload::DeleteWorkItemRequest(_)) => "DeleteWorkItem",
        Some(Payload::GetWorkItemsRequest(_)) => "GetWorkItems",
        Some(Payload::Subscribe(_)) => "Subscribe",
        Some(Payload::Unsubscribe(_)) => "Unsubscribe",
        Some(Payload::Ping(_)) => "Ping",
        _ => "Unknown",
    }
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod dispatcher;
```

**Verification**: `cargo check -p pm-ws`

---

## Session 10.2 Completion Checklist

After completing all steps:

- [ ] `cargo check -p pm-ws` passes
- [ ] `cargo check --workspace` passes
- [ ] `cargo test -p pm-ws` passes
- [ ] `cargo clippy -p pm-ws` passes

### Files Created (5)
- `pm-ws/src/handlers/db_ops.rs`
- `pm-ws/src/handlers/error_boundary.rs`
- `pm-ws/src/handlers/work_item.rs`
- `pm-ws/src/handlers/query.rs`
- `pm-ws/src/handlers/dispatcher.rs`

### Files Modified (2)
- `pm-ws/src/handlers/context.rs`
- `pm-ws/src/handlers/mod.rs`

---

## Next Session

**Session 10.3** will implement:
- Final module exports in lib.rs
- Server integration (main.rs, health.rs, error.rs)
- AppState updates with pool and circuit breaker
- WebSocket connection wiring to dispatcher
- Property-based tests
- Integration tests
