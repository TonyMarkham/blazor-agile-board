# Session 100.1: API Foundation

**Parent Plan**: `100-Session-Plan.md`
**Target**: ~40k tokens
**Prerequisites**: Existing codebase compiles (`cargo check --workspace`)

---

## Scope

This session sets up the foundation infrastructure that all REST API handlers will depend on:

1. **Cargo Dependencies** - Add clap, reqwest, pm-cli to workspace
2. **API Config** - LLM user ID and name configuration
3. **API Error Types** - REST-specific errors with HTTP status codes
4. **User ID Extractor** - Axum extractor for authentication
5. **AppState Extension** - Add api_config field

---

## Implementation Order

### Step 1: Update Root Cargo.toml

**Why First:** All subsequent steps depend on having the dependencies and workspace member defined.

**File:** `Cargo.toml` (root, MODIFY)

Add to `[workspace.dependencies]`:
```toml
# CLI dependencies
clap = { version = "4.5", features = ["derive"] }
reqwest = { version = "0.12", features = ["json", "rustls-tls"], default-features = false }
```

Add to `[workspace.members]`:
```toml
members = [
    # ... existing members ...
    "backend/crates/pm-cli",
]
```

**Verification:** `cargo check --workspace` (will warn about missing pm-cli, that's OK for now)

---

### Step 2: Update pm-ws Cargo.toml

**Why:** pm-ws needs pm-config to access ApiConfig for the extractors.

**File:** `backend/crates/pm-ws/Cargo.toml` (MODIFY)

Add to `[dependencies]`:
```toml
pm-config = { workspace = true }
```

**Verification:** `cargo check -p pm-ws`

---

### Step 3: Create API Config

**File:** `backend/crates/pm-config/src/api_config.rs` (NEW)

```rust
use serde::Deserialize;
use uuid::Uuid;

/// Default LLM user UUID - a well-known value for the system LLM user
pub const DEFAULT_LLM_USER_ID: &str = "00000000-0000-0000-0000-000000000001";
/// Default display name for the LLM user
pub const DEFAULT_LLM_USER_NAME: &str = "Claude Assistant";

/// Configuration for the REST API layer
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct ApiConfig {
    /// Whether the REST API is enabled
    pub enabled: bool,
    /// UUID for the LLM user (used when no X-User-Id header provided)
    pub llm_user_id: String,
    /// Display name for the LLM user
    pub llm_user_name: String,
}

impl Default for ApiConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            llm_user_id: DEFAULT_LLM_USER_ID.to_string(),
            llm_user_name: DEFAULT_LLM_USER_NAME.to_string(),
        }
    }
}

impl ApiConfig {
    /// Parse the LLM user ID as a UUID
    /// Falls back to the default if parsing fails
    pub fn llm_user_uuid(&self) -> Uuid {
        Uuid::parse_str(&self.llm_user_id).unwrap_or_else(|_| {
            Uuid::parse_str(DEFAULT_LLM_USER_ID).expect("Default LLM user ID is valid")
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_api_config() {
        let config = ApiConfig::default();
        assert!(config.enabled);
        assert_eq!(config.llm_user_id, DEFAULT_LLM_USER_ID);
        assert_eq!(config.llm_user_name, DEFAULT_LLM_USER_NAME);
    }

    #[test]
    fn test_llm_user_uuid_valid() {
        let config = ApiConfig::default();
        let uuid = config.llm_user_uuid();
        assert_eq!(uuid.to_string(), DEFAULT_LLM_USER_ID);
    }

    #[test]
    fn test_llm_user_uuid_invalid_falls_back() {
        let config = ApiConfig {
            llm_user_id: "not-a-uuid".to_string(),
            ..Default::default()
        };
        let uuid = config.llm_user_uuid();
        assert_eq!(uuid.to_string(), DEFAULT_LLM_USER_ID);
    }
}
```

**Teaching Point:** We use a well-known UUID for the LLM user so it's consistent across deployments. This makes it easy to identify actions taken by AI assistants in the audit log.

---

### Step 4: Update pm-config lib.rs

**File:** `backend/crates/pm-config/src/lib.rs` (MODIFY)

Add module declaration and export at the top of the file:
```rust
mod api_config;
pub use api_config::ApiConfig;
```

Find the `Config` struct and add the api field:
```rust
pub struct Config {
    // ... existing fields ...

    /// REST API configuration
    #[serde(default)]
    pub api: ApiConfig,
}
```

**Verification:** `cargo check -p pm-config && cargo test -p pm-config`

---

### Step 5: Create API Error Types

**File:** `backend/pm-server/src/api/error.rs` (NEW)

```rust
//! REST API error types
//!
//! These errors are designed to produce consistent JSON responses
//! with appropriate HTTP status codes.

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

/// JSON error response body
#[derive(Debug, Serialize)]
pub struct ApiErrorResponse {
    pub error: ApiErrorBody,
}

/// Inner error body with code, message, and optional field
#[derive(Debug, Serialize)]
pub struct ApiErrorBody {
    /// Machine-readable error code (e.g., "NOT_FOUND", "VALIDATION_ERROR")
    pub code: String,
    /// Human-readable error message
    pub message: String,
    /// Field name if this is a validation error for a specific field
    #[serde(skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
}

/// API errors with associated HTTP status codes
#[derive(Debug)]
pub enum ApiError {
    /// Resource not found (404)
    NotFound(String),
    /// Validation error (400)
    Validation { message: String, field: Option<String> },
    /// Version conflict for optimistic locking (409)
    Conflict { message: String, current_version: i32 },
    /// Internal server error (500)
    Internal(String),
    /// Bad request (400)
    BadRequest(String),
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, body) = match self {
            ApiError::NotFound(msg) => (
                StatusCode::NOT_FOUND,
                ApiErrorBody {
                    code: "NOT_FOUND".into(),
                    message: msg,
                    field: None,
                },
            ),
            ApiError::Validation { message, field } => (
                StatusCode::BAD_REQUEST,
                ApiErrorBody {
                    code: "VALIDATION_ERROR".into(),
                    message,
                    field,
                },
            ),
            ApiError::Conflict { message, current_version } => (
                StatusCode::CONFLICT,
                ApiErrorBody {
                    code: "CONFLICT".into(),
                    message: format!("{} (current version: {})", message, current_version),
                    field: None,
                },
            ),
            ApiError::Internal(msg) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                ApiErrorBody {
                    code: "INTERNAL_ERROR".into(),
                    message: msg,
                    field: None,
                },
            ),
            ApiError::BadRequest(msg) => (
                StatusCode::BAD_REQUEST,
                ApiErrorBody {
                    code: "BAD_REQUEST".into(),
                    message: msg,
                    field: None,
                },
            ),
        };

        (status, Json(ApiErrorResponse { error: body })).into_response()
    }
}

/// Convert sqlx errors to API errors
impl From<sqlx::Error> for ApiError {
    fn from(e: sqlx::Error) -> Self {
        // Don't expose internal database details to clients
        log::error!("Database error: {}", e);
        ApiError::Internal("Database operation failed".to_string())
    }
}

/// Convert UUID parse errors to API errors
impl From<uuid::Error> for ApiError {
    fn from(e: uuid::Error) -> Self {
        ApiError::Validation {
            message: format!("Invalid UUID format: {}", e),
            field: None,
        }
    }
}

/// Convert pm-ws errors to API errors
impl From<pm_ws::WsError> for ApiError {
    fn from(e: pm_ws::WsError) -> Self {
        // Map WsError variants to appropriate ApiError variants
        match e {
            pm_ws::WsError::NotFound { message, .. } => ApiError::NotFound(message),
            pm_ws::WsError::ValidationError { message, field, .. } => {
                ApiError::Validation { message, field }
            }
            pm_ws::WsError::ConflictError { current_version, .. } => {
                ApiError::Conflict {
                    message: "Version mismatch".to_string(),
                    current_version,
                }
            }
            pm_ws::WsError::Unauthorized { message, .. } => {
                ApiError::BadRequest(format!("Unauthorized: {}", message))
            }
            _ => ApiError::Internal(e.to_string()),
        }
    }
}
```

**Teaching Point:** The `IntoResponse` trait lets Axum automatically convert our error type into an HTTP response. We return JSON with appropriate status codes so CLI tools can easily parse errors.

---

### Step 6: Create User ID Extractor

**File:** `backend/pm-server/src/api/extractors.rs` (NEW)

```rust
//! Axum extractors for REST API authentication
//!
//! These extractors run before handlers and extract information from the request.

use axum::{
    extract::FromRequestParts,
    http::request::Parts,
};
use uuid::Uuid;

use crate::api::error::ApiError;
use pm_ws::AppState;

/// Extracts the user ID from the request
///
/// Checks for `X-User-Id` header first. If not present, falls back to
/// the configured LLM user ID from api_config.
///
/// # Example
///
/// ```ignore
/// async fn my_handler(
///     UserId(user_id): UserId,
/// ) -> Result<(), ApiError> {
///     // user_id is a Uuid
/// }
/// ```
pub struct UserId(pub Uuid);

#[axum::async_trait]
impl FromRequestParts<AppState> for UserId {
    type Rejection = ApiError;

    async fn from_request_parts(
        parts: &mut Parts,
        state: &AppState,
    ) -> Result<Self, Self::Rejection> {
        let headers = &parts.headers;

        // Try X-User-Id header first
        if let Some(header_value) = headers.get("X-User-Id") {
            if let Ok(user_id_str) = header_value.to_str() {
                if let Ok(uuid) = Uuid::parse_str(user_id_str) {
                    log::debug!("Using user ID from X-User-Id header: {}", uuid);
                    return Ok(UserId(uuid));
                }
                // Invalid UUID in header - fall through to default
                log::warn!("Invalid UUID in X-User-Id header: {}", user_id_str);
            }
        }

        // Fall back to configured LLM user ID
        let llm_user_id = state.api_config.llm_user_uuid();
        log::debug!("Using default LLM user ID: {}", llm_user_id);

        Ok(UserId(llm_user_id))
    }
}
```

**Teaching Point:** Axum extractors are powerful for DRY authentication. The extractor runs automatically before any handler that declares `UserId(user_id): UserId` in its parameters. This keeps handlers focused on business logic.

---

### Step 7: Create API Module

**File:** `backend/pm-server/src/api/mod.rs` (NEW)

```rust
//! REST API module for LLM and CLI access
//!
//! This module provides HTTP endpoints that:
//! - Accept JSON requests
//! - Return JSON responses
//! - Broadcast changes via WebSocket for real-time updates
//!
//! All endpoints use the same validation and business logic as WebSocket handlers.

pub mod error;
pub mod extractors;

pub use error::ApiError;
pub use extractors::UserId;
```

**Verification:** `cargo check -p pm-server` (will have unused module warning, that's OK)

---

### Step 8: Update AppState

**File:** `backend/crates/pm-ws/src/app_state.rs` (MODIFY)

Add import at the top:
```rust
use pm_config::ApiConfig;
```

Add field to `AppState` struct:
```rust
/// Shared application state for WebSocket handlers
#[derive(Clone)]
pub struct AppState {
    pub pool: SqlitePool,
    pub circuit_breaker: Arc<CircuitBreaker>,
    pub jwt_validator: Option<Arc<JwtValidator>>,
    pub desktop_user_id: String,
    pub rate_limiter_factory: RateLimiterFactory,
    pub registry: ConnectionRegistry,
    pub metrics: Metrics,
    pub shutdown: ShutdownCoordinator,
    pub config: ConnectionConfig,
    pub api_config: ApiConfig,  // NEW: REST API configuration
}
```

**Verification:** `cargo check -p pm-ws`

---

### Step 9: Update pm-server main.rs

**File:** `backend/pm-server/src/main.rs` (MODIFY)

Add module declaration:
```rust
mod api;
```

Find where `AppState` is constructed and add the api_config field:
```rust
let app_state = AppState {
    pool,
    circuit_breaker,
    jwt_validator,
    desktop_user_id,
    rate_limiter_factory,
    registry,
    metrics,
    shutdown: shutdown.clone(),
    config: connection_config,
    api_config: config.api.clone(),  // NEW
};
```

**Verification:** `cargo check -p pm-server`

---

### Step 10: Create Error Tests

**File:** `backend/pm-server/src/api/error.rs` (MODIFY - add tests at bottom)

Add `#[cfg(test)]` module at the end of the file:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::Request;
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_not_found_returns_404_with_json_body() {
        let error = ApiError::NotFound("Item not found".into());
        let response = error.into_response();

        assert_eq!(response.status(), StatusCode::NOT_FOUND);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(json["error"]["code"], "NOT_FOUND");
        assert_eq!(json["error"]["message"], "Item not found");
    }

    #[tokio::test]
    async fn test_validation_error_returns_400_with_field() {
        let error = ApiError::Validation {
            message: "Title too long".into(),
            field: Some("title".into()),
        };
        let response = error.into_response();

        assert_eq!(response.status(), StatusCode::BAD_REQUEST);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(json["error"]["code"], "VALIDATION_ERROR");
        assert_eq!(json["error"]["field"], "title");
    }

    #[tokio::test]
    async fn test_conflict_error_returns_409_with_version() {
        let error = ApiError::Conflict {
            message: "Version mismatch".into(),
            current_version: 5,
        };
        let response = error.into_response();

        assert_eq!(response.status(), StatusCode::CONFLICT);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(json["error"]["code"], "CONFLICT");
        assert!(json["error"]["message"].as_str().unwrap().contains("5"));
    }

    #[tokio::test]
    async fn test_internal_error_returns_500() {
        let error = ApiError::Internal("Database connection failed".into());
        let response = error.into_response();

        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(json["error"]["code"], "INTERNAL_ERROR");
    }

    #[test]
    fn test_uuid_error_converts_to_validation() {
        let uuid_err = uuid::Uuid::parse_str("not-a-uuid").unwrap_err();
        let api_err: ApiError = uuid_err.into();

        match api_err {
            ApiError::Validation { message, field } => {
                assert!(message.contains("Invalid UUID"));
                assert!(field.is_none());
            }
            _ => panic!("Expected Validation error"),
        }
    }
}
```

**Verification:** `cargo test -p pm-server api::error::tests`

---

### Step 11: Create Extractor Tests

**File:** `backend/pm-server/src/api/extractors.rs` (MODIFY - add tests at bottom)

Add `#[cfg(test)]` module at the end of the file:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::http::{Request, HeaderValue};
    use axum::body::Body;
    use std::sync::Arc;
    use pm_ws::{CircuitBreaker, CircuitBreakerConfig, ConnectionRegistry, Metrics, ShutdownCoordinator, RateLimiterFactory, ConnectionConfig};
    use sqlx::SqlitePool;

    async fn create_test_state() -> AppState {
        let pool = SqlitePool::connect(":memory:")
            .await
            .expect("Failed to create test pool");

        sqlx::migrate!("../crates/pm-db/migrations")
            .run(&pool)
            .await
            .expect("Failed to run migrations");

        let (shutdown, _) = ShutdownCoordinator::new();

        AppState {
            pool,
            circuit_breaker: Arc::new(CircuitBreaker::new(CircuitBreakerConfig::default())),
            jwt_validator: None,
            desktop_user_id: "desktop-user".to_string(),
            rate_limiter_factory: RateLimiterFactory::new(100, 60),
            registry: ConnectionRegistry::new(10000),
            metrics: Metrics::new(),
            shutdown,
            config: ConnectionConfig::default(),
            api_config: pm_config::ApiConfig::default(),
        }
    }

    #[tokio::test]
    async fn test_extractor_with_valid_header() {
        let state = create_test_state().await;
        let mut request = Request::builder()
            .header("X-User-Id", "12345678-1234-1234-1234-123456789abc")
            .body(Body::empty())
            .unwrap();

        let (mut parts, _body) = request.into_parts();
        let result = UserId::from_request_parts(&mut parts, &state).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap().0.to_string(), "12345678-1234-1234-1234-123456789abc");
    }

    #[tokio::test]
    async fn test_extractor_falls_back_to_llm_user_when_missing() {
        let state = create_test_state().await;
        let mut request = Request::builder()
            .body(Body::empty())
            .unwrap();

        let (mut parts, _body) = request.into_parts();
        let result = UserId::from_request_parts(&mut parts, &state).await;

        assert!(result.is_ok());
        let user_id = result.unwrap().0;
        assert_eq!(user_id, state.api_config.llm_user_uuid());
    }

    #[tokio::test]
    async fn test_extractor_falls_back_when_header_invalid_uuid() {
        let state = create_test_state().await;
        let mut request = Request::builder()
            .header("X-User-Id", "not-a-valid-uuid")
            .body(Body::empty())
            .unwrap();

        let (mut parts, _body) = request.into_parts();
        let result = UserId::from_request_parts(&mut parts, &state).await;

        assert!(result.is_ok());
        let user_id = result.unwrap().0;
        assert_eq!(user_id, state.api_config.llm_user_uuid());
    }

    #[tokio::test]
    async fn test_extractor_preserves_custom_llm_user_id() {
        let pool = SqlitePool::connect(":memory:")
            .await
            .expect("Failed to create test pool");

        sqlx::migrate!("../crates/pm-db/migrations")
            .run(&pool)
            .await
            .expect("Failed to run migrations");

        let (shutdown, _) = ShutdownCoordinator::new();

        let custom_llm_id = "99999999-9999-9999-9999-999999999999";
        let mut custom_config = pm_config::ApiConfig::default();
        custom_config.llm_user_id = custom_llm_id.to_string();

        let state = AppState {
            pool,
            circuit_breaker: Arc::new(CircuitBreaker::new(CircuitBreakerConfig::default())),
            jwt_validator: None,
            desktop_user_id: "desktop-user".to_string(),
            rate_limiter_factory: RateLimiterFactory::new(100, 60),
            registry: ConnectionRegistry::new(10000),
            metrics: Metrics::new(),
            shutdown,
            config: ConnectionConfig::default(),
            api_config: custom_config,
        };

        let mut request = Request::builder()
            .body(Body::empty())
            .unwrap();

        let (mut parts, _body) = request.into_parts();
        let result = UserId::from_request_parts(&mut parts, &state).await;

        assert!(result.is_ok());
        let user_id = result.unwrap().0;
        assert_eq!(user_id.to_string(), custom_llm_id);
    }
}
```

**Teaching Point:** These integration tests verify the ACTUAL auth logic - not just UUID parsing. They test:
- Valid header is extracted correctly
- Missing header falls back to LLM user
- Invalid UUID in header falls back to LLM user
- Custom LLM user ID is respected

This is YOUR authentication layer - it needs comprehensive tests.

**Verification:** `cargo test -p pm-server api::extractors::tests`

---

## Session 100.1 Completion Checklist

After completing all steps:

- [ ] `cargo check -p pm-config` passes
- [ ] `cargo check -p pm-ws` passes
- [ ] `cargo check -p pm-server` passes
- [ ] `cargo test -p pm-config` passes (api_config tests)
- [ ] `cargo test -p pm-server api::error::tests` passes (error tests)
- [ ] `cargo test -p pm-server api::extractors::tests` passes (extractor tests)
- [ ] `cargo check --workspace` passes (with pm-cli warning, OK for now)

### Files Created (4)
- `pm-config/src/api_config.rs`
- `pm-server/src/api/mod.rs`
- `pm-server/src/api/error.rs` (with tests)
- `pm-server/src/api/extractors.rs` (with tests)

### Files Modified (4)
- `Cargo.toml` (root)
- `backend/crates/pm-ws/Cargo.toml`
- `backend/crates/pm-config/src/lib.rs`
- `backend/crates/pm-ws/src/app_state.rs`
- `backend/pm-server/src/main.rs`

---

## Next Session

**Session 100.2** will implement:
- Work Item API handlers (create, read, update, delete, list)
- Project API handlers (list, get)
- Comment API handlers (create, read, update, delete, list)
- API routes registration
- LLM user initialization in database

---

## Key Takeaways

1. **Dependency Order Matters** - Cargo.toml changes must come first
2. **Extractors Simplify Auth** - Axum extractors handle auth before handlers run
3. **Error Consistency** - JSON error format with codes enables programmatic error handling
4. **Well-Known IDs** - Using a fixed UUID for the LLM user aids debugging and auditing
