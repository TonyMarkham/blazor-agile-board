# Session 101.1: Work Item CRUD Broadcasts

**Parent Plan**: `101-Session-Plan.md`
**Status**: Verified and ready for implementation
**Prerequisites**: `cargo check --workspace` passes

---

## Scope

Add broadcast calls for WorkItem create/update/delete events to enable real-time sync:

1. **New method** - `broadcast_to_project()` in `connection_registry.rs`
2. **WebSocket Handlers** - `pm-ws/src/handlers/work_item.rs`
3. **REST API Handlers** - `pm-server/src/api/work_items/work_items.rs`

---

## Verified Response Builder Signatures

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

```rust
pub fn build_work_item_created_response(message_id: &str, work_item: &WorkItem, actor_id: Uuid) -> WebSocketMessage  // line 40
pub fn build_work_item_updated_response(message_id: &str, work_item: &WorkItem, changes: &[FieldChange], actor_id: Uuid) -> WebSocketMessage  // line 56
pub fn build_work_item_deleted_response(message_id: &str, work_item_id: Uuid, actor_id: Uuid) -> WebSocketMessage  // line 74
```

**NOTE**: Original plan incorrectly showed `&project.key` parameter. The actual signatures do NOT have this.

---

## Implementation Order

### Step 1: Add `broadcast_to_project()` Method

**File**: `backend/crates/pm-ws/src/connection_registry.rs`

**Insert after line 206** (after `broadcast_activity_log_created` method ends with `Ok(delivered)` and `}`, before the closing `impl` brace):

```rust
    /// Broadcast any message to all clients subscribed to a project
    pub async fn broadcast_to_project(
        &self,
        project_id: &str,
        message: Message,
    ) -> WsErrorResult<usize> {
        let inner = self.inner.read().await;
        let connections: Vec<(ClientSubscriptions, mpsc::Sender<Message>)> = inner
            .connections
            .values()
            .map(|info| (info.subscriptions.clone(), info.sender.clone()))
            .collect();
        drop(inner);

        let mut delivered = 0;
        for (subscriptions, sender) in connections {
            if subscriptions.is_subscribed_to_project(project_id) {
                if sender.send(message.clone()).await.is_ok() {
                    delivered += 1;
                }
            }
        }

        Ok(delivered)
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 2: WebSocket - Create Work Item Broadcast

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

**Current code at lines 162-173**:
```rust
    // 10. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    // 11. Build response
    let response = build_work_item_created_response(&ctx.message_id, &work_item, ctx.user_id);
```

**Insert after line 170** (after `.await?;`, before `// 11. Build response`):

```rust
    // 10b. Broadcast WorkItemCreated to all project subscribers
    let broadcast = build_work_item_created_response(
        &Uuid::new_v4().to_string(),
        &work_item,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast WorkItemCreated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 3: WebSocket - Update Work Item Broadcast

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

**Current code at lines 308-323**:
```rust
    // 9. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    info!(
        "{} Updated work item {} (version {})",
        ctx.log_prefix(),
        work_item.id,
        work_item.version
    );
```

**Insert after line 316** (after `.await?;`, before `info!`):

```rust
    // 9b. Broadcast WorkItemUpdated to all project subscribers
    let broadcast = build_work_item_updated_response(
        &Uuid::new_v4().to_string(),
        &work_item,
        &changes,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast WorkItemUpdated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 4: WebSocket - Delete Work Item Broadcast

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

**Current code at lines 393-403**:
```rust
    // 6. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item_id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    info!("{} Deleted work item {}", ctx.log_prefix(), work_item_id);
```

**Insert after line 401** (after `.await?;`, before `info!`):

```rust
    // 6b. Broadcast WorkItemDeleted to all project subscribers
    let broadcast = build_work_item_deleted_response(
        &Uuid::new_v4().to_string(),
        work_item_id,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast WorkItemDeleted: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 5: REST API - Create Work Item Broadcast

**File**: `backend/pm-server/src/api/work_items/work_items.rs`

**Update imports** (lines 13-16, add response builders):
```rust
use pm_ws::{
    AppState, MessageValidator, build_activity_log_created_event,
    build_work_item_created_response, build_work_item_updated_response,
    build_work_item_deleted_response, sanitize_string,
    validate_hierarchy, validate_priority, validate_status,
};
```

**Current code at lines 218-239**:
```rust
    // 9. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &project_id.to_string(),
            Some(&work_item.id.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast work item creation to WebSocket clients: {}",
            e
        );
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!(
```

**Insert after line 237** (after closing `}`, before `log::info!`):

```rust
    // 9b. Broadcast WorkItemCreated to all project subscribers
    let broadcast = build_work_item_created_response(
        &Uuid::new_v4().to_string(),
        &work_item,
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast WorkItemCreated via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

### Step 6: REST API - Update Work Item Broadcast

**File**: `backend/pm-server/src/api/work_items/work_items.rs`

**Current code at lines 359-380**:
```rust
    // 7. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &work_item.project_id.to_string(),
            Some(&work_item.id.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast work item update to WebSocket clients: {}",
            e
        );
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!(
```

**Insert after line 378** (after closing `}`, before `log::info!`):

```rust
    // 7b. Broadcast WorkItemUpdated to all project subscribers
    let broadcast = build_work_item_updated_response(
        &Uuid::new_v4().to_string(),
        &work_item,
        &[], // REST API doesn't track field changes currently
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&work_item.project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast WorkItemUpdated via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

### Step 7: REST API - Delete Work Item Broadcast

**File**: `backend/pm-server/src/api/work_items/work_items.rs`

**Current code at lines 431-452**:
```rust
    // 4. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &work_item.project_id.to_string(),
            Some(&work_item_id.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast work item deletion to WebSocket clients: {}",
            e
        );
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!("Deleted work item {} via REST API", work_item_id);
```

**Insert after line 450** (after closing `}`, before `log::info!`):

```rust
    // 4b. Broadcast WorkItemDeleted to all project subscribers
    let broadcast = build_work_item_deleted_response(
        &Uuid::new_v4().to_string(),
        work_item_id,
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&work_item.project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast WorkItemDeleted via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

## Session Completion Checklist

- [ ] `cargo check --workspace` passes
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] CLI create triggers UI update
- [ ] Multi-window create sync works
- [ ] Multi-window update sync works
- [ ] Multi-window delete sync works

---

## Files Modified

| File | Changes |
|------|---------|
| `pm-ws/src/connection_registry.rs` | Add `broadcast_to_project()` method (line 206) |
| `pm-ws/src/handlers/work_item.rs` | Add 3 broadcast calls (lines 170, 316, 401) |
| `pm-server/src/api/work_items/work_items.rs` | Add imports + 3 broadcast calls (lines 237, 378, 450) |

---

## Next Session

**Session 101.2** will add Sprint broadcasts following the same pattern.
