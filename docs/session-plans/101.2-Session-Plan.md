# Session 101.2: Sprint CRUD Broadcasts

**Parent Plan**: `101-Session-Plan.md`
**Status**: Verified and ready for implementation
**Prerequisites**: Session 101.1 complete, `cargo check --workspace` passes

---

## Scope

Add broadcast calls for Sprint create/update/delete events to enable real-time sync:

1. **WebSocket Handlers** - `pm-ws/src/handlers/sprint.rs`

Note: REST API does not currently have Sprint endpoints (Sprints are managed via WebSocket only).

---

## Verified Response Builder Signatures

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

```rust
pub fn build_sprint_created_response(message_id: &str, sprint: &Sprint, actor_id: Uuid) -> WebSocketMessage  // line 222
pub fn build_sprint_updated_response(message_id: &str, sprint: &Sprint, changes: &[FieldChange], actor_id: Uuid) -> WebSocketMessage  // line 238
pub fn build_sprint_deleted_response(message_id: &str, sprint_id: Uuid, actor_id: Uuid) -> WebSocketMessage  // line 256
```

---

## Implementation Order

### Step 1: WebSocket - Create Sprint Broadcast

**File**: `backend/crates/pm-ws/src/handlers/sprint.rs`

**Current code at lines 133-144**:
```rust
    // 8. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = sprint.project_id.to_string();
    let sprint_id_str = sprint.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, None, Some(&sprint_id_str), message)
        .await?;

    // 9. Build response
    let response = build_sprint_created_response(&ctx.message_id, &sprint, ctx.user_id);
```

**Insert after line 141** (after `.await?;`, before `// 9. Build response`):

```rust
    // 8b. Broadcast SprintCreated to all project subscribers
    let broadcast = build_sprint_created_response(
        &Uuid::new_v4().to_string(),
        &sprint,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast SprintCreated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 2: WebSocket - Update Sprint Broadcast

**File**: `backend/crates/pm-ws/src/handlers/sprint.rs`

**Current code at lines 292-307**:
```rust
    // 9. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = sprint.project_id.to_string();
    let sprint_id_str = sprint.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, None, Some(&sprint_id_str), message)
        .await?;

    info!(
        "{} Updated sprint {} (version {})",
        ctx.log_prefix(),
        sprint.id,
        sprint.version
    );
```

**Insert after line 300** (after `.await?;`, before `info!`):

```rust
    // 9b. Broadcast SprintUpdated to all project subscribers
    let broadcast = build_sprint_updated_response(
        &Uuid::new_v4().to_string(),
        &sprint,
        &field_changes,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast SprintUpdated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 3: WebSocket - Delete Sprint Broadcast

**File**: `backend/crates/pm-ws/src/handlers/sprint.rs`

**Current code at lines 412-422**:
```rust
    // Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = sprint.project_id.to_string();
    let sprint_id_str = sprint_id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, None, Some(&sprint_id_str), message)
        .await?;

    info!("{} Deleted sprint {}", ctx.log_prefix(), sprint_id);
```

**Insert after line 420** (after `.await?;`, before `info!`):

```rust
    // Broadcast SprintDeleted to all project subscribers
    let broadcast = build_sprint_deleted_response(
        &Uuid::new_v4().to_string(),
        sprint_id,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast SprintDeleted: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

## Testing

### Test 1: Multi-Window Sprint Create

1. Open Blazor UI in two browser windows
2. Navigate both to the same project's sprint view
3. Create new sprint in Window A
4. Verify sprint appears in Window B without refresh

### Test 2: Multi-Window Sprint Update

1. View sprint list in two windows
2. Update sprint name/dates in Window A
3. Verify changes appear in Window B

### Test 3: Multi-Window Sprint Delete

1. View sprint list in two windows
2. Delete sprint in Window A
3. Verify sprint disappears from Window B

---

## Session Completion Checklist

- [ ] `cargo check --workspace` passes
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] Multi-window sprint create sync works
- [ ] Multi-window sprint update sync works
- [ ] Multi-window sprint delete sync works

---

## Files Modified

| File | Changes |
|------|---------|
| `pm-ws/src/handlers/sprint.rs` | Add 3 broadcast calls (lines 141, 300, 420) |

---

## Next Session

**Session 101.3** will add Comment broadcasts following the same pattern.
