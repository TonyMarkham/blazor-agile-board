# Session 101.3: Comment CRUD Broadcasts

**Parent Plan**: `101-Session-Plan.md`
**Status**: Verified and ready for implementation
**Prerequisites**: Session 101.1 complete, `cargo check --workspace` passes

---

## Scope

Add broadcast calls for Comment create/update/delete events to enable real-time sync:

1. **WebSocket Handlers** - `pm-ws/src/handlers/comment.rs`
2. **REST API Handlers** - `pm-server/src/api/comments/comments.rs`

---

## Verified Response Builder Signatures

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

```rust
pub fn build_comment_created_response(message_id: &str, comment: &Comment, actor_id: Uuid) -> WebSocketMessage  // line 324
pub fn build_comment_updated_response(message_id: &str, comment: &Comment, actor_id: Uuid) -> WebSocketMessage  // line 339
pub fn build_comment_deleted_response(message_id: &str, comment_id: Uuid, actor_id: Uuid) -> WebSocketMessage  // line 354
```

---

## Implementation Order

### Step 1: WebSocket - Create Comment Broadcast

**File**: `backend/crates/pm-ws/src/handlers/comment.rs`

**Current code at lines 104-115**:
```rust
    // 8. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    // 9. Build response
    let response = build_comment_created_response(&ctx.message_id, &comment, ctx.user_id);
```

**Insert after line 112** (after `.await?;`, before `// 9. Build response`):

```rust
    // 8b. Broadcast CommentCreated to all project subscribers
    let broadcast = build_comment_created_response(
        &Uuid::new_v4().to_string(),
        &comment,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast CommentCreated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 2: WebSocket - Update Comment Broadcast

**File**: `backend/crates/pm-ws/src/handlers/comment.rs`

**Current code at lines 205-215**:
```rust
    // 7. Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    info!("{} Updated comment {}", ctx.log_prefix(), comment.id);
```

**Insert after line 213** (after `.await?;`, before `info!`):

```rust
    // 7b. Broadcast CommentUpdated to all project subscribers
    let broadcast = build_comment_updated_response(
        &Uuid::new_v4().to_string(),
        &comment,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast CommentUpdated: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 3: WebSocket - Delete Comment Broadcast

**File**: `backend/crates/pm-ws/src/handlers/comment.rs`

**Current code at lines 277-287**:
```rust
    // Broadcast ActivityLogCreated
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    let project_id_str = work_item.project_id.to_string();
    let work_item_id_str = work_item.id.to_string();
    ctx.registry
        .broadcast_activity_log_created(&project_id_str, Some(&work_item_id_str), None, message)
        .await?;

    info!("{} Deleted comment {}", ctx.log_prefix(), comment_id);
```

**Insert after line 285** (after `.await?;`, before `info!`):

```rust
    // Broadcast CommentDeleted to all project subscribers
    let broadcast = build_comment_deleted_response(
        &Uuid::new_v4().to_string(),
        comment_id,
        ctx.user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = ctx.registry
        .broadcast_to_project(&project_id_str, Message::Binary(broadcast_bytes.into()))
        .await
    {
        warn!("{} Failed to broadcast CommentDeleted: {}", ctx.log_prefix(), e);
    }
```

**Verification**: `cargo check -p pm-ws`

---

### Step 4: REST API - Create Comment Broadcast

**File**: `backend/pm-server/src/api/comments/comments.rs`

**Update imports** (line 10, add response builders):
```rust
use pm_ws::{AppState, MessageValidator, build_activity_log_created_event,
    build_comment_created_response, build_comment_updated_response,
    build_comment_deleted_response, sanitize_string};
```

**Current code at lines 82-102**:
```rust
    // 5. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &work_item.project_id.to_string(),
            Some(&work_item_uuid.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast comment creation to WebSocket clients: {}",
            e
        );
    }

    log::info!(
```

**Insert after line 100** (after closing `}`, before `log::info!`):

```rust
    // 5b. Broadcast CommentCreated to all project subscribers
    let broadcast = build_comment_created_response(
        &Uuid::new_v4().to_string(),
        &comment,
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&work_item.project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast CommentCreated via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

### Step 5: REST API - Update Comment Broadcast

**File**: `backend/pm-server/src/api/comments/comments.rs`

**Current code at lines 158-178**:
```rust
    // 6. Broadcast
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &work_item.project_id.to_string(),
            Some(&comment.work_item_id.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast comment update to WebSocket clients: {}",
            e
        );
    }

    log::info!("Updated comment {} via REST API", comment_uuid);
```

**Insert after line 176** (after closing `}`, before `log::info!`):

```rust
    // 6b. Broadcast CommentUpdated to all project subscribers
    let broadcast = build_comment_updated_response(
        &Uuid::new_v4().to_string(),
        &comment,
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&work_item.project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast CommentUpdated via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

### Step 6: REST API - Delete Comment Broadcast

**File**: `backend/pm-server/src/api/comments/comments.rs`

**Current code at lines 221-241**:
```rust
    // 4. Broadcast
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state
        .registry
        .broadcast_activity_log_created(
            &work_item.project_id.to_string(),
            Some(&comment.work_item_id.to_string()),
            None,
            message,
        )
        .await
    {
        log::warn!(
            "Failed to broadcast comment deletion to WebSocket clients: {}",
            e
        );
    }

    log::info!("Deleted comment {} via REST API", comment_uuid);
```

**Insert after line 239** (after closing `}`, before `log::info!`):

```rust
    // 4b. Broadcast CommentDeleted to all project subscribers
    let broadcast = build_comment_deleted_response(
        &Uuid::new_v4().to_string(),
        comment_uuid,
        user_id,
    );
    let broadcast_bytes = broadcast.encode_to_vec();
    if let Err(e) = state.registry
        .broadcast_to_project(&work_item.project_id.to_string(), Message::Binary(broadcast_bytes.into()))
        .await
    {
        log::warn!("Failed to broadcast CommentDeleted via REST: {}", e);
    }
```

**Verification**: `cargo check -p pm-server`

---

## Testing

### Test 1: CLI Comment Create

```bash
./pm comment create \
  --work-item-id <work-item-id> \
  --content "Test comment broadcast"
```

**Expected**: Comment appears in Blazor UI work item detail without refresh.

### Test 2: Multi-Window Comment Sync

1. Open same work item detail in two browser windows
2. Add comment in Window A
3. Verify comment appears in Window B without refresh

### Test 3: Multi-Window Comment Update

1. View comment thread in two windows
2. Edit comment in Window A
3. Verify edit appears in Window B

### Test 4: Multi-Window Comment Delete

1. View comment thread in two windows
2. Delete comment in Window A
3. Verify comment disappears from Window B

---

## Session Completion Checklist

- [ ] `cargo check --workspace` passes
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] CLI comment create triggers UI update
- [ ] Multi-window comment create sync works
- [ ] Multi-window comment update sync works
- [ ] Multi-window comment delete sync works

---

## Files Modified

| File | Changes |
|------|---------|
| `pm-ws/src/handlers/comment.rs` | Add 3 broadcast calls (lines 112, 213, 285) |
| `pm-server/src/api/comments/comments.rs` | Add imports + 3 broadcast calls (lines 100, 176, 239) |

---

## Session 101 Complete

After completing 101.1, 101.2, and 101.3:

### Final Verification

```bash
cargo check --workspace
cargo test --workspace
cargo clippy --workspace -- -D warnings
```

### Full Integration Test

1. Start server: `cargo run --bin pm-server`
2. Open Blazor UI in 2+ browser windows
3. Test all entity types:
   - Create/update/delete work items
   - Create/update/delete sprints
   - Create/update/delete comments
4. Verify all changes sync in real-time across windows
5. Test CLI commands trigger UI updates

### Success Criteria

- [ ] All CRUD operations sync in real-time
- [ ] CLI commands trigger UI updates
- [ ] No page refresh required
