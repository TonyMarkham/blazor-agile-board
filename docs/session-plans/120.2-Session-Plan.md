# Session 120.2: Server & CLI Integration

**Parent Plan**: `120-Session-Plan.md`
**Prerequisite**: Session 120.1 completed
**Target**: ~25-35k tokens
**Prerequisites**: `just check-rs-config && just test-rs-config` both pass

---

## Scope

This session wires the port file infrastructure into the server and CLI:

1. **Server** - Write port file after bind, clean up on shutdown
2. **CLI** - Auto-discover server URL from port file
3. **Config Files** - Update example and active config to use `port = 0`

---

## Config Directory Location

The port file is written to `<config_dir>/server.json` where `<config_dir>` is:

1. `PM_CONFIG_DIR` environment variable if set
2. Otherwise: `<current_working_directory>/.pm/`

**Default location**: `.pm/server.json`

The `.server/` directory is separate — it holds the `config.toml` working copy. Both `.server/config.toml` and `backend/config.example.toml` need port documentation updates, but the port file itself goes to `.pm/`.

---

## Teaching Notes

### How does the server know its own port?

When you bind to port 0, the OS assigns an ephemeral port. After `TcpListener::bind()` succeeds, you call `listener.local_addr()` to get a `SocketAddr` containing the actual port. This is standard Rust/tokio networking:

```rust
let listener = TcpListener::bind("127.0.0.1:0").await?;
let actual_port = listener.local_addr()?.port(); // e.g., 52431
```

### Why is the port file write non-fatal?

The server should still run even if the port file can't be written (e.g., permissions issue, another server running). The user can always discover the port from the server's log output or use `--server` manually. Making it fatal would break the server for a convenience feature.

### Why does the CLI exit instead of trying the default port?

If no port file exists and no `--server` flag is given, the CLI exits with a clear error message. This is better than silently trying `localhost:8000` because:
- With `DEFAULT_PORT = 0`, there's no meaningful default to try
- A `connection refused` error from reqwest is confusing
- The explicit error message tells the user exactly what to do

### Port 0 tradeoffs

| | Port 0 (auto-assign) | Specific port (e.g., 8000) |
|-|----------------------|---------------------------|
| Multi-repo | No conflicts | Must pick unique ports |
| CLI discovery | Automatic via server.json | Can hardcode URL |
| Webhooks | Port changes every restart | Stable URL |
| Debugging | Check server.json or logs | Predictable |

**Recommendation**: Use port 0 unless you need a stable URL for webhooks or external monitoring.

---

## Prerequisites Check

Before starting, verify Session 120.1 is complete:

```bash
just check-rs-config  # Should pass
just test-rs-config   # Should pass
```

Ensure these exist:
- `pm_config::PortFileInfo` is exported (write, read, read_live, remove, path)
- `pm_config::DEFAULT_PORT` is `0`
- Port 0 passes `ServerConfig::validate()`

---

## Implementation Order

### Step 1: Update Server to Write Port File After Bind

**File**: `backend/pm-server/src/main.rs`

Two changes are needed in this file:

**Change 1** - After `TcpListener::bind()` (lines 185-188), replace the bind block with port file writing:

**Find this code** (lines 185-188):
```rust
    // Create TCP listener
    let bind_addr = config.bind_addr();
    let listener = TcpListener::bind(&bind_addr).await?;
    info!("Server listening on {}", bind_addr);
```

**Replace with:**
```rust
    // Create TCP listener
    let bind_addr = config.bind_addr();
    let listener = TcpListener::bind(&bind_addr).await?;

    // Get actual bound address (important when port is 0 / auto-assigned)
    let actual_addr = listener.local_addr()?;
    info!("Server listening on {}", actual_addr);

    // Write port discovery file for CLI auto-discovery
    match pm_config::PortFileInfo::write(actual_addr.port(), &config.server.host) {
        Ok(path) => info!("Port file written: {}", path.display()),
        Err(e) => warn!("Failed to write port file (CLI auto-discovery may not work): {}", e),
    }
```

**Why `actual_addr` instead of `bind_addr`?** When `config.server.port` is 0, `bind_addr` is `"127.0.0.1:0"`. After binding, `listener.local_addr()` returns the actual assigned port like `127.0.0.1:52431`. We log the actual address so the user can see which port was chosen, and we write the actual port to the port file.

**Change 2** - After the server's `axum::serve()` completes (lines 244-251), add port file cleanup:

**Find this code** (lines 244-251):
```rust
    // Start server with graceful shutdown
    info!("Server ready to accept connections");
    axum::serve(listener, app)
        .with_graceful_shutdown(async move {
            shutdown.subscribe_guard().wait().await;
            info!("Graceful shutdown complete");
        })
        .await?;

    Ok(())
```

**Replace with:**
```rust
    // Start server with graceful shutdown
    info!("Server ready to accept connections");
    axum::serve(listener, app)
        .with_graceful_shutdown(async move {
            shutdown.subscribe_guard().wait().await;
            info!("Graceful shutdown complete");
        })
        .await?;

    // Clean up port discovery file
    if let Err(e) = pm_config::PortFileInfo::remove() {
        warn!("Failed to remove port file: {}", e);
    }

    Ok(())
```

**When does cleanup happen?** The `axum::serve().await?` call blocks until the graceful shutdown completes (triggered by Ctrl+C via the signal handler). After it returns, we clean up the port file. If the server is killed with SIGKILL (which can't be caught), the file remains — but the CLI's `read_live()` detects the stale PID and removes it automatically.

**Verification**: `just check-rs-server`

---

### Step 2: Update CLI to Auto-Discover Server

**File**: `backend/crates/pm-cli/src/main.rs`

Three changes to this file:

**Change 1** - Delete the unused import (line 33):

**Delete this entire line:**
```rust
use pm_config::{DEFAULT_HOST, DEFAULT_PORT};
```

These constants are no longer used in the CLI. The line imports exactly these two and nothing else.

**Change 2** - Replace the hardcoded server URL fallback (lines 43-46):

**Find this code:**
```rust
    // Build server URL from config defaults if not provided
    let server_url = cli
        .server
        .unwrap_or_else(|| format!("http://{}:{}", DEFAULT_HOST, DEFAULT_PORT));
```

**Replace with:**
```rust
    // Discover server URL: explicit flag > port file > error
    let server_url = match cli.server {
        Some(url) => url,
        None => discover_server_url(),
    };
```

**Change 3** - Add the `discover_server_url` function at the bottom of the file (after the `main` function):

```rust
/// Discover the server URL from the port discovery file.
///
/// The pm-server writes a `server.json` file after binding, containing
/// the PID, port, and host. This function reads that file and verifies
/// the server process is still alive.
///
/// Falls back to a clear error message if no server is found.
fn discover_server_url() -> String {
    match pm_config::PortFileInfo::read_live() {
        Ok(Some(info)) => {
            format!("http://{}:{}", info.host, info.port)
        }
        Ok(None) => {
            let port_path = pm_config::PortFileInfo::path()
                .map(|p| p.display().to_string())
                .unwrap_or_else(|_| ".pm/server.json".to_string());

            eprintln!("Error: No running pm-server found.");
            eprintln!();
            eprintln!("Checked: {}", port_path);
            eprintln!();
            eprintln!("Start the server first:");
            eprintln!("  cargo run -p pm-server");
            eprintln!();
            eprintln!("Or specify a server URL explicitly:");
            eprintln!("  pm --server http://127.0.0.1:8000 <command>");
            std::process::exit(1);
        }
        Err(e) => {
            let port_path = pm_config::PortFileInfo::path()
                .map(|p| p.display().to_string())
                .unwrap_or_else(|_| ".pm/server.json".to_string());

            eprintln!("Error reading port file ({}): {}", port_path, e);
            eprintln!();
            eprintln!("Specify a server URL explicitly:");
            eprintln!("  pm --server http://127.0.0.1:8000 <command>");
            std::process::exit(1);
        }
    }
}
```

**Key design decisions:**

1. **`read_live()` not `read()`**: `read_live()` checks the PID and auto-removes stale files. If the server crashed, the CLI won't try to connect to a dead address.

2. **Error messages include the port file path**: Users can verify the file exists (`cat .pm/server.json`) and understand where the CLI looked.

3. **`process::exit(1)` not `panic!()`**: Clean exit with an actionable error message. No stack trace noise.

**Verification**: `just check-rs-cli`

---

### Step 3: Update CLI Help Text

**File**: `backend/crates/pm-cli/src/cli.rs`

Update the help text for the `--server` flag to reflect auto-discovery behavior.

**Find this code** (line 14):
```rust
    /// Server URL (default: http://127.0.0.1:8000)
    #[arg(long, global = true)]
    pub(crate) server: Option<String>,
```

**Replace with:**
```rust
    /// Server URL (auto-discovered from server.json, or specify manually)
    #[arg(long, global = true)]
    pub(crate) server: Option<String>,
```

**Verification**: `just check-rs-cli`

---

### Step 4: Update Config Example

**File**: `backend/config.example.toml`

Update the port configuration comment and default value.

**Find this code** (lines 25-27):
```toml
# Server port (range: 1024-65535, default: 8000)
# Ports below 1024 require root/admin privileges
port = 8000
```

**Replace with:**
```toml
# Server port (0 = auto-assign, or 1024-65535 for a specific port)
#
# Port 0 (auto-assign):
#   - OS picks an available port automatically
#   - Actual port is written to .pm/server.json for CLI auto-discovery
#   - Perfect for multi-repo setups (no conflicts)
#   - Port changes on every restart (not suitable for webhooks)
#
# Specific port (e.g., 8000):
#   - Stable URL for webhooks, bookmarks, monitoring
#   - Conflicts if multiple servers run in different repos
#
# Recommendation: Use 0 unless you need a stable URL for external tools.
port = 0
```

**Verification**: N/A (config file, not compiled)

---

### Step 5: Update Active Config

**File**: `.server/config.toml`

Same change as the example — update the port value.

**Find this code** (lines 25-27):
```toml
# Server port (range: 1024-65535, default: 8000)
# Ports below 1024 require root/admin privileges
port = 8000
```

**Replace with:**
```toml
# Server port (0 = auto-assign, or 1024-65535 for a specific port)
#
# Port 0 (auto-assign):
#   - OS picks an available port automatically
#   - Actual port is written to .pm/server.json for CLI auto-discovery
#   - Perfect for multi-repo setups (no conflicts)
#   - Port changes on every restart (not suitable for webhooks)
#
# Specific port (e.g., 8000):
#   - Stable URL for webhooks, bookmarks, monitoring
#   - Conflicts if multiple servers run in different repos
#
# Recommendation: Use 0 unless you need a stable URL for external tools.
port = 0
```

**Verification**: N/A (config file, not compiled)

---

## Session 120.2 Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes (full workspace)
- [ ] `just test-backend` passes (all existing tests + 120.1 tests)
- [ ] `just clippy-backend` passes (no warnings)
- [ ] Manual: Start server, verify `.pm/server.json` appears with correct port
- [ ] Manual: Run `cargo run -p pm-cli -- project list --pretty` — auto-discovers server
- [ ] Manual: Stop server (Ctrl+C), verify `.pm/server.json` is removed
- [ ] Manual: Run CLI with no server — shows helpful error message with port file path

### Files Modified (5)
- `pm-server/src/main.rs` - Write port file after bind, cleanup on shutdown
- `pm-cli/src/main.rs` - Auto-discover from port file, delete `DEFAULT_HOST`/`DEFAULT_PORT` import
- `pm-cli/src/cli.rs` - Update help text
- `backend/config.example.toml` - Document port 0 with tradeoffs
- `.server/config.toml` - Change port to 0

---

## Manual Verification Script

After implementation, run this end-to-end test:

```bash
#!/bin/bash
set -e

echo "=== Building everything ==="
just check-backend
just test-backend
just clippy-backend

echo "=== Starting server in background ==="
cargo run -p pm-server &
SERVER_PID=$!
sleep 3

echo "=== Checking port file was created ==="
if [ -f ".pm/server.json" ]; then
    echo "OK: Port file exists at .pm/server.json"
    cat .pm/server.json
else
    echo "FAIL: Port file NOT FOUND at .pm/server.json"
    kill $SERVER_PID 2>/dev/null
    exit 1
fi

echo "=== Testing CLI auto-discovery ==="
cargo run -p pm-cli -- project list --pretty

echo "=== Stopping server gracefully ==="
kill -TERM $SERVER_PID
wait $SERVER_PID 2>/dev/null || true
sleep 1

echo "=== Verifying port file was cleaned up ==="
if [ ! -f ".pm/server.json" ]; then
    echo "OK: Port file removed successfully"
else
    echo "FAIL: Port file still exists (cleanup failed)"
    cat .pm/server.json
    exit 1
fi

echo "=== Testing CLI with no server running ==="
cargo run -p pm-cli -- project list 2>&1 && echo "FAIL: Should have failed" || echo "OK: Failed as expected"

echo "=== All tests passed ==="
```

---

## Session 120 Complete

With both sub-sessions done, you have:

1. **Port File Module** (120.1)
   - `PortFileInfo` struct with write/read/read_live/remove/path
   - Cross-platform PID liveness (Unix + Windows + fallback)
   - Race condition protection (refuses to overwrite a live server)
   - Directory creation safety (creates `.pm/` if it doesn't exist)
   - DEFAULT_PORT changed to 0 for auto-assign
   - Port 0 accepted in validation
   - Full test coverage including edge cases

2. **Server & CLI Integration** (120.2)
   - Server writes port file after binding, cleans up on shutdown
   - CLI auto-discovers server URL from port file
   - Actionable error messages with port file path when no server found
   - Config files updated with port 0 default and tradeoff documentation
