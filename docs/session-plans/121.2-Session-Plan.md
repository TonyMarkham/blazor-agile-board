# Session 121.2: Tauri Repo-Awareness

**Parent Plan**: `121-Session-Plan.md`
**Prerequisite**: Session 121.1 completed
**Target**: ~35k tokens

---

## Scope

This sub-session closes the critical directory mismatch bug — the reason `pm project list` can't discover a Tauri-spawned server:

1. **Tauri `lib.rs` Fix** — Check `PM_CONFIG_DIR` before falling back to global app data
2. **`pm desktop` Command** — CLI subcommand that launches Tauri in repo-aware mode
3. **`just dev` Update** — Pass `PM_CONFIG_DIR` for development builds
4. **`CLAUDE_FUCKED_UP.md` Update** — Document the correct fix

### Concepts Taught

- **Environment variable coordination** — How `PM_CONFIG_DIR` flows from CLI to Tauri to pm-server
- **Binary discovery patterns** — Searching multiple locations in priority order
- **The port 0 trap** — Why `TcpListener::bind(("127.0.0.1", 0))` always succeeds

---

## Prerequisites Check

Verify Session 121.1 is complete:

```bash
just check-backend        # Should pass
ls .pm/config.toml        # Should exist (created by just setup-config)
grep 'config_dir := ".pm"' justfile    # Should match
```

---

## Implementation Order

### Step 1: Make Tauri Respect `PM_CONFIG_DIR`

**Concept: The Directory Mismatch Bug**

Here is the bug in a table:

| Mode | `server_dir` | Port file location | CLI reads from |
|------|-------------|-------------------|---------------|
| CLI (direct) | n/a | `<cwd>/.pm/server.json` | `<cwd>/.pm/server.json` |
| Tauri (before fix) | `~/Library/.../app/.server/` | `~/Library/.../app/.server/server.json` | `<cwd>/.pm/server.json` |
| Tauri (after fix) | `<repo>/.pm/` (when PM_CONFIG_DIR set) | `<repo>/.pm/server.json` | `<cwd>/.pm/server.json` |

The fix is 3 lines: before computing `server_dir`, check if `PM_CONFIG_DIR` is set in the environment. If it is, use that path instead of the global app data directory.

**Why this works end-to-end (no other code changes needed)**:

1. `lifecycle.rs:249` already sets `PM_CONFIG_DIR=self.server_dir` when spawning pm-server
2. `pm_config::Config::config_dir()` already reads `PM_CONFIG_DIR` (at `config.rs:83`)
3. pm-server already writes `server.json` to the config dir (at `main.rs:194`)
4. CLI already reads from `<cwd>/.pm/server.json` (at `main.rs:167`)

The ONLY missing piece: Tauri's `lib.rs` ignores `PM_CONFIG_DIR` for its own `server_dir`.

**File**: `desktop/src-tauri/src/lib.rs`

Replace lines 42-45:

**Before** (lines 42-45):
```rust
            let app_data_dir = app.path().app_data_dir()?;

            // Server data directory (.server/) - for pm-server
            let server_dir = app_data_dir.join(SERVER_DATA_DIR);
```

**After**:
```rust
            let app_data_dir = app.path().app_data_dir()?;

            // Server data directory:
            // If PM_CONFIG_DIR is set (repo mode via `pm desktop` or `just dev`),
            // use it directly so server data lives in <repo>/.pm/ alongside CLI.
            // Otherwise, use global app data directory (standalone desktop mode).
            let server_dir = match std::env::var("PM_CONFIG_DIR") {
                Ok(dir) if !dir.is_empty() => {
                    let path = std::path::PathBuf::from(&dir);
                    info!("Repo mode: PM_CONFIG_DIR={}", dir);
                    path
                }
                _ => app_data_dir.join(SERVER_DATA_DIR),
            };
```

**What does NOT change** (and why):

- `desktop/src-tauri/src/server/config.rs`: `DEFAULT_PORT` stays at 8000. Tauri's port scanning (8000-8100) is appropriate for desktop mode. Changing it to 0 would break `is_available(0)` (see Step 5).
- `desktop/src-tauri/src/server/lifecycle.rs`: Already passes `PM_CONFIG_DIR=self.server_dir` to pm-server on line 249. No change needed.
- `desktop/src-tauri/src/server/port.rs`: `PortManager` stays as-is. Port scanning works correctly.
- `backend/pm-server/src/main.rs`: Already reads `PM_CONFIG_DIR` via pm-config and writes port file there.

**Verification**: `just check-backend`

---

### Step 2: Add `Desktop` Variant to CLI Commands

**Concept: Subcommand Design**

The CLI uses `clap`'s derive API with nested subcommands. The existing pattern has three subcommands (`Project`, `WorkItem`, `Comment`), each with their own nested `#[command(subcommand)]` actions. `Desktop` is different — it's a standalone command with no arguments, because it's a launcher (sets env vars and spawns Tauri), not a client command.

This matters for the control flow in `main.rs`: Desktop must be handled **before** server URL discovery, because the desktop command doesn't need a running server — it IS the thing that starts one.

**File**: `backend/crates/pm-cli/src/commands.rs`

Add a new variant after the `Comment` variant (before the closing `}`):

```rust
    /// Launch the desktop app for this repository
    Desktop,
```

The full file should look like:

```rust
use crate::{
    comment_commands::CommentCommands, project_commands::ProjectCommands,
    work_item_commands::WorkItemCommands,
};

use clap::Subcommand;

#[derive(Subcommand)]
pub(crate) enum Commands {
    /// Project operations
    Project {
        #[command(subcommand)]
        action: ProjectCommands,
    },
    /// Work item operations
    WorkItem {
        #[command(subcommand)]
        action: WorkItemCommands,
    },
    /// Comment operations
    Comment {
        #[command(subcommand)]
        action: CommentCommands,
    },
    /// Launch the desktop app for this repository
    Desktop,
}
```

**Verification**: `just check-rs-cli`

---

### Step 3: Implement `launch_desktop()` and `find_tauri_binary()` in CLI

**Concept: Binary Discovery with Graceful Fallback**

The `pm desktop` command needs to find the Tauri binary, but it could be in several places depending on whether the user installed from a release or built from source. The search order provides a clean experience:

1. **`PM_TAURI_BIN` env var**: Explicit override for CI or custom setups
2. **`.pm/bin/`**: The installed location from `install.sh` or release extraction
3. **Workspace `target/`**: Development builds from `cargo build` or `cargo tauri build`

This pattern is common in CLI tools (e.g., `rustup` finding toolchains, `nvm` finding node versions).

**File**: `backend/crates/pm-cli/src/main.rs`

Three changes to this file:

#### 3a: Add import

After line 36 (`use std::process::ExitCode;`), add:
```rust
use std::path::PathBuf;
```

#### 3b: Intercept Desktop command before server discovery

After line 42 (`let cli = Cli::parse();`), insert:

```rust
    // Desktop launches Tauri (which spawns pm-server itself) — handle before server discovery
    if matches!(cli.command, Commands::Desktop) {
        return launch_desktop();
    }
```

#### 3c: Add `Desktop` arm to the match expression

In the match on `cli.command`, after the `Comment` arm (around line 130), add:

```rust
        // Desktop is handled above before server discovery
        Commands::Desktop => unreachable!(),
```

#### 3d: Update `discover_server_url()` error messages

In the `Ok(None)` arm of `discover_server_url()`, after line 181 (`eprintln!("  cargo run -p pm-server");`), add:
```rust
            eprintln!("  pm desktop                # Desktop mode");
```

#### 3e: Add `launch_desktop()` and `find_tauri_binary()` functions

At the end of the file (after the `discover_server_url()` function), add:

```rust
/// Launch the Tauri desktop app in repo-aware mode.
///
/// Sets PM_CONFIG_DIR to <cwd>/.pm/ so Tauri, pm-server, and the CLI
/// all share the same directory for config, database, and port discovery.
fn launch_desktop() -> ExitCode {
    let cwd = match std::env::current_dir() {
        Ok(dir) => dir,
        Err(e) => {
            eprintln!("Error: cannot determine current directory: {}", e);
            return ExitCode::FAILURE;
        }
    };

    let config_dir = cwd.join(".pm");

    // Ensure .pm/ directory exists
    if let Err(e) = std::fs::create_dir_all(&config_dir) {
        eprintln!("Error: cannot create {}: {}", config_dir.display(), e);
        return ExitCode::FAILURE;
    }

    // Find Tauri binary
    let binary = match find_tauri_binary(&cwd) {
        Some(path) => path,
        None => {
            eprintln!("Error: Tauri desktop app not found.");
            eprintln!();
            eprintln!("Searched locations:");
            eprintln!("  1. PM_TAURI_BIN environment variable");
            eprintln!("  2. {}/.pm/bin/", cwd.display());
            eprintln!("  3. Workspace target/debug/ and target/release/");
            eprintln!();
            eprintln!("Install the desktop app:");
            eprintln!("  just build    # Build Tauri from source");
            return ExitCode::FAILURE;
        }
    };

    eprintln!("Launching desktop app: {}", binary.display());
    eprintln!("Config directory: {}", config_dir.display());

    // Spawn Tauri with PM_CONFIG_DIR set — this is the key coordination mechanism
    match std::process::Command::new(&binary)
        .env("PM_CONFIG_DIR", &config_dir)
        .spawn()
    {
        Ok(_) => {
            // Don't wait for the child — desktop app runs independently
            ExitCode::SUCCESS
        }
        Err(e) => {
            eprintln!("Error: failed to launch {}: {}", binary.display(), e);
            ExitCode::FAILURE
        }
    }
}

/// Search for the Tauri binary in standard locations.
///
/// Search order:
/// 1. PM_TAURI_BIN environment variable (explicit override)
/// 2. .pm/bin/ installed location (macOS .app bundle, then plain binary)
/// 3. Workspace target/release/ then target/debug/ (development builds)
fn find_tauri_binary(cwd: &std::path::Path) -> Option<PathBuf> {
    // 1. Environment variable override
    if let Ok(path) = std::env::var("PM_TAURI_BIN") {
        let path = PathBuf::from(path);
        if path.exists() {
            return Some(path);
        }
        eprintln!(
            "Warning: PM_TAURI_BIN set but not found: {}",
            path.display()
        );
    }

    // 2. Installed location: .pm/bin/
    let bin_dir = cwd.join(".pm").join("bin");

    // macOS: .app bundle (standard macOS application structure)
    let macos_app = bin_dir
        .join("Project Manager.app")
        .join("Contents")
        .join("MacOS")
        .join("project-manager");
    if macos_app.exists() {
        return Some(macos_app);
    }

    // Linux/Windows: plain binary
    let plain = bin_dir.join("project-manager");
    if plain.exists() {
        return Some(plain);
    }

    #[cfg(windows)]
    {
        let exe = bin_dir.join("project-manager.exe");
        if exe.exists() {
            return Some(exe);
        }
    }

    // 3. Development: workspace target directory
    // Walk up from cwd to find workspace root (directory containing
    // a Cargo.toml with [workspace] section)
    let mut dir = Some(cwd);
    while let Some(d) = dir {
        let cargo_toml = d.join("Cargo.toml");
        if cargo_toml.exists() {
            if let Ok(content) = std::fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    // Found workspace root — check target directories
                    for profile in ["release", "debug"] {
                        let bin = d.join("target").join(profile).join("project-manager");
                        if bin.exists() {
                            return Some(bin);
                        }
                    }
                    break; // Found workspace root but no binary built yet
                }
            }
        }
        dir = d.parent();
    }

    None
}
```

**Verification**:
```bash
just check-rs-cli
just clippy-rs-cli
```

---

### Step 4: Update `just dev` to Pass `PM_CONFIG_DIR`

**Concept: Justfile Built-in Functions**

The `justfile_directory()` function returns the absolute path to the directory containing the justfile (the repo root). This is more reliable than a relative path like `.pm` because it works regardless of where `just dev` is invoked from (e.g., from a subdirectory).

When `cargo tauri dev` runs, Tauri's `lib.rs` `setup()` will see `PM_CONFIG_DIR` in the environment and use it for `server_dir` (the change from Step 1). This means:
- Tauri creates `.pm/` directories in the repo
- Tauri tells pm-server to use `<repo>/.pm/` via `PM_CONFIG_DIR`
- pm-server writes `server.json` to `<repo>/.pm/`
- CLI reads from `<repo>/.pm/server.json`
- Everything collocates.

**File**: `justfile`

Replace lines 453-456:

**Before**:
```just
# Run development build then start Tauri
dev:
    just build-dev
    cargo tauri dev
```

**After**:
```just
# Run development build then start Tauri (repo-aware)
dev:
    just build-dev
    PM_CONFIG_DIR="{{justfile_directory()}}/.pm" cargo tauri dev
```

**Verification**:
```bash
just --list | grep dev
# Should show: dev   # Run development build then start Tauri (repo-aware)
```

---

### Step 5: Update `CLAUDE_FUCKED_UP.md`

**Concept: Why `DEFAULT_PORT = 0` Breaks Tauri (The Port 0 Trap)**

Port 0 has special meaning in TCP: it tells the operating system to assign an ephemeral port. `TcpListener::bind(("127.0.0.1", 0))` **always succeeds** because the OS always has ephemeral ports available.

Tauri's `PortManager::is_available(port)` works by trying to bind to the port. If `DEFAULT_PORT` is 0:
1. `is_available(0)` calls `TcpListener::bind(("127.0.0.1", 0))` — always succeeds
2. `find_available(0, ...)` returns `Ok(0)` immediately without scanning the range
3. Tauri stores `actual_port = 0` in its state
4. The health checker polls `http://127.0.0.1:0/health` — can never connect
5. `websocket_url()` returns `ws://127.0.0.1:0/ws` — frontend can't connect
6. Tauri thinks the server is unhealthy and restarts it — infinite loop

**File**: `CLAUDE_FUCKED_UP.md`

Append to the end of the file:

```markdown
---

## Resolution (Session 121)

### The Proposed Fix Was Wrong

Changing `DEFAULT_PORT` from 8000 to 0 would BREAK Tauri entirely:

1. `PortManager::is_available(0)` calls `TcpListener::bind(("127.0.0.1", 0))`
2. Port 0 = "let the OS choose" — this **ALWAYS** succeeds
3. `find_available(0, ...)` returns `Ok(0)` without scanning the range
4. Tauri stores `actual_port = 0`
5. HealthChecker polls `http://127.0.0.1:0/health` — infinite timeout loop
6. `websocket_url()` returns `ws://127.0.0.1:0/ws` — frontend can't connect

### The Correct Fix

The real problem was a **DIRECTORY MISMATCH**, not a port number issue:

| Mode | `server_dir` | Port file |
|------|-------------|-----------|
| CLI | `<cwd>/.pm/` | `<repo>/.pm/server.json` |
| Tauri (before) | `~/Library/.../app/.server/` | global app data dir |
| Tauri (after) | `<repo>/.pm/` (when `PM_CONFIG_DIR` set) | `<repo>/.pm/server.json` |

**Fix**: 3-line change in `desktop/src-tauri/src/lib.rs` — check `PM_CONFIG_DIR` env var before falling back to global `app_data_dir`. Everything downstream already worked.

### `DEFAULT_PORT` Stays at 8000

Tauri's port scanning (8000-8100 range) is correct for desktop mode. The pm-server config uses `port = 0` (auto-assign) for direct CLI mode. These are different use cases with different defaults.
```

**Verification**: No code verification needed — documentation only.

---

## Session 121.2 Completion Checklist

```bash
# Full verification sequence
just check-backend        # All Rust code compiles
just clippy-backend       # No clippy warnings
just test-backend         # All tests pass

# CLI help shows new command
cargo run -p pm-cli -- --help
# Should show "desktop" in the subcommand list

cargo run -p pm-cli -- desktop --help
# Should show "Launch the desktop app for this repository"

# Integration test (manual — requires Tauri to be built)
just dev
# In another terminal:
cat .pm/server.json              # Should show port file with actual port
cargo run -p pm-cli -- project list --pretty
# Should auto-discover and connect to Tauri-spawned server
# Close Tauri, verify .pm/server.json is cleaned up
```

### Files Modified (4)
| File | Change |
|------|--------|
| `desktop/src-tauri/src/lib.rs` | Check `PM_CONFIG_DIR` for `server_dir` |
| `backend/crates/pm-cli/src/commands.rs` | Add `Desktop` variant |
| `backend/crates/pm-cli/src/main.rs` | Add `launch_desktop()`, `find_tauri_binary()`, intercept Desktop before server discovery |
| `justfile` | Pass `PM_CONFIG_DIR` in `dev` command |

### Files Updated (1)
| File | Change |
|------|--------|
| `CLAUDE_FUCKED_UP.md` | Document correct fix, explain port 0 trap |

---

## Next Session

**Session 121.3** will implement:
- Release distribution justfile commands (`build-portable`, `archive`, `release-build`)
- `install.sh` for macOS/Linux
- `install.ps1` for Windows
- Archive layout for `.pm/bin/` extraction
