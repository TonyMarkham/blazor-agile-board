# Session 121.3: Release Distribution

**Parent Plan**: `121-Session-Plan.md`
**Prerequisite**: Sessions 121.1 and 121.2 completed
**Target**: ~30k tokens

---

## Scope

This sub-session creates the distribution infrastructure so users can install pre-built binaries into `<repo>/.pm/bin/` without building from source:

1. **Justfile Variables** — Release naming conventions using Rust target triples
2. **Build + Archive Commands** — `build-portable`, `archive`, `release-build`
3. **GitHub Release Commands** — `release`, `release-upload`
4. **`install.sh`** — Cross-platform installer for macOS/Linux
5. **`install.ps1`** — Windows installer

### Concepts Taught

- **Rust target triples** — How `aarch64-apple-darwin` identifies a platform
- **Archive layout conventions** — Structuring tarballs for clean extraction
- **Installer design patterns** — Platform detection, graceful error handling, idempotent operations
- **GitHub release workflow** — Using `gh` CLI for release management

---

## Prerequisites Check

Verify Sessions 121.1 and 121.2 are complete:

```bash
just check-backend        # Should pass
grep 'config_dir := ".pm"' justfile          # Should match
grep 'PM_CONFIG_DIR' justfile                 # Should show in dev command
cargo run -p pm-cli -- desktop --help         # Should work
```

---

## Implementation Order

### Step 1: Add Release Variables to Justfile

**Concept: Rust Target Triples**

Rust identifies platforms using "target triples" like `aarch64-apple-darwin` (Apple Silicon Mac), `x86_64-unknown-linux-gnu` (Linux x64), or `x86_64-pc-windows-msvc` (Windows x64). The `rustc -vV` command outputs this as the `host` field. Using the target triple in archive names is the standard convention for Rust projects (used by rustup, cargo-dist, and most Rust release tooling).

The `just` tool supports backtick expressions that run shell commands at parse time — `target_triple := \`rustc -vV | grep host | cut -d' ' -f2\`` runs once when the justfile is loaded, not on every command invocation.

**File**: `justfile`

After line 8 (`coverage_dir := "./coverage"`), add:

```just

# === Distribution ===
dist_dir := "dist"
version := "0.1.0"
target_triple := `rustc -vV | grep host | cut -d' ' -f2`
archive_name := "pm-" + version + "-" + target_triple
```

**Verification**:
```bash
just --evaluate target_triple
# Should output something like: aarch64-apple-darwin
just --evaluate archive_name
# Should output something like: pm-0.1.0-aarch64-apple-darwin
```

---

### Step 2: Add Distribution Commands to Justfile

**Concept: Archive Layout for Clean Extraction**

The archive structure is designed so that extracting it into `.pm/` gives you the right file layout:

```
pm-0.1.0-aarch64-apple-darwin/
  bin/
    pm                        # CLI binary
    pm-server                 # Backend server
    Project Manager.app/      # macOS desktop app (or project-manager on Linux)
```

When `install.sh` extracts the archive, it copies `bin/*` into `.pm/bin/`, which is exactly where `find_tauri_binary()` (from Session 121.2) looks for the desktop app.

**File**: `justfile`

Add a new section before the existing `# Utility Commands` comment (before the `setup-config` recipe):

```just
# ============================================================================
# Distribution Commands
# ============================================================================

# Build all binaries in release mode for distribution
build-portable:
    @echo "Building portable release ({{target_triple}})..."
    cargo build -p pm-cli {{cargo_release}}
    cargo build -p pm-server {{cargo_release}}
    cargo tauri build

# Create distribution archive from release binaries
archive: build-portable
    @echo "Creating archive: {{dist_dir}}/{{archive_name}}.tar.gz"
    mkdir -p {{dist_dir}}/{{archive_name}}/bin
    cp target/release/pm {{dist_dir}}/{{archive_name}}/bin/
    cp target/release/pm-server {{dist_dir}}/{{archive_name}}/bin/
    @# macOS: copy .app bundle if it exists
    @if [ -d "target/release/bundle/macos/Project Manager.app" ]; then \
        cp -r "target/release/bundle/macos/Project Manager.app" {{dist_dir}}/{{archive_name}}/bin/; \
    fi
    @# Linux: copy AppImage if it exists
    @if ls target/release/bundle/appimage/*.AppImage 1>/dev/null 2>&1; then \
        cp target/release/bundle/appimage/*.AppImage {{dist_dir}}/{{archive_name}}/bin/project-manager; \
    fi
    cd {{dist_dir}} && tar czf {{archive_name}}.tar.gz {{archive_name}}/
    @echo ""
    @echo "Archive created: {{dist_dir}}/{{archive_name}}.tar.gz"
    @echo "Contents:"
    @tar tzf {{dist_dir}}/{{archive_name}}.tar.gz

# Build + archive in one step
release-build: archive

# Clean distribution artifacts
clean-dist:
    rm -rf {{dist_dir}}

# Upload archive to an existing GitHub release (requires gh CLI)
release-upload tag:
    gh release upload {{tag}} {{dist_dir}}/{{archive_name}}.tar.gz --clobber

# Create a new GitHub release and upload the archive
release tag:
    gh release create {{tag}} {{dist_dir}}/{{archive_name}}.tar.gz \
        --title "v{{version}}" \
        --notes "Release v{{version}} for {{target_triple}}"
```

Also update the `help` recipe to include distribution commands. Add before the `Maintenance` section in the help output:

```just
    echo "  Distribution:"
    echo "  just build-portable          - Build all binaries (release)"
    echo "  just archive                 - Build + create distribution archive"
    echo "  just release-build           - Alias for archive"
    echo "  just release <tag>           - Create GitHub release with archive"
    echo "  just release-upload <tag>    - Upload to existing GitHub release"
    echo "  just clean-dist              - Remove dist/ directory"
    echo ""
```

**Verification**:
```bash
just --list | grep -E "(portable|archive|release|dist)"
# Should show: build-portable, archive, release-build, release, release-upload, clean-dist
```

---

### Step 3: Create `install.sh`

**Concept: Installer Design Patterns**

A good installer script follows these principles:

1. **Detect, don't assume**: Query the OS and architecture at runtime
2. **Fail fast**: Use `set -euo pipefail` so any error stops immediately
3. **Clean up after yourself**: Use `trap` to remove temp files even on failure
4. **Be idempotent**: Running it twice produces the same result
5. **Prefer existing tools**: Use `gh` CLI if available (faster, authenticated), fall back to `curl`
6. **Be transparent**: Print what you're doing at every step

**File**: `install.sh` (NEW, at repo root)

```bash
#!/usr/bin/env bash
# install.sh - Install Blazor Agile Board tools into <cwd>/.pm/bin/
#
# Usage:
#   # From within a git repo:
#   curl -fsSL https://raw.githubusercontent.com/OWNER/blazor-agile-board/main/install.sh | bash
#
#   # Or run directly:
#   bash install.sh
#
# Environment variables:
#   PM_VERSION     - Specific version to install (default: latest)
#   PM_REPO        - GitHub repo (default: OWNER/blazor-agile-board)
#   PM_INSTALL_DIR - Override install directory (default: .pm/bin)

set -euo pipefail

# =========================================================================
# Configuration
# =========================================================================

REPO="${PM_REPO:-OWNER/blazor-agile-board}"
INSTALL_DIR="${PM_INSTALL_DIR:-.pm/bin}"

# =========================================================================
# Output Helpers
# =========================================================================

# Only use colors if stdout is a terminal
if [ -t 1 ]; then
    BLUE='\033[0;34m' GREEN='\033[0;32m' RED='\033[0;31m' NC='\033[0m'
else
    BLUE='' GREEN='' RED='' NC=''
fi

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
error() { echo -e "${RED}[error]${NC} $*" >&2; exit 1; }

# =========================================================================
# Platform Detection
# =========================================================================

detect_target() {
    local arch os

    # Detect CPU architecture
    case "$(uname -m)" in
        x86_64|amd64)  arch="x86_64" ;;
        arm64|aarch64) arch="aarch64" ;;
        *) error "Unsupported architecture: $(uname -m)" ;;
    esac

    # Detect operating system
    case "$(uname -s)" in
        Darwin) os="apple-darwin" ;;
        Linux)  os="unknown-linux-gnu" ;;
        MINGW*|MSYS*|CYGWIN*)
            error "Use install.ps1 for Windows: powershell -c 'irm .../install.ps1 | iex'"
            ;;
        *) error "Unsupported OS: $(uname -s)" ;;
    esac

    echo "${arch}-${os}"
}

# =========================================================================
# Version Detection
# =========================================================================

get_latest_version() {
    # Prefer gh CLI (authenticated, faster, no rate limit)
    if command -v gh &>/dev/null; then
        gh release view --repo "$REPO" --json tagName -q .tagName 2>/dev/null && return
    fi

    # Fall back to GitHub API via curl
    curl -fsSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null \
        | grep '"tag_name"' \
        | head -1 \
        | sed 's/.*"tag_name": *"//;s/".*//'
}

# =========================================================================
# Main
# =========================================================================

main() {
    info "Blazor Agile Board Installer"
    echo ""

    # Detect platform
    local target
    target=$(detect_target)
    info "Platform: ${target}"

    # Determine version
    local version="${PM_VERSION:-}"
    if [ -z "$version" ]; then
        info "Detecting latest version..."
        version=$(get_latest_version)
        [ -z "$version" ] && error "Could not determine latest version. Set PM_VERSION manually."
    fi
    info "Version: ${version}"

    # Build download URL
    local ver_num="${version#v}"   # Strip leading 'v' if present
    local archive_name="pm-${ver_num}-${target}"
    local archive_file="${archive_name}.tar.gz"
    local url="https://github.com/${REPO}/releases/download/${version}/${archive_file}"

    # Create install directory
    mkdir -p "$INSTALL_DIR"

    # Download to temp directory (cleaned up on exit via trap)
    info "Downloading ${archive_file}..."
    local tmp_dir
    tmp_dir=$(mktemp -d)
    trap 'rm -rf "$tmp_dir"' EXIT

    if command -v gh &>/dev/null; then
        gh release download "$version" --repo "$REPO" \
            --pattern "$archive_file" --dir "$tmp_dir" 2>/dev/null \
            || curl -fSL "$url" -o "$tmp_dir/$archive_file"
    else
        curl -fSL "$url" -o "$tmp_dir/$archive_file"
    fi

    # Extract archive
    info "Extracting to ${INSTALL_DIR}/..."
    tar xzf "$tmp_dir/$archive_file" -C "$tmp_dir"

    # Copy binaries from archive's bin/ to install directory
    [ -d "$tmp_dir/$archive_name/bin" ] || error "Archive missing expected bin/ directory"
    cp -r "$tmp_dir/$archive_name/bin/"* "$INSTALL_DIR/"

    # Make binaries executable
    chmod +x "$INSTALL_DIR/pm" "$INSTALL_DIR/pm-server" 2>/dev/null || true

    # Create .pm/.gitignore if it doesn't exist (idempotent)
    if [ ! -f ".pm/.gitignore" ]; then
        info "Creating .pm/.gitignore..."
        cat > ".pm/.gitignore" << 'GITIGNORE'
# Runtime files - not tracked
!data.db
bin/
*.db-wal
*.db-shm
server.json
server.lock
logs/
log/
tauri/
GITIGNORE
        ok "Created .pm/.gitignore"
    fi

    # Print success message
    echo ""
    ok "Installation complete!"
    echo ""
    echo "  Installed to: $(cd "$INSTALL_DIR" && pwd)"
    echo ""
    echo "  Binaries:"
    ls -1 "$INSTALL_DIR/" | while read -r f; do echo "    $f"; done
    echo ""
    echo "  Usage:"
    echo "    .pm/bin/pm project list --pretty"
    echo "    .pm/bin/pm desktop"
    echo ""
    echo "  Add to PATH (optional):"
    echo "    export PATH=\"\$(pwd)/.pm/bin:\$PATH\""
    echo ""
}

main "$@"
```

After creating, make it executable:
```bash
chmod +x install.sh
```

**Verification**:
```bash
bash -n install.sh    # Syntax check — no output means no errors
```

---

### Step 4: Create `install.ps1`

**Concept: PowerShell Installer for Windows**

PowerShell is the standard scripting language on modern Windows. The installer follows the same patterns as `install.sh` but using PowerShell idioms:

- `$ErrorActionPreference = "Stop"` is the PowerShell equivalent of `set -e`
- `Invoke-WebRequest` replaces `curl`
- `[System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture` for architecture detection
- `try/finally` for cleanup instead of `trap`

**File**: `install.ps1` (NEW, at repo root)

```powershell
# install.ps1 - Install Blazor Agile Board tools into <cwd>\.pm\bin\
#
# Usage:
#   irm https://raw.githubusercontent.com/OWNER/blazor-agile-board/main/install.ps1 | iex
#   # or
#   .\install.ps1
#
# Environment variables:
#   PM_VERSION     - Specific version (default: latest)
#   PM_REPO        - GitHub repo (default: OWNER/blazor-agile-board)
#   PM_INSTALL_DIR - Override install dir (default: .pm\bin)

$ErrorActionPreference = "Stop"

# =========================================================================
# Configuration
# =========================================================================

$Repo = if ($env:PM_REPO) { $env:PM_REPO } else { "OWNER/blazor-agile-board" }
$InstallDir = if ($env:PM_INSTALL_DIR) { $env:PM_INSTALL_DIR } else { ".pm\bin" }

# =========================================================================
# Output Helpers
# =========================================================================

function Write-Info($msg) { Write-Host "[info]  $msg" -ForegroundColor Blue }
function Write-Ok($msg) { Write-Host "[ok]    $msg" -ForegroundColor Green }
function Write-Err($msg) { Write-Host "[error] $msg" -ForegroundColor Red; exit 1 }

# =========================================================================
# Main
# =========================================================================

Write-Info "Blazor Agile Board Installer"
Write-Host ""

# Detect architecture
$Arch = switch ([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture) {
    "X64"   { "x86_64" }
    "Arm64" { "aarch64" }
    default { Write-Err "Unsupported architecture: $_" }
}

$Target = "${Arch}-pc-windows-msvc"
Write-Info "Platform: $Target"

# Determine version
$Version = $env:PM_VERSION
if (-not $Version) {
    Write-Info "Detecting latest version..."
    try {
        $Release = Invoke-RestMethod "https://api.github.com/repos/$Repo/releases/latest"
        $Version = $Release.tag_name
    }
    catch {
        Write-Err "Could not determine latest version. Set PM_VERSION manually."
    }
}
Write-Info "Version: $Version"

# Build download URL
$VerNum = $Version -replace '^v', ''
$ArchiveName = "pm-${VerNum}-${Target}"
$ArchiveFile = "${ArchiveName}.tar.gz"
$Url = "https://github.com/$Repo/releases/download/$Version/$ArchiveFile"

# Create install directory
New-Item -ItemType Directory -Path $InstallDir -Force | Out-Null

# Download to temp directory
Write-Info "Downloading $ArchiveFile..."
$TmpDir = Join-Path ([System.IO.Path]::GetTempPath()) ([System.Guid]::NewGuid().ToString())
New-Item -ItemType Directory -Path $TmpDir -Force | Out-Null

try {
    $ArchivePath = Join-Path $TmpDir $ArchiveFile
    Invoke-WebRequest -Uri $Url -OutFile $ArchivePath

    # Extract archive (tar is available on Windows 10+)
    Write-Info "Extracting to $InstallDir\..."
    tar xzf $ArchivePath -C $TmpDir

    # Copy binaries
    $BinDir = Join-Path $TmpDir $ArchiveName "bin"
    if (Test-Path $BinDir) {
        Copy-Item "$BinDir\*" $InstallDir -Recurse -Force
    }
    else {
        Write-Err "Archive missing expected bin\ directory"
    }
}
finally {
    # Clean up temp directory
    Remove-Item $TmpDir -Recurse -Force -ErrorAction SilentlyContinue
}

# Create .pm\.gitignore if it doesn't exist
$GitignorePath = ".pm\.gitignore"
if (-not (Test-Path $GitignorePath)) {
    Write-Info "Creating $GitignorePath..."
    @"
# Runtime files - not tracked
!data.db
bin/
*.db-wal
*.db-shm
server.json
server.lock
logs/
log/
tauri/
"@ | Set-Content $GitignorePath -Encoding utf8
    Write-Ok "Created $GitignorePath"
}

# Print success
Write-Host ""
Write-Ok "Installation complete!"
Write-Host ""
Write-Host "  Installed to: $(Resolve-Path $InstallDir)"
Write-Host ""
Write-Host "  Usage:"
Write-Host "    .pm\bin\pm project list --pretty"
Write-Host "    .pm\bin\pm desktop"
Write-Host ""
Write-Host "  Add to PATH (current session):"
Write-Host "    `$env:PATH = `"$(Get-Location)\.pm\bin;`$env:PATH`""
Write-Host ""
```

**Verification**:
```bash
file install.ps1
# Should show: install.ps1: UTF-8 Unicode text
```

---

## Session 121.3 Completion Checklist

```bash
# Verify justfile commands exist
just --list | grep -E "(portable|archive|release|dist)"
# Should show 6 new commands

# Verify install scripts have no syntax errors
bash -n install.sh
file install.ps1

# Full release build test (slow — builds everything in release mode)
just release-build
tar tzf dist/pm-*.tar.gz
# Should show structure like:
#   pm-0.1.0-aarch64-apple-darwin/bin/pm
#   pm-0.1.0-aarch64-apple-darwin/bin/pm-server
#   pm-0.1.0-aarch64-apple-darwin/bin/Project Manager.app/...

# Verify dist/ is gitignored
git status
# dist/ should NOT appear in untracked files
```

### Files Created (2)
| File | Purpose |
|------|---------|
| `install.sh` | macOS/Linux installer script |
| `install.ps1` | Windows installer script |

### Files Modified (1)
| File | Change |
|------|--------|
| `justfile` | Distribution variables + 6 new commands + help text |

---

## Session 121 Complete

With all three sub-sessions complete, the project has:

1. **Infrastructure** (121.1)
   - Centralized workspace metadata (one version bump updates all crates)
   - Selective `.pm/` git tracking (database and config tracked, runtime files ignored)
   - `Cargo.lock` committed for reproducible builds
   - Justfile migrated from `.server` to `.pm`

2. **Tauri Repo-Awareness** (121.2)
   - 3-line fix in Tauri `lib.rs` closes the directory mismatch bug
   - `pm desktop` command launches Tauri with `PM_CONFIG_DIR` set
   - `just dev` passes `PM_CONFIG_DIR` automatically
   - `CLAUDE_FUCKED_UP.md` documents the correct fix and the port 0 trap

3. **Release Distribution** (121.3)
   - `just release-build` creates platform-specific archives
   - `just release <tag>` publishes to GitHub releases
   - `install.sh` and `install.ps1` for one-command installation
   - Archive layout matches `find_tauri_binary()` search paths

### Notes

- **GitHub repo URL**: `OWNER/blazor-agile-board` is a placeholder in install scripts and `[workspace.package]`. Update when the actual GitHub URL is confirmed.
- **Existing `.server/` users**: One-time migration: `cp .server/config.toml .pm/config.toml && cp .server/data.db .pm/data.db`
