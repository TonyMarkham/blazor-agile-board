# Session 121.3: Release Distribution

**Parent Plan**: `121-Session-Plan.md`
**Prerequisite**: Sessions 121.1 and 121.2 completed
**Target**: ~30k tokens

---

## Scope

This sub-session creates the distribution infrastructure so users can install pre-built binaries into `<repo>/.pm/bin/` without building from source:

1. **Justfile Variables** — Release naming conventions using Rust target triples
2. **Build + Archive Commands** — `build-portable`, `archive`, `release-build`
3. **GitHub Release Commands** — `release`, `release-upload`
4. **`install.sh`** — Cross-platform installer for macOS/Linux
5. **`install.ps1`** — Windows installer

**Key requirement from 121.2**: Both install scripts MUST write `.pm/bin/config.json` with `{"repo_root": "/absolute/path/to/repo"}`. This file is consumed by `Config::config_dir_from_binary_config()` (121.2 Step 1, fallback #2) and `find_server_dir_from_binary()` (121.2 Step 5). It enables Tauri to find `.pm/` when double-clicked outside a terminal, where `git rev-parse --show-toplevel` would fail because there's no repo context. Without this file, double-click Tauri falls through to fallback #3 (`~/.pm/` global) which is disconnected from the repo.

**GitHub repo URL**: Install scripts and `[workspace.package]` metadata use `TonyMarkham/blazor-agile-board` (matching root `Cargo.toml` set in 121.1).

### Concepts Taught

- **Rust target triples** — How `aarch64-apple-darwin` identifies a platform
- **Archive layout conventions** — Structuring tarballs for clean extraction
- **Installer design patterns** — Platform detection, graceful error handling, idempotent operations
- **GitHub release workflow** — Using `gh` CLI for release management

---

## Prerequisites Check

Verify Sessions 121.1 and 121.2 are complete:

```bash
just check-backend        # Should pass
just test-backend         # Should pass
grep 'config_dir := ".pm"' justfile          # Should match
cargo run -p pm-cli -- desktop --help         # Should work

# Verify no discovery env vars remain
grep -rn 'PM_CONFIG_DIR' backend/crates/pm-config/src/config.rs   # Nothing
grep -rn 'PM_SERVER_BIN' desktop/src-tauri/src/server/lifecycle.rs  # Nothing
```

---

## Implementation Order

### Step 1: Add Release Variables to Justfile

**Concept: Rust Target Triples**

Rust identifies platforms using "target triples" like `aarch64-apple-darwin` (Apple Silicon Mac), `x86_64-unknown-linux-gnu` (Linux x64), or `x86_64-pc-windows-msvc` (Windows x64). The `rustc -vV` command outputs this as the `host` field. Using the target triple in archive names is the standard convention for Rust projects (used by rustup, cargo-dist, and most Rust release tooling).

The `just` tool supports backtick expressions that run shell commands at parse time — `target_triple := \`rustc -vV | grep host | cut -d' ' -f2\`` runs once when the justfile is loaded, not on every command invocation.

**File**: `justfile`

After line 8 (`coverage_dir := "./coverage"`), add:

```just

# === Distribution ===
dist_dir := "dist"
version := "0.1.0"
target_triple := `rustc -vV | grep host | cut -d' ' -f2`
archive_name := "pm-" + version + "-" + target_triple
```

**Verification**:
```bash
just --evaluate target_triple
# Should output something like: aarch64-apple-darwin
just --evaluate archive_name
# Should output something like: pm-0.1.0-aarch64-apple-darwin
```

---

### Step 2: Add Distribution Commands to Justfile

**Concept: Archive Layout for Clean Extraction**

The archive structure is designed so that extracting it into `.pm/` gives you the right file layout:

```
pm-0.1.0-aarch64-apple-darwin/
  bin/
    pm                        # CLI binary
    pm-server                 # Backend server
    Project Manager.app/      # macOS desktop app (or project-manager on Linux)
```

When `install.sh` extracts the archive, it copies `bin/*` into `.pm/bin/`, which is exactly where `find_tauri_binary()` (from Session 121.2) looks for the desktop app.

**File**: `justfile`

Add a new section before the existing `# Utility Commands` comment (before the `setup-config` recipe):

```just
# ============================================================================
# Distribution Commands
# ============================================================================

# Build all binaries in release mode for distribution
build-portable:
    @echo "Building portable release ({{target_triple}})..."
    cargo build -p pm-cli {{cargo_release}}
    cargo build -p pm-server {{cargo_release}}
    cargo tauri build

# Create distribution archive from release binaries
archive: build-portable
    @echo "Creating archive: {{dist_dir}}/{{archive_name}}.tar.gz"
    @test -f target/release/pm || (echo "ERROR: pm binary not found in target/release/"; exit 1)
    @test -f target/release/pm-server || (echo "ERROR: pm-server binary not found in target/release/"; exit 1)
    mkdir -p {{dist_dir}}/{{archive_name}}/bin
    cp target/release/pm {{dist_dir}}/{{archive_name}}/bin/
    cp target/release/pm-server {{dist_dir}}/{{archive_name}}/bin/
    @# macOS: copy .app bundle if it exists
    @if [ -d "target/release/bundle/macos/Project Manager.app" ]; then \
        cp -r "target/release/bundle/macos/Project Manager.app" {{dist_dir}}/{{archive_name}}/bin/; \
    fi
    @# Linux: copy AppImage if it exists
    @if ls target/release/bundle/appimage/*.AppImage 1>/dev/null 2>&1; then \
        cp target/release/bundle/appimage/*.AppImage {{dist_dir}}/{{archive_name}}/bin/project-manager; \
    fi
    cd {{dist_dir}} && tar czf {{archive_name}}.tar.gz {{archive_name}}/
    @echo ""
    @echo "Archive created: {{dist_dir}}/{{archive_name}}.tar.gz"
    @echo "Contents:"
    @tar tzf {{dist_dir}}/{{archive_name}}.tar.gz

# Build + archive in one step
release-build: archive

# Clean distribution artifacts
clean-dist:
    rm -rf {{dist_dir}}

# Upload archive to an existing GitHub release (requires gh CLI)
release-upload tag:
    gh release upload {{tag}} {{dist_dir}}/{{archive_name}}.tar.gz --clobber

# Create a new GitHub release and upload the archive
release tag:
    gh release create {{tag}} {{dist_dir}}/{{archive_name}}.tar.gz \
        --title "v{{version}}" \
        --notes "Release v{{version}} for {{target_triple}}"
```

Also update the `help` recipe to include distribution commands. Add before the `Maintenance` section in the help output:

```just
    echo "  Distribution:"
    echo "  just build-portable          - Build all binaries (release)"
    echo "  just archive                 - Build + create distribution archive"
    echo "  just release-build           - Alias for archive"
    echo "  just release <tag>           - Create GitHub release with archive"
    echo "  just release-upload <tag>    - Upload to existing GitHub release"
    echo "  just clean-dist              - Remove dist/ directory"
    echo ""
```

**Verification**:
```bash
just --list | grep -E "(portable|archive|release|dist)"
# Should show: build-portable, archive, release-build, release, release-upload, clean-dist
```

---

### Step 3: Create `install.sh`

**Concept: Installer Design Patterns**

A good installer script follows these principles:

1. **Detect, don't assume**: Query the OS and architecture at runtime
2. **Fail fast**: Use `set -euo pipefail` so any error stops immediately
3. **Clean up after yourself**: Use `trap` to remove temp files even on failure
4. **Be idempotent**: Running it twice produces the same result
5. **Prefer existing tools**: Use `gh` CLI if available (faster, authenticated), fall back to `curl`
6. **Be transparent**: Print what you're doing at every step

**Critical requirement**: The script MUST write `.pm/bin/config.json` with the repo root. This is how Tauri finds `.pm/` when double-clicked (see Session 121.2, Step 5 — `find_server_dir_from_binary()`).

**File**: `install.sh` (NEW, at repo root)

```bash
#!/usr/bin/env bash
# install.sh - Install Blazor Agile Board tools into <repo>/.pm/bin/
#
# Usage:
#   # From within a git repo:
#   curl -fsSL https://raw.githubusercontent.com/TonyMarkham/blazor-agile-board/main/install.sh | bash
#
#   # Or run directly:
#   bash install.sh
#
# Environment variables:
#   PM_VERSION     - Specific version to install (default: latest)
#   PM_REPO        - GitHub repo (default: TonyMarkham/blazor-agile-board)

set -euo pipefail

# =========================================================================
# Configuration
# =========================================================================

REPO="${PM_REPO:-TonyMarkham/blazor-agile-board}"

# =========================================================================
# Output Helpers
# =========================================================================

# Only use colors if stdout is a terminal
if [ -t 1 ]; then
    BLUE='\033[0;34m' GREEN='\033[0;32m' RED='\033[0;31m' NC='\033[0m'
else
    BLUE='' GREEN='' RED='' NC=''
fi

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
error() { echo -e "${RED}[error]${NC} $*" >&2; exit 1; }

# =========================================================================
# Repository Root Detection
# =========================================================================

find_repo_root() {
    if ! command -v git &>/dev/null; then
        error "git is required but not found"
    fi

    local root
    root=$(git rev-parse --show-toplevel 2>/dev/null) \
        || error "Not inside a git repository. Run this from within a repo."
    echo "$root"
}

# =========================================================================
# Platform Detection
# =========================================================================

detect_target() {
    local arch os

    # Detect CPU architecture
    case "$(uname -m)" in
        x86_64|amd64)  arch="x86_64" ;;
        arm64|aarch64) arch="aarch64" ;;
        *) error "Unsupported architecture: $(uname -m)" ;;
    esac

    # Detect operating system
    case "$(uname -s)" in
        Darwin) os="apple-darwin" ;;
        Linux)  os="unknown-linux-gnu" ;;
        MINGW*|MSYS*|CYGWIN*)
            error "Use install.ps1 for Windows: powershell -c 'irm .../install.ps1 | iex'"
            ;;
        *) error "Unsupported OS: $(uname -s)" ;;
    esac

    echo "${arch}-${os}"
}

# =========================================================================
# Version Detection
# =========================================================================

get_latest_version() {
    # Prefer gh CLI (authenticated, faster, no rate limit)
    if command -v gh &>/dev/null; then
        gh release view --repo "$REPO" --json tagName -q .tagName 2>/dev/null && return
    fi

    # Fall back to GitHub API via curl
    curl -fsSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null \
        | grep '"tag_name"' \
        | head -1 \
        | sed 's/.*"tag_name": *"//;s/".*//'
}

# =========================================================================
# Main
# =========================================================================

main() {
    info "Blazor Agile Board Installer"
    echo ""

    # Find repo root via git
    local repo_root
    repo_root=$(find_repo_root)
    info "Repository: ${repo_root}"

    local install_dir="${repo_root}/.pm/bin"

    # Detect platform
    local target
    target=$(detect_target)
    info "Platform: ${target}"

    # Determine version
    local version="${PM_VERSION:-}"
    if [ -z "$version" ]; then
        info "Detecting latest version..."
        version=$(get_latest_version)
        [ -z "$version" ] && error "Could not determine latest version. Set PM_VERSION manually."
    fi
    info "Version: ${version}"

    # Build download URL
    local ver_num="${version#v}"   # Strip leading 'v' if present
    local archive_name="pm-${ver_num}-${target}"
    local archive_file="${archive_name}.tar.gz"
    local url="https://github.com/${REPO}/releases/download/${version}/${archive_file}"

    # Create install directory
    mkdir -p "$install_dir"

    # Download to temp directory (cleaned up on exit via trap)
    info "Downloading ${archive_file}..."
    local tmp_dir
    tmp_dir=$(mktemp -d)
    trap 'rm -rf "$tmp_dir"' EXIT

    if command -v gh &>/dev/null; then
        gh release download "$version" --repo "$REPO" \
            --pattern "$archive_file" --dir "$tmp_dir" 2>/dev/null \
            || curl -fSL "$url" -o "$tmp_dir/$archive_file"
    else
        curl -fSL "$url" -o "$tmp_dir/$archive_file"
    fi

    # Extract archive
    info "Extracting to ${install_dir}/..."
    tar xzf "$tmp_dir/$archive_file" -C "$tmp_dir"

    # Copy binaries from archive's bin/ to install directory
    [ -d "$tmp_dir/$archive_name/bin" ] || error "Archive missing expected bin/ directory"
    cp -r "$tmp_dir/$archive_name/bin/"* "$install_dir/"

    # Make binaries executable
    chmod +x "$install_dir/pm" "$install_dir/pm-server" 2>/dev/null || true

    # Write config.json for Tauri double-click support.
    # When Tauri is launched outside a terminal, git rev-parse fails.
    # This file tells Tauri where the repo root is.
    info "Writing config.json (repo_root for Tauri)..."
    cat > "$install_dir/config.json" << CONFIGJSON
{"repo_root": "${repo_root}"}
CONFIGJSON
    ok "Created ${install_dir}/config.json"

    # ↑ config.json is consumed by two functions from Session 121.2:
    #   - Config::config_dir_from_binary_config() (Step 1, fallback #2)
    #   - find_server_dir_from_binary() (Step 5)
    # Without this file, double-click Tauri falls through to ~/.pm/ global.

    # Create .pm/.gitignore if it doesn't exist (idempotent)
    local pm_dir="${repo_root}/.pm"
    if [ ! -f "${pm_dir}/.gitignore" ]; then
        info "Creating .pm/.gitignore..."
        cat > "${pm_dir}/.gitignore" << 'GITIGNORE'
# Runtime files - not tracked
# data.json and config.toml ARE tracked (not listed here = tracked).

# SQLite database (local performance — use data.json for git sync)
data.db

# Negate root .gitignore's *.json pattern if one exists
!data.json

bin/
*.db-wal
*.db-shm
server.json
server.lock
logs/
log/
tauri/
GITIGNORE
        ok "Created .pm/.gitignore"
    fi

    # Print success message
    echo ""
    ok "Installation complete!"
    echo ""
    echo "  Installed to: ${install_dir}"
    echo ""
    echo "  Binaries:"
    ls -1 "$install_dir/" | while read -r f; do echo "    $f"; done
    echo ""
    echo "  Usage:"
    echo "    .pm/bin/pm project list --pretty"
    echo "    .pm/bin/pm desktop"
    echo ""
    echo "  Add to PATH (optional):"
    echo "    export PATH=\"${repo_root}/.pm/bin:\$PATH\""
    echo ""
}

main "$@"
```

After creating, make it executable:
```bash
chmod +x install.sh
```

**Verification**:
```bash
bash -n install.sh    # Syntax check — no output means no errors
```

---

### Step 4: Create `install.ps1`

**Concept: PowerShell Installer for Windows**

PowerShell is the standard scripting language on modern Windows. The installer follows the same patterns as `install.sh` but using PowerShell idioms:

- `$ErrorActionPreference = "Stop"` is the PowerShell equivalent of `set -e`
- `Invoke-WebRequest` replaces `curl`
- `[System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture` for architecture detection
- `try/finally` for cleanup instead of `trap`

**Critical**: Same as `install.sh`, this MUST write `.pm\bin\config.json` with the repo root.

**File**: `install.ps1` (NEW, at repo root)

```powershell
# install.ps1 - Install Blazor Agile Board tools into <repo>\.pm\bin\
#
# Usage:
#   irm https://raw.githubusercontent.com/TonyMarkham/blazor-agile-board/main/install.ps1 | iex
#   # or
#   .\install.ps1
#
# Environment variables:
#   PM_VERSION     - Specific version (default: latest)
#   PM_REPO        - GitHub repo (default: TonyMarkham/blazor-agile-board)

$ErrorActionPreference = "Stop"

# =========================================================================
# Configuration
# =========================================================================

$Repo = if ($env:PM_REPO) { $env:PM_REPO } else { "TonyMarkham/blazor-agile-board" }

# =========================================================================
# Output Helpers
# =========================================================================

function Write-Info($msg) { Write-Host "[info]  $msg" -ForegroundColor Blue }
function Write-Ok($msg) { Write-Host "[ok]    $msg" -ForegroundColor Green }
function Write-Err($msg) { Write-Host "[error] $msg" -ForegroundColor Red; exit 1 }

# =========================================================================
# Repository Root Detection
# =========================================================================

$RepoRoot = & git rev-parse --show-toplevel 2>$null
if (-not $RepoRoot) {
    Write-Err "Not inside a git repository. Run this from within a repo."
}

$InstallDir = Join-Path $RepoRoot ".pm\bin"

# =========================================================================
# Main
# =========================================================================

Write-Info "Blazor Agile Board Installer"
Write-Host ""
Write-Info "Repository: $RepoRoot"

# Detect architecture
$Arch = switch ([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture) {
    "X64"   { "x86_64" }
    "Arm64" { "aarch64" }
    default { Write-Err "Unsupported architecture: $_" }
}

$Target = "${Arch}-pc-windows-msvc"
Write-Info "Platform: $Target"

# Determine version
$Version = $env:PM_VERSION
if (-not $Version) {
    Write-Info "Detecting latest version..."
    try {
        $Release = Invoke-RestMethod "https://api.github.com/repos/$Repo/releases/latest"
        $Version = $Release.tag_name
    }
    catch {
        Write-Err "Could not determine latest version. Set PM_VERSION manually."
    }
}
Write-Info "Version: $Version"

# Build download URL
$VerNum = $Version -replace '^v', ''
$ArchiveName = "pm-${VerNum}-${Target}"
$ArchiveFile = "${ArchiveName}.tar.gz"
$Url = "https://github.com/$Repo/releases/download/$Version/$ArchiveFile"

# Create install directory
New-Item -ItemType Directory -Path $InstallDir -Force | Out-Null

# Download to temp directory
Write-Info "Downloading $ArchiveFile..."
$TmpDir = Join-Path ([System.IO.Path]::GetTempPath()) ([System.Guid]::NewGuid().ToString())
New-Item -ItemType Directory -Path $TmpDir -Force | Out-Null

try {
    $ArchivePath = Join-Path $TmpDir $ArchiveFile
    Invoke-WebRequest -Uri $Url -OutFile $ArchivePath

    # Extract archive (tar is available on Windows 10+)
    Write-Info "Extracting to $InstallDir\..."
    tar xzf $ArchivePath -C $TmpDir

    # Copy binaries
    $BinDir = Join-Path $TmpDir $ArchiveName "bin"
    if (Test-Path $BinDir) {
        Copy-Item "$BinDir\*" $InstallDir -Recurse -Force
    }
    else {
        Write-Err "Archive missing expected bin\ directory"
    }
}
finally {
    # Clean up temp directory
    Remove-Item $TmpDir -Recurse -Force -ErrorAction SilentlyContinue
}

# Write config.json for Tauri double-click support
Write-Info "Writing config.json (repo_root for Tauri)..."
$ConfigJson = @{ repo_root = $RepoRoot } | ConvertTo-Json -Compress
Set-Content (Join-Path $InstallDir "config.json") $ConfigJson -Encoding utf8
Write-Ok "Created $(Join-Path $InstallDir 'config.json')"

# Create .pm\.gitignore if it doesn't exist
$GitignorePath = Join-Path $RepoRoot ".pm\.gitignore"
if (-not (Test-Path $GitignorePath)) {
    Write-Info "Creating .pm\.gitignore..."
    @"
# Runtime files - not tracked
# data.json and config.toml ARE tracked (not listed here = tracked).

# SQLite database (local performance — use data.json for git sync)
data.db

# Negate root .gitignore's *.json pattern if one exists
!data.json

bin/
*.db-wal
*.db-shm
server.json
server.lock
logs/
log/
tauri/
"@ | Set-Content $GitignorePath -Encoding utf8
    Write-Ok "Created $GitignorePath"
}

# Print success
Write-Host ""
Write-Ok "Installation complete!"
Write-Host ""
Write-Host "  Installed to: $InstallDir"
Write-Host ""
Write-Host "  Usage:"
Write-Host "    .pm\bin\pm project list --pretty"
Write-Host "    .pm\bin\pm desktop"
Write-Host ""
Write-Host "  Add to PATH (current session):"
Write-Host "    `$env:PATH = `"$RepoRoot\.pm\bin;`$env:PATH`""
Write-Host ""
```

**Verification**:
```bash
file install.ps1
# Should show: install.ps1: UTF-8 Unicode text
```

---

## Session 121.3 Completion Checklist

```bash
# Verify justfile commands exist
just --list | grep -E "(portable|archive|release|dist)"
# Should show 6 new commands

# Verify install scripts have no syntax errors
bash -n install.sh
file install.ps1

# Verify config.json is written by install.sh
grep -A1 'config.json' install.sh
# Should show the repo_root JSON write

# Full release build test (slow — builds everything in release mode)
just release-build
tar tzf dist/pm-*.tar.gz
# Should show structure like:
#   pm-0.1.0-aarch64-apple-darwin/bin/pm
#   pm-0.1.0-aarch64-apple-darwin/bin/pm-server
#   pm-0.1.0-aarch64-apple-darwin/bin/Project Manager.app/...

# Verify dist/ is gitignored
git status
# dist/ should NOT appear in untracked files
```

### Files Created (2)
| File | Purpose |
|------|---------|
| `install.sh` | macOS/Linux installer (writes `.pm/bin/config.json` with repo root) |
| `install.ps1` | Windows installer (writes `.pm\bin\config.json` with repo root) |

### Files Modified (1)
| File | Change |
|------|--------|
| `justfile` | Distribution variables + 6 new commands + help text |

### `config.json` Contract

Both install scripts write `.pm/bin/config.json`:

```json
{"repo_root": "/absolute/path/to/repo"}
```

This file is consumed by `find_server_dir_from_binary()` in Tauri's `lib.rs` (Session 121.2, Step 5). It enables Tauri to find `.pm/` when launched via double-click outside a terminal, where `git rev-parse --show-toplevel` would fail.

---

## Session 121 Complete

With all three sub-sessions complete, the project has:

1. **Infrastructure** (121.1)
   - Centralized workspace metadata (one version bump updates all crates)
   - Selective `.pm/` git tracking (database and config tracked, runtime files ignored)
   - `Cargo.lock` committed for reproducible builds
   - Justfile migrated from `.server` to `.pm`

2. **Tauri Repo-Awareness** (121.2)
   - `Config::config_dir()` uses `git rev-parse --show-toplevel` — zero env vars
   - `pm desktop` command launches Tauri, setting cwd to repo root
   - `find_server_binary()` and `find_tauri_binary()` use sibling-to-exe + `.pm/bin/`
   - `CLAUDE_FUCKED_UP.md` documents the correct fix and the port 0 trap

3. **Release Distribution** (121.3)
   - `just release-build` creates platform-specific archives
   - `just release <tag>` publishes to GitHub releases
   - `install.sh` and `install.ps1` for one-command installation
   - Install scripts write `config.json` for Tauri double-click support
   - Archive layout matches `find_tauri_binary()` search paths

### Notes

- **GitHub repo URL**: Install scripts and `[workspace.package]` use `TonyMarkham/blazor-agile-board`.
- **Existing `.server/` users**: One-time migration: `cp .server/config.toml .pm/config.toml && cp .server/data.db .pm/data.db`
