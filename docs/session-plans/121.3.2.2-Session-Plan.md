# Session 121.3.2.2: Sprint CRUD

**Parent Plan**: [121.3.2-Session-Plan.md](121.3.2-Session-Plan.md)
**Target**: ~30k tokens
**Prerequisites**: `just check-backend && just test-backend && just check-rs-cli` all pass

---

## Scope

Sprints have zero REST endpoints, zero CLI client methods, and zero CLI commands. The DB repository (`SprintRepository`) already has full CRUD. This session adds the complete REST API module, CLI client methods, and CLI commands.

**Core model fields** (`pm-core/src/models/sprint.rs`): `id`, `project_id`, `name`, `goal`, `start_date`, `end_date`, `status` (SprintStatus: Planned/Active/Completed), `version`, `created_at`, `updated_at`, `created_by`, `updated_by`, `deleted_at`

**New REST endpoints**:

| Method | Path | Handler |
|--------|------|---------|
| `GET` | `/api/v1/projects/{project_id}/sprints` | `list_sprints` |
| `GET` | `/api/v1/sprints/{id}` | `get_sprint` |
| `POST` | `/api/v1/sprints` | `create_sprint` |
| `PUT` | `/api/v1/sprints/{id}` | `update_sprint` |
| `DELETE` | `/api/v1/sprints/{id}` | `delete_sprint` |

---

## Implementation Order

### Step 1: Create Sprint DTO

**Create**: `backend/pm-server/src/api/sprints/sprint_dto.rs`

Follow pattern from `project_dto.rs`. Convert UUIDs to strings, DateTimes to i64 timestamps, SprintStatus to string.

```rust
use pm_core::Sprint;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SprintDto {
    pub id: String,
    pub project_id: String,
    pub name: String,
    pub goal: Option<String>,
    pub start_date: i64,
    pub end_date: i64,
    pub status: String,
    pub version: i32,
    pub created_at: i64,
    pub updated_at: i64,
    pub created_by: String,
    pub updated_by: String,
}

impl From<Sprint> for SprintDto { ... }
```

---

### Step 2: Create Response Wrappers

**Create**: `backend/pm-server/src/api/sprints/sprint_response.rs`

```rust
use crate::SprintDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SprintResponse {
    pub sprint: SprintDto,
}
```

**Create**: `backend/pm-server/src/api/sprints/sprint_list_response.rs`

```rust
use crate::SprintDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SprintListResponse {
    pub sprints: Vec<SprintDto>,
}
```

---

### Step 3: Create Request DTOs

**Create**: `backend/pm-server/src/api/sprints/create_sprint_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct CreateSprintRequest {
    pub project_id: String,
    pub name: String,
    #[serde(default)]
    pub goal: Option<String>,
    /// Unix timestamp
    pub start_date: i64,
    /// Unix timestamp
    pub end_date: i64,
}
```

**Create**: `backend/pm-server/src/api/sprints/update_sprint_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct UpdateSprintRequest {
    #[serde(default)]
    pub name: Option<String>,
    #[serde(default)]
    pub goal: Option<String>,
    #[serde(default)]
    pub start_date: Option<i64>,
    #[serde(default)]
    pub end_date: Option<i64>,
    /// Status: "planned", "active", "completed"
    #[serde(default)]
    pub status: Option<String>,
    pub expected_version: i32,
}
```

---

### Step 4: Create Handler Functions

**Create**: `backend/pm-server/src/api/sprints/sprints.rs`

Follow the handler pattern from `work_items.rs` and `projects.rs`:

**`list_sprints`** (`GET /api/v1/projects/{project_id}/sprints`):
- Parse project_id UUID from path
- `SprintRepository::find_by_project(project_id)`
- Return `SprintListResponse`

**`get_sprint`** (`GET /api/v1/sprints/{id}`):
- Parse UUID from path
- `SprintRepository::find_by_id(id)`
- Return 404 if not found
- Return `SprintResponse`

**`create_sprint`** (`POST /api/v1/sprints`):
- Parse `CreateSprintRequest`
- Validate project exists, name non-empty (sanitize with `sanitize_string()`)
- Convert timestamps: `let start = DateTime::from_timestamp(req.start_date, 0).ok_or(ApiError::Validation { message: "Invalid start_date timestamp" })?;` (same for `end_date`)
- Validate `end > start` — return `ApiError::Validation` if not
- Create `Sprint::new(project_id, name, goal, start, end, user_id)` — note: `Sprint::new()` takes `DateTime<Utc>`, not `i64`
- Create `ActivityLog::created("sprint", sprint.id, user_id)`
- **Transaction**: `SprintRepository::create()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, None, Some(sprint_id), ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_sprint_created_response` (non-fatal)
- Return `SprintResponse`

**`update_sprint`** (`PUT /api/v1/sprints/{id}`):
- Parse UUID, parse `UpdateSprintRequest`
- Load sprint, check version (optimistic locking)
- Apply optional updates (sanitize name/goal with `sanitize_string()`; convert optional `i64` timestamps to `DateTime<Utc>` via `DateTime::from_timestamp()` with validation; validate end > start if either date changes)
- Create `ActivityLog::updated("sprint", sprint.id, user_id, &[])`
- **Transaction**: `SprintRepository::update()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, None, Some(sprint_id), ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_sprint_updated_response` (non-fatal)
- Return `SprintResponse`

**`delete_sprint`** (`DELETE /api/v1/sprints/{id}`):
- Parse UUID, load sprint
- Create `ActivityLog::deleted("sprint", sprint.id, user_id)`
- **Transaction**: `SprintRepository::delete()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, None, Some(sprint_id), ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_sprint_deleted_response` (non-fatal)
- Return `DeleteResponse`

**Required**: All mutation handlers (create, update, delete) MUST write `ActivityLog` entries and broadcast via WebSocket, matching the pattern in `work_items.rs`:
1. Create `ActivityLog::created("sprint", ...)` / `::updated(...)` / `::deleted(...)`
2. Write entity + activity log in same transaction
3. Broadcast `ActivityLogCreated` via `state.registry.broadcast_activity_log_created(project_id, None, Some(sprint_id), message)` (non-fatal)
4. Broadcast entity event via `state.registry.broadcast_to_project(project_id, message)` using `build_sprint_created_response` / `build_sprint_updated_response` / `build_sprint_deleted_response` from `pm_ws` (non-fatal)

---

### Step 5: Create Module File

**Create**: `backend/pm-server/src/api/sprints/mod.rs`

```rust
pub(crate) mod create_sprint_request;
pub(crate) mod sprint_dto;
pub(crate) mod sprint_list_response;
pub(crate) mod sprint_response;
#[allow(clippy::module_inception)]
pub(crate) mod sprints;
pub(crate) mod update_sprint_request;
```

---

### Step 6: Update API Module + Re-exports + Routes

**File**: `backend/pm-server/src/api/mod.rs`

Add: `pub(crate) mod sprints;`

**File**: `backend/pm-server/src/lib.rs`

Add re-exports for sprint types and handlers:
```rust
sprints::{
    sprint_dto::SprintDto,
    sprint_response::SprintResponse,
    sprint_list_response::SprintListResponse,
    create_sprint_request::CreateSprintRequest,
    update_sprint_request::UpdateSprintRequest,
    sprints::{list_sprints, get_sprint, create_sprint, update_sprint, delete_sprint},
},
```

**File**: `backend/pm-server/src/routes.rs`

Add to `build_router()`:
```rust
// REST API v1 - Sprints
.route("/api/v1/projects/{project_id}/sprints", get(list_sprints))
.route("/api/v1/sprints", post(create_sprint))
.route("/api/v1/sprints/{id}", get(get_sprint))
.route("/api/v1/sprints/{id}", put(update_sprint))
.route("/api/v1/sprints/{id}", delete(delete_sprint))
```

Update imports at top of `routes.rs`.

**Verification**: `just check-rs-server`

---

### Step 7: Add CLI Client Methods

**File**: `backend/crates/pm-cli/src/client/client.rs`

Add a new Sprint Operations section:

```rust
// =========================================================================
// Sprint Operations
// =========================================================================

pub async fn list_sprints(&self, project_id: &str) -> CliClientResult<Value> { ... }
pub async fn get_sprint(&self, id: &str) -> CliClientResult<Value> { ... }
pub async fn create_sprint(&self, project_id: &str, name: &str, start_date: i64, end_date: i64, goal: Option<&str>) -> CliClientResult<Value> { ... }
pub async fn update_sprint(&self, id: &str, name: Option<&str>, goal: Option<&str>, start_date: Option<i64>, end_date: Option<i64>, status: Option<&str>, expected_version: i32) -> CliClientResult<Value> { ... }
pub async fn delete_sprint(&self, id: &str) -> CliClientResult<Value> { ... }
```

Follow the existing inline `#[derive(Serialize)] struct` pattern from `create_work_item()`.

---

### Step 8: Add CLI Commands

**Create**: `backend/crates/pm-cli/src/sprint_commands.rs`

Follow pattern from `work_item_commands.rs`:

```rust
use clap::Subcommand;

#[derive(Subcommand)]
pub enum SprintCommands {
    List {
        /// Project ID (UUID)
        project_id: String,
    },
    Get {
        /// Sprint ID (UUID)
        id: String,
    },
    Create {
        #[arg(long)]
        project_id: String,
        #[arg(long)]
        name: String,
        /// Unix timestamp
        #[arg(long)]
        start_date: i64,
        /// Unix timestamp
        #[arg(long)]
        end_date: i64,
        #[arg(long)]
        goal: Option<String>,
    },
    Update {
        id: String,
        #[arg(long)]
        name: Option<String>,
        #[arg(long)]
        goal: Option<String>,
        #[arg(long)]
        start_date: Option<i64>,
        #[arg(long)]
        end_date: Option<i64>,
        #[arg(long, value_parser = ["planned", "active", "completed"])]
        status: Option<String>,
        #[arg(long)]
        version: i32,
    },
    Delete {
        id: String,
    },
}
```

---

### Step 9: Wire Sprint Commands

**File**: `backend/crates/pm-cli/src/commands.rs`

Add Sprint variant:
```rust
/// Sprint operations
Sprint {
    #[command(subcommand)]
    action: SprintCommands,
},
```

Add import: `use crate::sprint_commands::SprintCommands;`

**File**: `backend/crates/pm-cli/src/main.rs`

Add `mod sprint_commands;` and import `SprintCommands`.

Add match arm in the command dispatch:
```rust
Commands::Sprint { action } => match action {
    SprintCommands::List { project_id } => client.list_sprints(&project_id).await,
    SprintCommands::Get { id } => client.get_sprint(&id).await,
    SprintCommands::Create { project_id, name, start_date, end_date, goal } => {
        client.create_sprint(&project_id, &name, start_date, end_date, goal.as_deref()).await
    }
    SprintCommands::Update { id, name, goal, start_date, end_date, status, version } => {
        client.update_sprint(&id, name.as_deref(), goal.as_deref(), start_date, end_date, status.as_deref(), version).await
    }
    SprintCommands::Delete { id } => client.delete_sprint(&id).await,
},
```

**Verification**: `just check-rs-cli`

---

## Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes
- [ ] `just clippy-backend` passes
- [ ] `just test-backend` passes
- [ ] `just check-rs-cli` passes

### Files Created (8)
- `backend/pm-server/src/api/sprints/mod.rs`
- `backend/pm-server/src/api/sprints/sprint_dto.rs`
- `backend/pm-server/src/api/sprints/sprint_response.rs`
- `backend/pm-server/src/api/sprints/sprint_list_response.rs`
- `backend/pm-server/src/api/sprints/create_sprint_request.rs`
- `backend/pm-server/src/api/sprints/update_sprint_request.rs`
- `backend/pm-server/src/api/sprints/sprints.rs`
- `backend/crates/pm-cli/src/sprint_commands.rs`

### Files Modified (6)
- `backend/pm-server/src/api/mod.rs` — add `sprints` module
- `backend/pm-server/src/lib.rs` — re-export sprint types/handlers
- `backend/pm-server/src/routes.rs` — register 5 routes
- `backend/crates/pm-cli/src/client/client.rs` — add 5 client methods
- `backend/crates/pm-cli/src/commands.rs` — add Sprint variant
- `backend/crates/pm-cli/src/main.rs` — add `mod sprint_commands`, wire sprint commands

---

## Next Session

**Session 121.3.2.3** adds Dependency Create/Read/Delete (REST + CLI).
