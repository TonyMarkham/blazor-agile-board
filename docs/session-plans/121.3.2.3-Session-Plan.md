# Session 121.3.2.3: Dependency Create/Read/Delete

**Parent Plan**: [121.3.2-Session-Plan.md](121.3.2-Session-Plan.md)
**Target**: ~20k tokens
**Prerequisites**: `just check-backend && just test-backend && just check-rs-cli` all pass
**Status**: ✅ **COMPLETE** (2026-02-08)

---

## Scope

Dependencies have zero REST endpoints, zero CLI client methods, and zero CLI commands. The DB repository (`DependencyRepository`) already has full CRUD. This session adds REST endpoints, CLI client methods, and CLI commands.

No update operation — dependencies are link records that you create or delete. This is the simplest entity (no `project_id`, no `updated_at`, no `version`).

This session also **extracts cycle detection** from `pm-ws` into `DependencyRepository` so both the WebSocket and REST handlers use the same validation. Currently `detect_circular_dependency()` lives in `pm-ws/src/handlers/dependency.rs:52-119` and only protects WebSocket users — CLI users could create cycles via REST without this fix.

**Core model fields** (`pm-core/src/models/dependency.rs`): `id`, `blocking_item_id`, `blocked_item_id`, `dependency_type` (DependencyType: Blocks/RelatesTo), `created_at`, `created_by`, `deleted_at`

**New REST endpoints**:

| Method | Path | Handler |
|--------|------|---------|
| `GET` | `/api/v1/work-items/{id}/dependencies` | `list_dependencies` |
| `POST` | `/api/v1/dependencies` | `create_dependency` |
| `DELETE` | `/api/v1/dependencies/{id}` | `delete_dependency` |

---

## Implementation Order

### Step 0: Extract Cycle Detection into DependencyRepository

**Why**: Cycle detection currently lives in `pm-ws/src/handlers/dependency.rs:52-119` and only protects WebSocket users. Moving it to the repository ensures both WebSocket and REST handlers validate cycles through the same code path.

**File**: `backend/crates/pm-db/src/repositories/dependency_repository.rs`

Add a `detect_cycle()` method. The algorithm is a BFS that checks whether `blocked_id` can reach `blocking_id` through existing `Blocks`-type edges:

```rust
/// Check if adding `blocking_id → blocked_id` would create a cycle.
/// Returns `Ok(None)` if no cycle, `Ok(Some(path))` if cycle detected.
/// Only follows `Blocks` edges — `RelatesTo` cannot create cycles.
pub async fn detect_cycle(
    &self,
    blocking_id: Uuid,
    blocked_id: Uuid,
) -> DbErrorResult<Option<Vec<Uuid>>> {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut parent_map: HashMap<Uuid, Uuid> = HashMap::new();

    queue.push_back(blocked_id);
    visited.insert(blocked_id);

    while let Some(current) = queue.pop_front() {
        let blocked_by_current = self.find_blocked(current).await?;

        for dep in blocked_by_current {
            if dep.dependency_type != DependencyType::Blocks {
                continue;
            }
            if dep.blocked_item_id == blocking_id {
                // Reconstruct cycle path for error message
                let mut path = vec![blocking_id];
                let mut node = current;
                while let Some(&parent) = parent_map.get(&node) {
                    path.push(node);
                    node = parent;
                }
                path.push(blocked_id);
                path.reverse();
                return Ok(Some(path));
            }
            if !visited.contains(&dep.blocked_item_id) {
                visited.insert(dep.blocked_item_id);
                parent_map.insert(dep.blocked_item_id, current);
                queue.push_back(dep.blocked_item_id);
            }
        }
    }
    Ok(None)
}
```

**File**: `backend/crates/pm-ws/src/handlers/dependency.rs`

**Before** (lines 52-119): Local `detect_circular_dependency()` function returns `WsErrorResult<()>` — it does the BFS, formats the error message, and returns `Err(WsError::ValidationError { ... })` directly.

**After**: Delete the local function entirely (lines 52-119). At the call site (line 260), replace `detect_circular_dependency(&dep_repo, blocking_id, blocked_id).await?;` with:

```rust
// The new repo method returns DbErrorResult<Option<Vec<Uuid>>> — different error type,
// different return semantics. Map DbError → WsError, and Option → WsError::ValidationError.
if let Some(cycle_path) = dep_repo.detect_cycle(blocking_id, blocked_id).await
    .map_err(|e| WsError::Database {
        message: e.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?
{
    let path_str = cycle_path.iter()
        .map(|id| id.to_string()[..8].to_string())
        .collect::<Vec<_>>()
        .join(" → ");
    return Err(WsError::ValidationError {
        message: format!("Circular dependency detected: {}. This would create a cycle.", path_str),
        field: Some("blocking_item_id".into()),
        location: ErrorLocation::from(Location::caller()),
    });
}
```

**Key difference from old code**: The old function did the BFS itself and returned `WsErrorResult<()>`. The new repo method returns `DbErrorResult<Option<Vec<Uuid>>>` — the caller is responsible for:
1. Mapping `DbError` → `WsError::Database` (via `.map_err()`)
2. Converting `Some(path)` → `WsError::ValidationError` with the formatted cycle path

Also remove the now-unused `HashSet`, `VecDeque`, and `HashMap` imports if they were only used by the deleted function.

**Verification**: `just check-rs-db && just check-rs-ws && just test-backend`

---

### Step 1: Create Dependency DTO

**Create**: `backend/pm-server/src/api/dependencies/dependency_dto.rs`

```rust
use pm_core::Dependency;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct DependencyDto {
    pub id: String,
    pub blocking_item_id: String,
    pub blocked_item_id: String,
    pub dependency_type: String,
    pub created_at: i64,
    pub created_by: String,
}

impl From<Dependency> for DependencyDto {
    fn from(d: Dependency) -> Self {
        Self {
            id: d.id.to_string(),
            blocking_item_id: d.blocking_item_id.to_string(),
            blocked_item_id: d.blocked_item_id.to_string(),
            dependency_type: d.dependency_type.as_str().to_string(),
            created_at: d.created_at.timestamp(),
            created_by: d.created_by.to_string(),
        }
    }
}
```

---

### Step 2: Create Response Wrapper

**Create**: `backend/pm-server/src/api/dependencies/dependency_list_response.rs`

```rust
use crate::DependencyDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct DependencyListResponse {
    pub dependencies: Vec<DependencyDto>,
}
```

No single-item response needed — dependencies are always listed or created (create returns the created item directly).

---

### Step 3: Create Request DTO

**Create**: `backend/pm-server/src/api/dependencies/create_dependency_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct CreateDependencyRequest {
    pub blocking_item_id: String,
    pub blocked_item_id: String,
    /// "blocks" or "relates_to"
    pub dependency_type: String,
}
```

---

### Step 4: Create Handler Functions

**Create**: `backend/pm-server/src/api/dependencies/dependencies.rs`

**`list_dependencies`** (`GET /api/v1/work-items/{id}/dependencies`):
- Parse work item UUID from path
- `DependencyRepository::find_blocking(id)` — items blocking this one
- `DependencyRepository::find_blocked(id)` — items blocked by this one
- Combine both lists (deduplicate by id) into `DependencyListResponse`

**`create_dependency`** (`POST /api/v1/dependencies`):
- Parse `CreateDependencyRequest`
- Validate both work item IDs exist (via `WorkItemRepository::find_by_id()`) — also fetch the blocking work item to get `project_id` for broadcasts
- Validate dependency_type is valid ("blocks" or "relates_to")
- Validate no self-reference (`blocking_item_id != blocked_item_id`)
- Check for duplicate (via `DependencyRepository::find_by_pair()`)
- **Cycle detection** (for Blocks type only): call `DependencyRepository::detect_cycle(blocking_id, blocked_id)` — return `ApiError::Validation` with cycle path if `Some(path)` returned
- Create `Dependency::new(blocking_id, blocked_id, dep_type, user_id)`
- Create `ActivityLog::created("dependency", dependency.id, user_id)`
- **Transaction**: `DependencyRepository::create()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, None, None, ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_dependency_created_response` (non-fatal)
- Return the created `DependencyDto`

**`delete_dependency`** (`DELETE /api/v1/dependencies/{id}`):
- Parse UUID from path
- Load dependency via `find_by_id()`
- Fetch blocking work item to get `project_id` for broadcasts
- Create `ActivityLog::deleted("dependency", dependency.id, user_id)`
- **Transaction**: `DependencyRepository::delete()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, None, None, ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_dependency_deleted_response` (non-fatal)
- Return `DeleteResponse`

**Required**: Mutation handlers (create, delete) MUST write `ActivityLog` entries and broadcast via WebSocket, matching the pattern in `work_items.rs`:
1. Create `ActivityLog::created("dependency", ...)` / `::deleted(...)`
2. Write entity + activity log in same transaction
3. Broadcast `ActivityLogCreated` via `state.registry.broadcast_activity_log_created(project_id, None, None, message)` (non-fatal) — get `project_id` from the blocking work item
4. Broadcast entity event via `state.registry.broadcast_to_project(project_id, message)` using `build_dependency_created_response` / `build_dependency_deleted_response` from `pm_ws` (non-fatal)

Cycle detection uses the shared `DependencyRepository::detect_cycle()` method (extracted in Step 0), so both REST and WebSocket paths enforce the same validation.

---

### Step 5: Create Module File

**Create**: `backend/pm-server/src/api/dependencies/mod.rs`

```rust
pub(crate) mod create_dependency_request;
pub(crate) mod dependency_dto;
pub(crate) mod dependency_list_response;
#[allow(clippy::module_inception)]
pub(crate) mod dependencies;
```

---

### Step 6: Update API Module + Re-exports + Routes

**File**: `backend/pm-server/src/api/mod.rs`

Add: `pub(crate) mod dependencies;`

**File**: `backend/pm-server/src/lib.rs`

Add re-exports:
```rust
dependencies::{
    dependency_dto::DependencyDto,
    dependency_list_response::DependencyListResponse,
    create_dependency_request::CreateDependencyRequest,
    dependencies::{list_dependencies, create_dependency, delete_dependency},
},
```

**File**: `backend/pm-server/src/routes.rs`

Add to `build_router()`:
```rust
// REST API v1 - Dependencies
.route("/api/v1/work-items/{id}/dependencies", get(list_dependencies))
.route("/api/v1/dependencies", post(create_dependency))
.route("/api/v1/dependencies/{id}", delete(delete_dependency))
```

Update imports at top of `routes.rs`.

**Verification**: `just check-rs-server`

---

### Step 7: Add CLI Client Methods

**File**: `backend/crates/pm-cli/src/client/client.rs`

Add a Dependency Operations section:

```rust
// =========================================================================
// Dependency Operations
// =========================================================================

/// List dependencies for a work item (both blocking and blocked)
pub async fn list_dependencies(&self, work_item_id: &str) -> CliClientResult<Value> {
    let req = self.request(
        Method::GET,
        &format!("/api/v1/work-items/{}/dependencies", work_item_id),
    );
    self.execute(req).await
}

/// Create a dependency link
pub async fn create_dependency(
    &self,
    blocking_item_id: &str,
    blocked_item_id: &str,
    dependency_type: &str,
) -> CliClientResult<Value> {
    #[derive(Serialize)]
    struct CreateRequest<'a> {
        blocking_item_id: &'a str,
        blocked_item_id: &'a str,
        dependency_type: &'a str,
    }

    let body = CreateRequest { blocking_item_id, blocked_item_id, dependency_type };
    let req = self.request(Method::POST, "/api/v1/dependencies").json(&body);
    self.execute(req).await
}

/// Delete a dependency
pub async fn delete_dependency(&self, id: &str) -> CliClientResult<Value> {
    let req = self.request(Method::DELETE, &format!("/api/v1/dependencies/{}", id));
    self.execute(req).await
}
```

---

### Step 8: Add CLI Commands

**Create**: `backend/crates/pm-cli/src/dependency_commands.rs`

```rust
use clap::Subcommand;

#[derive(Subcommand)]
pub enum DependencyCommands {
    /// List dependencies for a work item
    List {
        /// Work item ID (UUID)
        work_item_id: String,
    },
    /// Create a dependency link between two work items
    Create {
        /// ID of the work item that blocks (UUID)
        #[arg(long)]
        blocking: String,
        /// ID of the work item that is blocked (UUID)
        #[arg(long)]
        blocked: String,
        /// Dependency type: blocks or relates_to
        #[arg(long, value_parser = ["blocks", "relates_to"])]
        r#type: String,
    },
    /// Delete a dependency
    Delete {
        /// Dependency ID (UUID)
        id: String,
    },
}
```

---

### Step 9: Wire Dependency Commands

**File**: `backend/crates/pm-cli/src/commands.rs`

Add:
```rust
/// Dependency operations
Dependency {
    #[command(subcommand)]
    action: DependencyCommands,
},
```

Add import: `use crate::dependency_commands::DependencyCommands;`

**File**: `backend/crates/pm-cli/src/main.rs`

Add `mod dependency_commands;` and import `DependencyCommands`.

Add match arm:
```rust
Commands::Dependency { action } => match action {
    DependencyCommands::List { work_item_id } => {
        client.list_dependencies(&work_item_id).await
    }
    DependencyCommands::Create { blocking, blocked, r#type } => {
        client.create_dependency(&blocking, &blocked, &r#type).await
    }
    DependencyCommands::Delete { id } => client.delete_dependency(&id).await,
},
```

**Verification**: `just check-rs-cli`

---

## Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes
- [ ] `just clippy-backend` passes
- [ ] `just test-backend` passes
- [ ] `just check-rs-cli` passes

### Files Created (6)
- `backend/pm-server/src/api/dependencies/mod.rs`
- `backend/pm-server/src/api/dependencies/dependency_dto.rs`
- `backend/pm-server/src/api/dependencies/dependency_list_response.rs`
- `backend/pm-server/src/api/dependencies/create_dependency_request.rs`
- `backend/pm-server/src/api/dependencies/dependencies.rs`
- `backend/crates/pm-cli/src/dependency_commands.rs`

### Files Modified (8)
- `backend/crates/pm-db/src/repositories/dependency_repository.rs` — add `detect_cycle()` method
- `backend/crates/pm-ws/src/handlers/dependency.rs` — replace local `detect_circular_dependency()` with `repo.detect_cycle()` call, remove local function
- `backend/pm-server/src/api/mod.rs` — add `dependencies` module
- `backend/pm-server/src/lib.rs` — re-export dependency types/handlers
- `backend/pm-server/src/routes.rs` — register 3 routes
- `backend/crates/pm-cli/src/client/client.rs` — add 3 client methods
- `backend/crates/pm-cli/src/commands.rs` — add Dependency variant
- `backend/crates/pm-cli/src/main.rs` — add `mod dependency_commands`, wire commands

---

## Completion Summary

**Date Completed**: 2026-02-08
**Actual Token Usage**: ~92k tokens (teaching mode session)
**Build Status**: ✅ All checks passing
**Test Status**: ✅ All tests passing (backend + CLI)
**Manual Testing**: ✅ Complete (all validations verified)

### Deliverables

**REST Endpoints** (3):
- `GET /api/v1/work-items/{id}/dependencies` - List dependencies
- `POST /api/v1/dependencies` - Create dependency (with cycle detection)
- `DELETE /api/v1/dependencies/{id}` - Delete dependency

**CLI Commands** (3):
- `pm dependency list <work_item_id>`
- `pm dependency create --blocking <id> --blocked <id> --type <blocks|relates_to>`
- `pm dependency delete <id>`

**Key Features Implemented**:
- ✅ Cycle detection extracted to `DependencyRepository::detect_cycle()` (shared by REST + WebSocket)
- ✅ Complete validation: no self-references, no duplicates, no cycles (for "blocks" type)
- ✅ Activity log entries for all mutations
- ✅ WebSocket broadcasts to connected clients
- ✅ Helpful error messages with shortened UUIDs in cycle paths

**Files Created**: 6 (all DTOs, handlers, CLI commands)
**Files Modified**: 8 (repository, WebSocket handler, routes, CLI integration)

### Verification

All acceptance criteria met:
- [x] `just check-backend` passes
- [x] `just clippy-backend` passes (zero warnings)
- [x] `just test-backend` passes
- [x] `just check-rs-cli` passes
- [x] Manual testing confirms all validations work correctly
- [x] Cycle detection prevents circular "blocks" dependencies
- [x] "relates_to" type correctly bypasses cycle check

---

## Next Session

**Session 121.3.2.4** adds Swim Lane Read-Only endpoints (DTO + GET + CLI list).
