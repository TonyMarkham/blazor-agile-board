# Session 121.3.2.4: Swim Lane CRUD

**Parent Plan**: [121.3.2-Session-Plan.md](121.3.2-Session-Plan.md)
**Target**: ~25k tokens
**Prerequisites**: `just check-backend && just test-backend && just check-rs-cli` all pass

---

## Scope

Swim lanes (Kanban board columns) have zero REST endpoints, zero CLI client methods, and zero CLI commands. The DB repository (`SwimLaneRepository`) already has full CRUD. This session adds the complete REST API module, CLI client methods, and CLI commands.

**Core model fields** (`pm-core/src/models/swim_lane.rs`): `id`, `project_id`, `name`, `status_value`, `position`, `is_default`, `created_at`, `updated_at`, `deleted_at`

Note: No `created_by`/`updated_by`, no `version`. Has `is_default` flag — default lanes cannot be deleted.

**New REST endpoints**:

| Method | Path | Handler |
|--------|------|---------|
| `GET` | `/api/v1/projects/{project_id}/swim-lanes` | `list_swim_lanes` |
| `GET` | `/api/v1/swim-lanes/{id}` | `get_swim_lane` |
| `POST` | `/api/v1/swim-lanes` | `create_swim_lane` |
| `PUT` | `/api/v1/swim-lanes/{id}` | `update_swim_lane` |
| `DELETE` | `/api/v1/swim-lanes/{id}` | `delete_swim_lane` |

---

## Implementation Order

### Step 1: Create Swim Lane DTO

**Create**: `backend/pm-server/src/api/swim_lanes/swim_lane_dto.rs`

```rust
use pm_core::SwimLane;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SwimLaneDto {
    pub id: String,
    pub project_id: String,
    pub name: String,
    pub status_value: String,
    pub position: i32,
    pub is_default: bool,
    pub created_at: i64,
    pub updated_at: i64,
}

impl From<SwimLane> for SwimLaneDto {
    fn from(sl: SwimLane) -> Self {
        Self {
            id: sl.id.to_string(),
            project_id: sl.project_id.to_string(),
            name: sl.name,
            status_value: sl.status_value,
            position: sl.position,
            is_default: sl.is_default,
            created_at: sl.created_at.timestamp(),
            updated_at: sl.updated_at.timestamp(),
        }
    }
}
```

---

### Step 2: Create Response Wrappers

**Create**: `backend/pm-server/src/api/swim_lanes/swim_lane_response.rs`

```rust
use crate::SwimLaneDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SwimLaneResponse {
    pub swim_lane: SwimLaneDto,
}
```

**Create**: `backend/pm-server/src/api/swim_lanes/swim_lane_list_response.rs`

```rust
use crate::SwimLaneDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct SwimLaneListResponse {
    pub swim_lanes: Vec<SwimLaneDto>,
}
```

---

### Step 3: Create Request DTOs

**Create**: `backend/pm-server/src/api/swim_lanes/create_swim_lane_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct CreateSwimLaneRequest {
    pub project_id: String,
    pub name: String,
    pub status_value: String,
    pub position: i32,
}
```

**Create**: `backend/pm-server/src/api/swim_lanes/update_swim_lane_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct UpdateSwimLaneRequest {
    #[serde(default)]
    pub name: Option<String>,
    #[serde(default)]
    pub status_value: Option<String>,
    #[serde(default)]
    pub position: Option<i32>,
}
```

Note: No `expected_version` since SwimLane has no `version` field.

---

### Step 4: Create Handler Functions

**Create**: `backend/pm-server/src/api/swim_lanes/swim_lanes.rs`

**`list_swim_lanes`** (`GET /api/v1/projects/{project_id}/swim-lanes`):
- Parse project_id UUID from path
- `SwimLaneRepository::find_by_project(project_id)` — ordered by position
- Return `SwimLaneListResponse`

**`get_swim_lane`** (`GET /api/v1/swim-lanes/{id}`):
- Parse UUID from path
- `SwimLaneRepository::find_by_id(id)`
- Return 404 if not found
- Return `SwimLaneResponse`

**`create_swim_lane`** (`POST /api/v1/swim-lanes`):
- Parse `CreateSwimLaneRequest`
- Validate project exists, name non-empty
- Create `SwimLane::new(project_id, name, status_value, position)`
- `SwimLaneRepository::create()`
- Return `SwimLaneResponse`

**`update_swim_lane`** (`PUT /api/v1/swim-lanes/{id}`):
- Parse UUID, parse `UpdateSwimLaneRequest`
- Load swim lane via `find_by_id()`
- Apply optional updates (name, status_value, position)
- `SwimLaneRepository::update()`
- Return `SwimLaneResponse`

**`delete_swim_lane`** (`DELETE /api/v1/swim-lanes/{id}`):
- Parse UUID, load swim lane
- **Reject if `is_default == true`** — return error "Cannot delete default swim lane"
- `SwimLaneRepository::delete()` (soft delete)
- Return `DeleteResponse`

**Note**: These REST endpoints are for CLI/sync tooling only — no WebSocket broadcasts. Real-time updates remain exclusive to WebSocket protocol handlers. See parent plan architectural note.

---

### Step 5: Create Module File

**Create**: `backend/pm-server/src/api/swim_lanes/mod.rs`

```rust
pub(crate) mod create_swim_lane_request;
pub(crate) mod swim_lane_dto;
pub(crate) mod swim_lane_list_response;
pub(crate) mod swim_lane_response;
#[allow(clippy::module_inception)]
pub(crate) mod swim_lanes;
pub(crate) mod update_swim_lane_request;
```

---

### Step 6: Update API Module + Re-exports + Routes

**File**: `backend/pm-server/src/api/mod.rs`

Add: `pub(crate) mod swim_lanes;`

**File**: `backend/pm-server/src/lib.rs`

Add re-exports:
```rust
swim_lanes::{
    swim_lane_dto::SwimLaneDto,
    swim_lane_response::SwimLaneResponse,
    swim_lane_list_response::SwimLaneListResponse,
    create_swim_lane_request::CreateSwimLaneRequest,
    update_swim_lane_request::UpdateSwimLaneRequest,
    swim_lanes::{list_swim_lanes, get_swim_lane, create_swim_lane, update_swim_lane, delete_swim_lane},
},
```

**File**: `backend/pm-server/src/routes.rs`

Add to `build_router()`:
```rust
// REST API v1 - Swim Lanes
.route("/api/v1/projects/{project_id}/swim-lanes", get(list_swim_lanes))
.route("/api/v1/swim-lanes", post(create_swim_lane))
.route("/api/v1/swim-lanes/{id}", get(get_swim_lane))
.route("/api/v1/swim-lanes/{id}", put(update_swim_lane))
.route("/api/v1/swim-lanes/{id}", delete(delete_swim_lane))
```

Update imports at top of `routes.rs`.

**Verification**: `just check-rs-server`

---

### Step 7: Add CLI Client Methods

**File**: `backend/crates/pm-cli/src/client/client.rs`

Add a Swim Lane Operations section:

```rust
// =========================================================================
// Swim Lane Operations
// =========================================================================

pub async fn list_swim_lanes(&self, project_id: &str) -> CliClientResult<Value> {
    let req = self.request(
        Method::GET,
        &format!("/api/v1/projects/{}/swim-lanes", project_id),
    );
    self.execute(req).await
}

pub async fn get_swim_lane(&self, id: &str) -> CliClientResult<Value> {
    let req = self.request(Method::GET, &format!("/api/v1/swim-lanes/{}", id));
    self.execute(req).await
}

pub async fn create_swim_lane(
    &self,
    project_id: &str,
    name: &str,
    status_value: &str,
    position: i32,
) -> CliClientResult<Value> {
    #[derive(Serialize)]
    struct CreateRequest<'a> {
        project_id: &'a str,
        name: &'a str,
        status_value: &'a str,
        position: i32,
    }

    let body = CreateRequest { project_id, name, status_value, position };
    let req = self.request(Method::POST, "/api/v1/swim-lanes").json(&body);
    self.execute(req).await
}

pub async fn update_swim_lane(
    &self,
    id: &str,
    name: Option<&str>,
    status_value: Option<&str>,
    position: Option<i32>,
) -> CliClientResult<Value> {
    #[derive(Serialize)]
    struct UpdateRequest<'a> {
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<&'a str>,
        #[serde(skip_serializing_if = "Option::is_none")]
        status_value: Option<&'a str>,
        #[serde(skip_serializing_if = "Option::is_none")]
        position: Option<i32>,
    }

    let body = UpdateRequest { name, status_value, position };
    let req = self
        .request(Method::PUT, &format!("/api/v1/swim-lanes/{}", id))
        .json(&body);
    self.execute(req).await
}

pub async fn delete_swim_lane(&self, id: &str) -> CliClientResult<Value> {
    let req = self.request(Method::DELETE, &format!("/api/v1/swim-lanes/{}", id));
    self.execute(req).await
}
```

---

### Step 8: Add CLI Commands

**Create**: `backend/crates/pm-cli/src/swim_lane_commands.rs`

```rust
use clap::Subcommand;

#[derive(Subcommand)]
pub enum SwimLaneCommands {
    /// List swim lanes for a project (ordered by position)
    List {
        /// Project ID (UUID)
        project_id: String,
    },
    /// Get a swim lane by ID
    Get {
        /// Swim lane ID (UUID)
        id: String,
    },
    /// Create a new swim lane
    Create {
        #[arg(long)]
        project_id: String,
        #[arg(long)]
        name: String,
        /// Status value this lane represents (e.g., "todo", "in_progress")
        #[arg(long)]
        status_value: String,
        /// Display position (0-based)
        #[arg(long)]
        position: i32,
    },
    /// Update a swim lane
    Update {
        /// Swim lane ID (UUID)
        id: String,
        #[arg(long)]
        name: Option<String>,
        #[arg(long)]
        status_value: Option<String>,
        #[arg(long)]
        position: Option<i32>,
    },
    /// Delete a swim lane (cannot delete default lanes)
    Delete {
        /// Swim lane ID (UUID)
        id: String,
    },
}
```

---

### Step 9: Wire Swim Lane Commands

**File**: `backend/crates/pm-cli/src/commands.rs`

Add:
```rust
/// Swim lane operations
SwimLane {
    #[command(subcommand)]
    action: SwimLaneCommands,
},
```

Add import: `use crate::swim_lane_commands::SwimLaneCommands;`

**File**: `backend/crates/pm-cli/src/main.rs`

Add `mod swim_lane_commands;` and import `SwimLaneCommands`.

Add match arm:
```rust
Commands::SwimLane { action } => match action {
    SwimLaneCommands::List { project_id } => client.list_swim_lanes(&project_id).await,
    SwimLaneCommands::Get { id } => client.get_swim_lane(&id).await,
    SwimLaneCommands::Create { project_id, name, status_value, position } => {
        client.create_swim_lane(&project_id, &name, &status_value, position).await
    }
    SwimLaneCommands::Update { id, name, status_value, position } => {
        client.update_swim_lane(&id, name.as_deref(), status_value.as_deref(), position).await
    }
    SwimLaneCommands::Delete { id } => client.delete_swim_lane(&id).await,
},
```

**Verification**: `just check-rs-cli`

---

## Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes
- [ ] `just clippy-backend` passes
- [ ] `just test-backend` passes
- [ ] `just check-rs-cli` passes

### Files Created (8)
- `backend/pm-server/src/api/swim_lanes/mod.rs`
- `backend/pm-server/src/api/swim_lanes/swim_lane_dto.rs`
- `backend/pm-server/src/api/swim_lanes/swim_lane_response.rs`
- `backend/pm-server/src/api/swim_lanes/swim_lane_list_response.rs`
- `backend/pm-server/src/api/swim_lanes/create_swim_lane_request.rs`
- `backend/pm-server/src/api/swim_lanes/update_swim_lane_request.rs`
- `backend/pm-server/src/api/swim_lanes/swim_lanes.rs`
- `backend/crates/pm-cli/src/swim_lane_commands.rs`

### Files Modified (6)
- `backend/pm-server/src/api/mod.rs` — add `swim_lanes` module
- `backend/pm-server/src/lib.rs` — re-export swim lane types/handlers
- `backend/pm-server/src/routes.rs` — register 5 routes
- `backend/crates/pm-cli/src/client/client.rs` — add 5 client methods
- `backend/crates/pm-cli/src/commands.rs` — add SwimLane variant
- `backend/crates/pm-cli/src/main.rs` — add `mod swim_lane_commands`, wire commands

---

## Next Session

**Session 121.3.2.5** adds Time Entry CRUD (REST + CLI).
