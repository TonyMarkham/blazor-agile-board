# Session 121.3.2.6: Bulk Sync Endpoints

**Parent Plan**: [121.3.2-Session-Plan.md](121.3.2-Session-Plan.md)
**Target**: ~30k tokens
**Prerequisites**:
- `just check-backend && just test-backend && just check-rs-cli` all pass
- **Sessions 121.3.2.1–5 complete** — this session reuses DTOs from those entity modules

---

## Scope

This session adds two bulk sync endpoints (`GET /api/v1/sync/export` and `POST /api/v1/sync/import`) that export/import ALL entity types in a single HTTP call each. This unblocks Session 121.4 (CLI sync commands).

**Why this is last**: The entity CRUD sessions (121.3.2.1–5) each create their own DTO (`SprintDto`, `DependencyDto`, `SwimLaneDto`, `TimeEntryDto`). This session imports those existing DTOs into `ExportData` — no duplicate `sync_dto.rs` needed.

1. **Repository Gaps** - Add `find_all()` to 6 repositories (Sprint, SwimLane, WorkItem, Comment, Dependency, TimeEntry) for bulk export
2. **Deserialize on DTOs** - Add `Deserialize` derive to all 7 entity DTOs (for import)
3. **ExportData Struct** - Schema with all 7 entity arrays + metadata
4. **Sync Handlers** - Export (gather all entities) and Import (upsert in FK order)
5. **Route Registration** - Wire into router
6. **CLI Client Methods** - `sync_export()` and `sync_import()`

---

## Implementation Order

### Step 1: Add `find_all()` to 6 Repositories

The export handler needs to fetch ALL entities in bulk (not per-project) to avoid N+1 queries. `ProjectRepository` already has `find_all()`. Add it to the other 6:

**1a. SprintRepository** — `backend/crates/pm-db/src/repositories/sprint_repository.rs`

Copy pattern from `find_by_project()`, remove the `WHERE project_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<Sprint>> {
    // SELECT all sprint columns FROM pm_sprints WHERE deleted_at IS NULL
    // Same row mapping as find_by_project()
}
```

**1b. SwimLaneRepository** — `backend/crates/pm-db/src/repositories/swim_lane_repository.rs`

Copy pattern from `find_by_project()`, remove the `WHERE project_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<SwimLane>> {
    // SELECT all swim lane columns FROM pm_swim_lanes WHERE deleted_at IS NULL
    // Same row mapping as find_by_project()
}
```

**1c. WorkItemRepository** — `backend/crates/pm-db/src/repositories/work_item_repository.rs`

Copy pattern from `find_by_project()`, remove the `WHERE project_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<WorkItem>> {
    // SELECT all work item columns FROM pm_work_items WHERE deleted_at IS NULL
    // Same row mapping as find_by_project()
}
```

**1d. CommentRepository** — `backend/crates/pm-db/src/repositories/comment_repository.rs`

Copy pattern from `find_by_work_item()`, remove the `WHERE work_item_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<Comment>> {
    // SELECT all comment columns FROM pm_comments WHERE deleted_at IS NULL
    // Same row mapping as find_by_work_item()
}
```

**1e. DependencyRepository** — `backend/crates/pm-db/src/repositories/dependency_repository.rs`

Note: `detect_cycle()` was already added to this file in 121.3.2.3. This step only adds `find_all()`.

Copy pattern from `find_blocking()` (line 112), remove the `WHERE blocked_item_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<Dependency>> {
    // SELECT all dependency columns FROM pm_dependencies WHERE deleted_at IS NULL
    // Same row mapping as find_blocking()
}
```

**1f. TimeEntryRepository** — `backend/crates/pm-db/src/repositories/time_entry_repository.rs`

Copy pattern from `find_by_work_item()` (line 119), remove the `WHERE work_item_id = ?` filter:

```rust
pub async fn find_all(&self) -> DbErrorResult<Vec<TimeEntry>> {
    // SELECT all time entry columns FROM pm_time_entries WHERE deleted_at IS NULL
    // Same row mapping as find_by_work_item()
}
```

**Verification**: `just check-rs-db`

---

### Step 3: Add Deserialize to All Entity DTOs

The import handler needs to deserialize incoming DTOs. Add `Deserialize` derive to all 7 entity DTOs:

| File | Change |
|------|--------|
| `backend/pm-server/src/api/projects/project_dto.rs` | `#[derive(Debug, Serialize)]` → `#[derive(Debug, Serialize, Deserialize)]` |
| `backend/pm-server/src/api/work_items/work_item_dto.rs` | Same |
| `backend/pm-server/src/api/comments/comment_dto.rs` | Same |
| `backend/pm-server/src/api/sprints/sprint_dto.rs` | Same (created in 121.3.2.2) |
| `backend/pm-server/src/api/dependencies/dependency_dto.rs` | Same (created in 121.3.2.3) |
| `backend/pm-server/src/api/swim_lanes/swim_lane_dto.rs` | Same (created in 121.3.2.4) |
| `backend/pm-server/src/api/time_entries/time_entry_dto.rs` | Same (created in 121.3.2.5) |

For each file, ensure `use serde::{Serialize, Deserialize};` (or add `Deserialize` to the existing serde import).

**Verification**: `just check-rs-server`

---

### Step 4: Create ExportData Struct

**Create**: `backend/pm-server/src/api/sync/export_data.rs`

Imports DTOs from existing entity modules — no duplication:

```rust
use crate::{
    ProjectDto, WorkItemDto, CommentDto,
    SprintDto, DependencyDto, SwimLaneDto, TimeEntryDto,
};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct ExportData {
    pub schema_version: u32,
    pub exported_at: String,
    pub exported_by: String,
    pub projects: Vec<ProjectDto>,
    pub work_items: Vec<WorkItemDto>,
    pub sprints: Vec<SprintDto>,
    pub comments: Vec<CommentDto>,
    pub swim_lanes: Vec<SwimLaneDto>,
    pub dependencies: Vec<DependencyDto>,
    pub time_entries: Vec<TimeEntryDto>,
}
```

---

### Step 5: Create Sync Handlers

**Create**: `backend/pm-server/src/api/sync/sync_handlers.rs`

**Export handler** (`GET /api/v1/sync/export`):

Bulk-fetch all entities (7 queries total, no N+1):

```rust
pub async fn sync_export(
    State(state): State<AppState>,
) -> ApiResult<Json<ExportData>> {
    let pool = &state.pool;

    // 7 bulk queries — one per entity type
    let projects = ProjectRepository::new(pool.clone()).find_all().await?;
    let sprints = SprintRepository::new(pool.clone()).find_all().await?;
    let swim_lanes = SwimLaneRepository::new(pool.clone()).find_all().await?;
    let work_items = WorkItemRepository::new(pool.clone()).find_all().await?;
    let comments = CommentRepository::new(pool.clone()).find_all().await?;
    let dependencies = DependencyRepository::new(pool.clone()).find_all().await?;
    let time_entries = TimeEntryRepository::new(pool.clone()).find_all().await?;

    // Convert to DTOs using existing From impls
    let data = ExportData {
        schema_version: 1,
        exported_at: Utc::now().to_rfc3339(),
        exported_by: "pm-server".to_string(),
        projects: projects.into_iter().map(ProjectDto::from).collect(),
        sprints: sprints.into_iter().map(SprintDto::from).collect(),
        swim_lanes: swim_lanes.into_iter().map(SwimLaneDto::from).collect(),
        work_items: work_items.into_iter().map(WorkItemDto::from).collect(),
        comments: comments.into_iter().map(CommentDto::from).collect(),
        dependencies: dependencies.into_iter().map(DependencyDto::from).collect(),
        time_entries: time_entries.into_iter().map(TimeEntryDto::from).collect(),
    };

    Ok(Json(data))
}
```

**Import handler** (`POST /api/v1/sync/import`):
- Accept `Json<ExportData>`
- Validate `schema_version == 1` — return `ApiError::Validation` if unsupported
- Within a transaction, upsert in FK order: projects → sprints → swim_lanes → work_items → comments → dependencies → time_entries
- For each entity: look up by ID, insert if new, update if import is newer, skip if local is newer
- **Conflict resolution strategy**: Compare `updated_at` timestamps. For entities without `updated_at` (Dependencies — only have `created_at`), always overwrite if the entity exists (dependencies are immutable link records, so a re-import is equivalent). If timestamps are equal, skip (local wins on tie).

```rust
pub async fn sync_import(
    State(state): State<AppState>,
    Json(data): Json<ExportData>,
) -> ApiResult<Json<ImportResult>> {
    if data.schema_version != 1 {
        return Err(ApiError::Validation {
            message: format!("Unsupported schema version: {}", data.schema_version),
        });
    }

    let pool = &state.pool;
    let mut result = ImportResult::default();

    // Upsert helper pattern (applied to each entity type):
    // match repo.find_by_id(dto.id).await? {
    //     None => { repo.create(&entity).await?; result.X.created += 1; }
    //     Some(existing) if entity.updated_at > existing.updated_at => {
    //         repo.update(&entity).await?; result.X.updated += 1;
    //     }
    //     Some(_) => { result.X.skipped += 1; }  // local is newer
    // }

    // FK order: projects → sprints → swim_lanes → work_items
    //         → comments → dependencies → time_entries
    // Each block converts DTOs back to core models, then upserts

    Ok(Json(result))
}
```

Also define `ImportResult` and per-entity counts:
```rust
#[derive(Debug, Default, Serialize)]
pub struct ImportResult {
    pub projects: EntityImportCounts,
    pub sprints: EntityImportCounts,
    pub swim_lanes: EntityImportCounts,
    pub work_items: EntityImportCounts,
    pub comments: EntityImportCounts,
    pub dependencies: EntityImportCounts,
    pub time_entries: EntityImportCounts,
}

#[derive(Debug, Default, Serialize)]
pub struct EntityImportCounts {
    pub created: usize,
    pub updated: usize,
    pub skipped: usize,
}
```

**DTO → Model conversion (TryFrom impls)**:

The import path requires **7 `TryFrom` implementations** converting DTOs (String IDs, i64 timestamps, String enums) back to core models (Uuid, DateTime, typed enums). This is ~200-300 lines of conversion code. All impls go in `sync_handlers.rs` since they're import-specific.

Each impl needs: UUID parsing, timestamp conversion, and enum parsing. Example:

```rust
impl TryFrom<ProjectDto> for Project {
    type Error = ApiError;

    fn try_from(dto: ProjectDto) -> Result<Self, Self::Error> {
        Ok(Project {
            id: Uuid::parse_str(&dto.id).map_err(|_| ApiError::Validation {
                message: format!("Invalid project UUID: {}", dto.id),
            })?,
            title: dto.title,
            description: dto.description,
            key: dto.key,
            status: ProjectStatus::from_str(&dto.status).map_err(|_| ApiError::Validation {
                message: format!("Invalid project status: {}", dto.status),
            })?,
            version: dto.version,
            created_at: DateTime::from_timestamp(dto.created_at, 0)
                .ok_or_else(|| ApiError::Validation {
                    message: format!("Invalid timestamp: {}", dto.created_at),
                })?,
            updated_at: DateTime::from_timestamp(dto.updated_at, 0)
                .ok_or_else(|| ApiError::Validation {
                    message: format!("Invalid timestamp: {}", dto.updated_at),
                })?,
            created_by: Uuid::parse_str(&dto.created_by).map_err(|_| ApiError::Validation {
                message: format!("Invalid UUID: {}", dto.created_by),
            })?,
            updated_by: Uuid::parse_str(&dto.updated_by).map_err(|_| ApiError::Validation {
                message: format!("Invalid UUID: {}", dto.updated_by),
            })?,
            deleted_at: None,
            next_work_item_number: dto.next_work_item_number,
        })
    }
}
```

The remaining 6 impls follow the same pattern — parse UUIDs, convert timestamps, parse enums (`SprintStatus::from_str`, `DependencyType::from_str`, `WorkItemType::from_str`, etc.). If any `from_str` methods don't exist on the enums, add them in `pm-core`.

---

### Step 6: Create Module File

**Create**: `backend/pm-server/src/api/sync/mod.rs`

```rust
pub(crate) mod export_data;
#[allow(clippy::module_inception)]
pub(crate) mod sync_handlers;
```

Note: No `sync_dto.rs` — DTOs come from entity modules.

---

### Step 7: Register Routes + Re-exports

**File**: `backend/pm-server/src/api/mod.rs`

Add: `pub(crate) mod sync;`

**File**: `backend/pm-server/src/lib.rs`

Add re-exports for sync types and handlers:
```rust
sync::{
    export_data::ExportData,
    sync_handlers::{sync_export, sync_import, ImportResult},
},
```

**File**: `backend/pm-server/src/routes.rs`

Add to `build_router()`:
```rust
// REST API v1 - Sync
.route("/api/v1/sync/export", get(sync_export))
.route("/api/v1/sync/import", post(sync_import))
```

Update imports at top of `routes.rs` to include `sync_export, sync_import`.

**Verification**: `just check-rs-server`

---

### Step 8: Add CLI Client Methods

**File**: `backend/crates/pm-cli/src/client/client.rs`

Add a new section after the last entity operations:

```rust
// =========================================================================
// Sync Operations
// =========================================================================

/// Export all data from the server
pub async fn sync_export(&self) -> CliClientResult<Value> {
    let req = self.request(Method::GET, "/api/v1/sync/export");
    self.execute(req).await
}

/// Import data to the server
pub async fn sync_import(&self, data: &Value) -> CliClientResult<Value> {
    let req = self
        .request(Method::POST, "/api/v1/sync/import")
        .json(data);
    self.execute(req).await
}
```

**Verification**: `just check-rs-cli`

---

## Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes
- [ ] `just clippy-backend` passes
- [ ] `just test-backend` passes
- [ ] `just check-rs-cli` passes

### Files Created (3)
- `backend/pm-server/src/api/sync/mod.rs`
- `backend/pm-server/src/api/sync/export_data.rs`
- `backend/pm-server/src/api/sync/sync_handlers.rs`

### Files Modified (17)
- `backend/crates/pm-db/src/repositories/sprint_repository.rs` — add `find_all()`
- `backend/crates/pm-db/src/repositories/swim_lane_repository.rs` — add `find_all()`
- `backend/crates/pm-db/src/repositories/work_item_repository.rs` — add `find_all()`
- `backend/crates/pm-db/src/repositories/comment_repository.rs` — add `find_all()`
- `backend/crates/pm-db/src/repositories/dependency_repository.rs` — add `find_all()`
- `backend/crates/pm-db/src/repositories/time_entry_repository.rs` — add `find_all()`
- `backend/pm-server/src/api/mod.rs` — add `sync` module
- `backend/pm-server/src/api/projects/project_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/comments/comment_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/work_items/work_item_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/sprints/sprint_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/dependencies/dependency_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/swim_lanes/swim_lane_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/api/time_entries/time_entry_dto.rs` — add `Deserialize` derive
- `backend/pm-server/src/lib.rs` — re-export sync types/handlers
- `backend/pm-server/src/routes.rs` — register 2 routes
- `backend/crates/pm-cli/src/client/client.rs` — add 2 client methods

---

## Next Session

After all 121.3.2.x sub-sessions are complete, **Session 121.4** implements the CLI sync commands (`pm sync export`, `pm sync import`) using the bulk sync endpoints created here and the individual CRUD endpoints created in 121.3.2.1–5.
