# Session 40.5: Build Pipeline & Testing

**Parent Plan**: `40-Session-Plan-Production.md`
**Prerequisite**: Session 40.4 completed
**Target**: ~40k tokens

---

## Scope

This session completes the desktop application with production-ready infrastructure:

1. **Build Scripts** - Cross-platform build automation
2. **CI/CD Pipeline** - GitHub Actions for all platforms
3. **Unit Tests** - Test server management components
4. **Integration Tests** - End-to-end server lifecycle testing
5. **Manual Test Checklist** - QA verification guide

---

## Learning Objectives

After completing this session, you will understand:
- Cross-platform build scripting
- Tauri sidecar binary naming conventions
- GitHub Actions matrix builds
- Testing embedded server applications
- Release packaging and distribution

---

## Prerequisites Check

Before starting, verify Session 40.4 is complete:

```bash
cd desktop/src-tauri && cargo build
dotnet build frontend/ProjectManagement.Wasm
```

---

## Implementation Order

### Step 1: Create Build Script (Unix)

**Create**: `desktop/scripts/build.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DESKTOP_DIR="$PROJECT_ROOT/desktop"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

# Parse arguments
BUILD_TYPE="${1:-debug}"
TARGET="${2:-$(rustc -vV | grep host | cut -d' ' -f2)}"

echo ""
echo "========================================"
echo "  Project Manager Desktop Build"
echo "========================================"
echo ""
log_info "Build type: $BUILD_TYPE"
log_info "Target: $TARGET"
log_info "Project root: $PROJECT_ROOT"
echo ""

# Determine cargo profile
if [[ "$BUILD_TYPE" == "release" ]]; then
    CARGO_PROFILE="--release"
    CARGO_OUT_DIR="release"
    DOTNET_CONFIG="Release"
else
    CARGO_PROFILE=""
    CARGO_OUT_DIR="debug"
    DOTNET_CONFIG="Debug"
fi

# Determine binary extension
BIN_EXT=""
if [[ "$TARGET" == *"windows"* ]]; then
    BIN_EXT=".exe"
fi

# === Step 1: Build pm-server ===
log_step "1/4 Building pm-server..."
cd "$PROJECT_ROOT/backend"
cargo build $CARGO_PROFILE --bin pm-server --target "$TARGET"

# === Step 2: Copy pm-server to Tauri binaries ===
log_step "2/4 Copying pm-server sidecar..."
SIDECAR_DIR="$DESKTOP_DIR/src-tauri/binaries"
mkdir -p "$SIDECAR_DIR"

SRC_BIN="$PROJECT_ROOT/backend/target/$TARGET/$CARGO_OUT_DIR/pm-server$BIN_EXT"
DST_BIN="$SIDECAR_DIR/pm-server-$TARGET$BIN_EXT"

if [[ ! -f "$SRC_BIN" ]]; then
    log_error "pm-server binary not found at $SRC_BIN"
    exit 1
fi

cp "$SRC_BIN" "$DST_BIN"
chmod +x "$DST_BIN"
log_info "Copied to $DST_BIN"

# === Step 3: Build Blazor WASM frontend ===
log_step "3/4 Building Blazor WASM frontend..."
cd "$PROJECT_ROOT/frontend"
dotnet publish ProjectManagement.Wasm/ProjectManagement.Wasm.csproj \
    -c "$DOTNET_CONFIG" \
    -o "$DESKTOP_DIR/frontend" \
    --nologo \
    -v quiet

log_info "Frontend published to $DESKTOP_DIR/frontend"

# === Step 4: Build Tauri app ===
log_step "4/4 Building Tauri application..."
cd "$DESKTOP_DIR/src-tauri"

if [[ "$BUILD_TYPE" == "release" ]]; then
    cargo tauri build --target "$TARGET"
else
    cargo tauri build --debug --target "$TARGET"
fi

# === Output summary ===
echo ""
echo "========================================"
echo "  Build Complete!"
echo "========================================"
echo ""

BUNDLE_DIR="$DESKTOP_DIR/src-tauri/target/$TARGET/$CARGO_OUT_DIR/bundle"
log_info "Output directory: $BUNDLE_DIR"

if [[ -d "$BUNDLE_DIR" ]]; then
    log_info "Artifacts:"
    find "$BUNDLE_DIR" -type f \( \
        -name "*.dmg" -o \
        -name "*.app" -o \
        -name "*.exe" -o \
        -name "*.msi" -o \
        -name "*.deb" -o \
        -name "*.rpm" -o \
        -name "*.AppImage" \
    \) -exec ls -lh {} \; 2>/dev/null || true
fi
```

---

### Step 2: Create Development Script

**Create**: `desktop/scripts/dev.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

echo "=== Project Manager Development Mode ==="
echo ""

# Build pm-server in debug mode
echo "[1/3] Building pm-server..."
cd "$PROJECT_ROOT/backend"
cargo build --bin pm-server

# Copy to Tauri binaries
TARGET=$(rustc -vV | grep host | cut -d' ' -f2)
echo "[2/3] Copying sidecar binary..."
mkdir -p "$PROJECT_ROOT/desktop/src-tauri/binaries"
cp "target/debug/pm-server" "$PROJECT_ROOT/desktop/src-tauri/binaries/pm-server-$TARGET"
chmod +x "$PROJECT_ROOT/desktop/src-tauri/binaries/pm-server-$TARGET"

# Build frontend
echo "[3/3] Building frontend..."
cd "$PROJECT_ROOT/frontend"
dotnet publish ProjectManagement.Wasm -c Debug -o "$PROJECT_ROOT/desktop/frontend" --nologo -v quiet

# Run Tauri dev
echo ""
echo "Starting Tauri development mode..."
cd "$PROJECT_ROOT/desktop/src-tauri"
cargo tauri dev
```

Make scripts executable:
```bash
chmod +x desktop/scripts/build.sh
chmod +x desktop/scripts/dev.sh
```

---

### Step 3: Create GitHub Actions CI/CD

**Create**: `.github/workflows/desktop-build.yml`

```yaml
name: Desktop App Build

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
            name: macOS-ARM64
          - platform: macos-latest
            target: x86_64-apple-darwin
            name: macOS-x64
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            name: Linux-x64
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows-x64

    runs-on: ${{ matrix.platform }}
    name: Build (${{ matrix.name }})

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            backend -> target
            desktop/src-tauri -> target

      - name: Build pm-server
        run: cargo build --release --bin pm-server --target ${{ matrix.target }}
        working-directory: backend

      - name: Copy sidecar binary
        shell: bash
        run: |
          mkdir -p desktop/src-tauri/binaries
          if [[ "${{ matrix.target }}" == *"windows"* ]]; then
            cp "backend/target/${{ matrix.target }}/release/pm-server.exe" \
               "desktop/src-tauri/binaries/pm-server-${{ matrix.target }}.exe"
          else
            cp "backend/target/${{ matrix.target }}/release/pm-server" \
               "desktop/src-tauri/binaries/pm-server-${{ matrix.target }}"
            chmod +x "desktop/src-tauri/binaries/pm-server-${{ matrix.target }}"
          fi

      - name: Build frontend
        run: |
          dotnet publish ProjectManagement.Wasm/ProjectManagement.Wasm.csproj \
            -c Release \
            -o ../desktop/frontend
        working-directory: frontend

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: desktop/src-tauri
          args: --target ${{ matrix.target }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.name }}
          path: |
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/macos/*.app
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/rpm/*.rpm
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage
          if-no-files-found: ignore

  # Create GitHub Release on tag push
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          files: artifacts/**/*
          generate_release_notes: true
          draft: true
```

---

### Step 4: Create Unit Tests

**Create**: `desktop/src-tauri/src/server/tests.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    mod config_tests {
        use super::*;
        use crate::server::{ServerConfig, CONFIG_VERSION};

        #[test]
        fn default_config_is_valid() {
            let config = ServerConfig::default();
            assert!(config.validate().is_ok());
        }

        #[test]
        fn config_rejects_privileged_port() {
            let mut config = ServerConfig::default();
            config.server.port = 80;
            assert!(config.validate().is_err());
        }

        #[test]
        fn config_rejects_invalid_port_range() {
            let mut config = ServerConfig::default();
            config.server.port_range = (9000, 8000); // Inverted
            assert!(config.validate().is_err());
        }

        #[test]
        fn config_rejects_non_localhost() {
            let mut config = ServerConfig::default();
            config.server.host = "0.0.0.0".to_string();
            assert!(config.validate().is_err());
        }

        #[test]
        fn config_creates_default_on_missing_file() {
            let temp_dir = TempDir::new().unwrap();
            let config = ServerConfig::load_or_create(temp_dir.path()).unwrap();
            assert_eq!(config.version, CONFIG_VERSION);
            assert!(temp_dir.path().join("config.toml").exists());
        }

        #[test]
        fn config_migrates_old_version() {
            let temp_dir = TempDir::new().unwrap();
            let old_config = r#"
                version = 0
                [server]
                port = 8080
            "#;
            std::fs::write(temp_dir.path().join("config.toml"), old_config).unwrap();

            let config = ServerConfig::load_or_create(temp_dir.path()).unwrap();
            assert_eq!(config.version, CONFIG_VERSION);
            assert_eq!(config.server.port, 8080);
            // Resilience settings should be added
            assert!(config.resilience.max_restarts > 0);
        }

        #[test]
        fn config_atomic_write_no_temp_file() {
            let temp_dir = TempDir::new().unwrap();
            let config = ServerConfig::default();
            config.save(temp_dir.path()).unwrap();

            // No .tmp file should remain
            assert!(!temp_dir.path().join("config.toml.tmp").exists());
            assert!(temp_dir.path().join("config.toml").exists());
        }
    }

    mod lock_file_tests {
        use super::*;
        use crate::server::LockFile;

        #[test]
        fn lock_file_prevents_double_acquisition() {
            let temp_dir = TempDir::new().unwrap();

            let lock1 = LockFile::acquire(temp_dir.path(), 8000).unwrap();
            let lock2_result = LockFile::acquire(temp_dir.path(), 8000);

            assert!(matches!(
                lock2_result,
                Err(crate::server::ServerError::AlreadyRunning { .. })
            ));
            drop(lock1);
        }

        #[test]
        fn lock_file_released_on_drop() {
            let temp_dir = TempDir::new().unwrap();

            {
                let _lock = LockFile::acquire(temp_dir.path(), 8000).unwrap();
                assert!(temp_dir.path().join("server.lock").exists());
            }

            // Lock should be released
            assert!(!temp_dir.path().join("server.lock").exists());
        }

        #[test]
        fn stale_lock_is_cleaned_up() {
            let temp_dir = TempDir::new().unwrap();

            // Write fake lock with non-existent PID
            let fake_lock = r#"{"pid": 999999999, "port": 8000, "started_at": "2020-01-01T00:00:00Z"}"#;
            std::fs::write(temp_dir.path().join("server.lock"), fake_lock).unwrap();

            // Should succeed because PID doesn't exist
            let lock = LockFile::acquire(temp_dir.path(), 8000);
            assert!(lock.is_ok());
        }
    }

    mod port_tests {
        use super::*;
        use crate::server::PortManager;

        #[test]
        fn finds_available_port() {
            let port = PortManager::find_available(8000, (8000, 8100)).unwrap();
            assert!(port >= 8000 && port <= 8100);
        }

        #[test]
        fn port_availability_check() {
            // Bind to a port
            let listener = std::net::TcpListener::bind("127.0.0.1:0").unwrap();
            let bound_port = listener.local_addr().unwrap().port();

            // Should not be available
            assert!(!PortManager::is_available(bound_port));

            drop(listener);

            // Should be available now
            assert!(PortManager::is_available(bound_port));
        }

        #[test]
        fn prefers_specified_port() {
            // Find a free port first
            let listener = std::net::TcpListener::bind("127.0.0.1:0").unwrap();
            let free_port = listener.local_addr().unwrap().port();
            drop(listener);

            // Should return the preferred port if available
            let result = PortManager::find_available(free_port, (free_port, free_port + 100));
            assert_eq!(result.unwrap(), free_port);
        }
    }

    mod error_tests {
        use super::*;
        use crate::server::ServerError;

        #[test]
        fn errors_have_recovery_hints() {
            let error = ServerError::PortInUse { port: 8000 };
            assert!(!error.recovery_hint().is_empty());

            let error = ServerError::MaxRestartsExceeded { max: 5 };
            assert!(!error.recovery_hint().is_empty());

            let error = ServerError::AlreadyRunning {
                path: "/tmp/test.lock".into(),
            };
            assert!(!error.recovery_hint().is_empty());
        }

        #[test]
        fn transient_errors_identified() {
            assert!(ServerError::HealthCheckFailed {
                message: "timeout".into()
            }
            .is_transient());

            assert!(!ServerError::BinaryNotFound {
                path: "/bin/pm-server".into()
            }
            .is_transient());

            assert!(!ServerError::AlreadyRunning {
                path: "/tmp/test.lock".into()
            }
            .is_transient());
        }
    }
}
```

Update `src/server/mod.rs` to include tests:

```rust
#[cfg(test)]
mod tests;
```

---

### Step 5: Create Integration Tests

**Create**: `desktop/src-tauri/tests/integration_tests.rs`

```rust
//! Integration tests for desktop application.
//!
//! These tests require pm-server to be built and available.

use std::path::PathBuf;
use std::process::{Child, Command, Stdio};
use std::time::Duration;
use tokio::time::timeout;

struct TestServer {
    process: Child,
    port: u16,
    data_dir: tempfile::TempDir,
}

impl TestServer {
    async fn start() -> Result<Self, Box<dyn std::error::Error>> {
        let data_dir = tempfile::TempDir::new()?;
        let port = find_free_port();

        let bin_path = find_pm_server_binary()?;

        let process = Command::new(&bin_path)
            .env("PM_CONFIG_DIR", data_dir.path())
            .env("PM_SERVER_PORT", port.to_string())
            .env("PM_SERVER_HOST", "127.0.0.1")
            .env("PM_AUTH_ENABLED", "false")
            .env("PM_LOG_LEVEL", "debug")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let server = Self {
            process,
            port,
            data_dir,
        };

        server.wait_ready(Duration::from_secs(10)).await?;

        Ok(server)
    }

    async fn wait_ready(&self, timeout_duration: Duration) -> Result<(), Box<dyn std::error::Error>> {
        let url = format!("http://127.0.0.1:{}/ready", self.port);
        let client = reqwest::Client::new();

        let result = timeout(timeout_duration, async {
            loop {
                if let Ok(resp) = client.get(&url).send().await {
                    if resp.status().is_success() {
                        return Ok(());
                    }
                }
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        })
        .await;

        result.map_err(|_| "Server startup timeout".into()).and_then(|r| r)
    }

    fn health_url(&self) -> String {
        format!("http://127.0.0.1:{}/health", self.port)
    }

    fn ready_url(&self) -> String {
        format!("http://127.0.0.1:{}/ready", self.port)
    }

    fn websocket_url(&self) -> String {
        format!("ws://127.0.0.1:{}/ws", self.port)
    }
}

impl Drop for TestServer {
    fn drop(&mut self) {
        self.process.kill().ok();
    }
}

fn find_free_port() -> u16 {
    std::net::TcpListener::bind("127.0.0.1:0")
        .unwrap()
        .local_addr()
        .unwrap()
        .port()
}

fn find_pm_server_binary() -> Result<PathBuf, Box<dyn std::error::Error>> {
    let candidates = [
        "../../backend/target/debug/pm-server",
        "../../backend/target/release/pm-server",
        "../backend/target/debug/pm-server",
        "../backend/target/release/pm-server",
    ];

    for candidate in candidates {
        let path = PathBuf::from(candidate);
        if path.exists() {
            return Ok(path.canonicalize()?);
        }
    }

    Err("pm-server binary not found. Run 'cargo build -p pm-server' first.".into())
}

#[tokio::test]
async fn test_server_starts_and_responds() {
    let server = TestServer::start().await.expect("Failed to start server");

    let client = reqwest::Client::new();
    let resp = client.get(&server.health_url()).send().await.unwrap();

    assert!(resp.status().is_success());

    let body: serde_json::Value = resp.json().await.unwrap();
    assert_eq!(body["status"], "ok");
}

#[tokio::test]
async fn test_ready_endpoint_includes_database() {
    let server = TestServer::start().await.expect("Failed to start server");

    let client = reqwest::Client::new();
    let resp = client.get(&server.ready_url()).send().await.unwrap();

    assert!(resp.status().is_success());

    let body: serde_json::Value = resp.json().await.unwrap();
    assert_eq!(body["status"], "healthy");
    assert!(body["database"]["status"] == "healthy");
}

#[tokio::test]
async fn test_database_file_created() {
    let server = TestServer::start().await.expect("Failed to start server");

    let db_path = server.data_dir.path().join("data.db");
    assert!(db_path.exists(), "Database file should exist");
}

#[tokio::test]
async fn test_config_file_created() {
    let server = TestServer::start().await.expect("Failed to start server");

    let config_path = server.data_dir.path().join("config.toml");
    assert!(config_path.exists(), "Config file should be created");

    let content = std::fs::read_to_string(&config_path).unwrap();
    assert!(content.contains("[server]"));
}

#[tokio::test]
async fn test_graceful_shutdown() {
    let mut server = TestServer::start().await.expect("Failed to start server");

    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        let pid = Pid::from_raw(server.process.id() as i32);
        kill(pid, Signal::SIGTERM).ok();
    }

    #[cfg(windows)]
    {
        server.process.kill().ok();
    }

    let status = tokio::time::timeout(
        Duration::from_secs(5),
        tokio::task::spawn_blocking(move || server.process.wait()),
    )
    .await;

    assert!(status.is_ok(), "Server should shut down within timeout");
}
```

---

### Step 6: Create Manual Test Checklist

**Create**: `desktop/docs/TEST_CHECKLIST.md`

```markdown
# Desktop Application Test Checklist

Use this checklist for QA verification before releases.

## Pre-Release Testing

### Startup Tests

- [ ] **Fresh Install**: App starts on clean system (no prior data)
- [ ] **Existing Data**: App starts with existing database
- [ ] **Config Migration**: App migrates old config format correctly
- [ ] **Loading Screen**: Shows progress steps during startup
- [ ] **Startup Timeout**: Shows error after 30s if server fails

### Server Lifecycle Tests

- [ ] **Auto-Start**: Server starts automatically on app launch
- [ ] **Health Monitoring**: Tray icon reflects server status
- [ ] **Graceful Shutdown**: Server stops cleanly when app closes
- [ ] **Crash Recovery**: Server restarts after unexpected crash
- [ ] **Max Restarts**: Shows error after 5 consecutive crashes

### Single Instance Tests

- [ ] **Lock File**: Second instance shows error and focuses first window
- [ ] **Stale Lock**: App starts if previous instance crashed (stale lock)
- [ ] **Lock Cleanup**: Lock file removed on clean exit

### Port Management Tests

- [ ] **Default Port**: Uses port 8000 when available
- [ ] **Port Conflict**: Finds alternative port if 8000 in use
- [ ] **Port Range**: Fails gracefully if all ports (8000-8100) occupied

### UI Tests

- [ ] **Window Opens**: Main window appears after startup
- [ ] **Tray Icon**: System tray icon visible with correct status
- [ ] **Tray Menu**: Menu shows status, restart, logs, quit options
- [ ] **Hide to Tray**: Window hides (not closes) on X button
- [ ] **Show from Tray**: Click tray icon shows window
- [ ] **WebSocket**: Frontend connects to backend successfully

### Data Persistence Tests

- [ ] **Create Project**: New project persists after restart
- [ ] **Create Work Item**: Work items persist after restart
- [ ] **Database Location**: Data stored in correct platform directory
  - macOS: `~/Library/Application Support/com.projectmanager.app/`
  - Windows: `%APPDATA%/com.projectmanager.app/`
  - Linux: `~/.local/share/com.projectmanager.app/`
- [ ] **Database Integrity**: No corruption after force quit

### Error Handling Tests

- [ ] **Server Error**: Shows user-friendly error message
- [ ] **Recovery Hint**: Error includes actionable guidance
- [ ] **Export Diagnostics**: Can export logs via tray menu
- [ ] **Retry Button**: Can retry startup after failure

## Cross-Platform Tests

### macOS
- [ ] App bundle (.app) launches correctly
- [ ] Tray icon appears in menu bar
- [ ] Data stored in ~/Library/Application Support/
- [ ] DMG installer mounts and app copies correctly
- [ ] App runs without code signing warning (for testing)
- [ ] Universal binary works on Intel and ARM

### Windows
- [ ] EXE launches correctly
- [ ] Tray icon appears in system tray (notification area)
- [ ] Data stored in %APPDATA%
- [ ] NSIS installer runs without admin prompt (per-user install)
- [ ] Start menu shortcut created
- [ ] Uninstaller removes all files

### Linux
- [ ] AppImage launches correctly
- [ ] Tray icon appears (if desktop supports tray)
- [ ] Data stored in ~/.local/share/
- [ ] DEB package installs via `dpkg -i`
- [ ] RPM package installs via `rpm -i`
- [ ] Desktop file created for application menu

## Performance Tests

- [ ] **Startup Time**: App ready in < 10 seconds
- [ ] **Memory Usage**: < 500MB RAM after startup
- [ ] **CPU Idle**: < 5% CPU when idle
- [ ] **Large Dataset**: Works with 1000+ work items

## Security Tests

- [ ] **Local Only**: Server only binds to 127.0.0.1
- [ ] **No External Calls**: App works completely offline
- [ ] **Config Sanitization**: Diagnostics don't leak secrets
- [ ] **File Permissions**: Lock file has restricted permissions (Unix)

## Upgrade Tests

- [ ] **In-Place Upgrade**: Install over previous version preserves data
- [ ] **Config Migration**: Old config upgraded to new format
- [ ] **Database Migration**: Schema migrations run correctly

---

## Test Results Template

| Test Category | Pass | Fail | Notes |
|--------------|------|------|-------|
| Startup | | | |
| Server Lifecycle | | | |
| Single Instance | | | |
| Port Management | | | |
| UI | | | |
| Data Persistence | | | |
| Error Handling | | | |
| macOS | | | |
| Windows | | | |
| Linux | | | |
| Performance | | | |
| Security | | | |
| Upgrade | | | |

**Tester**: ________________
**Date**: ________________
**Version**: ________________
**Platform**: ________________
```

---

## Session 40.5 Completion Checklist

After completing all steps:

- [ ] Build scripts work: `./desktop/scripts/build.sh debug`
- [ ] Dev script works: `./desktop/scripts/dev.sh`
- [ ] Unit tests pass: `cargo test -p project-manager`
- [ ] Integration tests pass (with pm-server built)
- [ ] Files created:
  - [ ] `desktop/scripts/build.sh`
  - [ ] `desktop/scripts/dev.sh`
  - [ ] `.github/workflows/desktop-build.yml`
  - [ ] `desktop/src-tauri/src/server/tests.rs`
  - [ ] `desktop/src-tauri/tests/integration_tests.rs`
  - [ ] `desktop/docs/TEST_CHECKLIST.md`

### Files Created (6)

| File | Purpose | Lines |
|------|---------|-------|
| `scripts/build.sh` | Production build script | ~100 |
| `scripts/dev.sh` | Development build script | ~35 |
| `desktop-build.yml` | CI/CD pipeline | ~120 |
| `src/server/tests.rs` | Unit tests | ~150 |
| `tests/integration_tests.rs` | Integration tests | ~130 |
| `docs/TEST_CHECKLIST.md` | QA checklist | ~150 |

---

## Final Verification

After completing all Session 40 sub-sessions:

```bash
# 1. Run all unit tests
cd desktop/src-tauri
cargo test

# 2. Run integration tests (requires pm-server)
cd ../../backend && cargo build -p pm-server
cd ../desktop/src-tauri
cargo test --test integration_tests

# 3. Build debug version
cd ..
./scripts/dev.sh

# 4. Build release version
./scripts/build.sh release

# 5. Check artifacts
ls src-tauri/target/*/release/bundle/
```

---

## Key Concepts Covered

1. **Cross-Platform Build Scripts**: Handle differences between Unix and Windows

2. **CI/CD Matrix Builds**: Build for all platforms in parallel

3. **Sidecar Binary Naming**: Tauri requires `{name}-{target-triple}` format

4. **Unit vs Integration Tests**:
   - Unit tests: Fast, isolated, no external dependencies
   - Integration tests: Require actual server binary

5. **QA Checklists**: Essential for catching platform-specific issues

---

## Session 40 Complete

Congratulations! You have built a production-grade desktop application with:

- Embedded server with health monitoring
- Crash recovery with exponential backoff
- System tray integration
- Cross-platform build pipeline
- Comprehensive testing

The application is ready for internal testing and eventual release.
