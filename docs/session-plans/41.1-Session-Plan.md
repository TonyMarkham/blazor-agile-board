# Session 41.1: Backend Database & Models

**Parent Plan**: `41-Session-Plan.md`
**Target**: ~30-40k tokens
**Prerequisites**: `cargo check --workspace` passes

---

## Scope

This session creates the database schema and Rust models for the Project entity:

1. **Database Migration** - Create `pm_projects` table, migrate existing data, update FKs
2. **Rust Model** - Project struct + ProjectStatus enum
3. **Repository** - CRUD operations for projects

---

## Implementation Order

### Step 1: Create Database Migration

**Create**: `backend/crates/pm-db/migrations/YYYYMMDDHHMMSS_create_projects_table.sql`

Use timestamp format: `20260121000001_create_projects_table.sql`

```sql
-- ============================================================
-- Migration: Create pm_projects table and migrate data
-- ============================================================

-- Step 1: Create pm_projects table
CREATE TABLE pm_projects (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    key TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('active', 'archived')),
    version INTEGER NOT NULL DEFAULT 1,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    created_by TEXT NOT NULL,
    updated_by TEXT NOT NULL,
    deleted_at INTEGER,
    UNIQUE(key)
);

-- Step 2: Migrate existing projects from pm_work_items
-- Generate key from title (uppercase, no spaces, max 10 chars) + first 4 chars of ID for uniqueness
INSERT INTO pm_projects (id, title, description, key, status, version, created_at, updated_at, created_by, updated_by, deleted_at)
SELECT
    id,
    title,
    description,
    UPPER(SUBSTR(REPLACE(REPLACE(title, ' ', ''), '-', ''), 1, 10)) || '_' || UPPER(SUBSTR(id, 1, 4)),
    'active',
    COALESCE(version, 1),
    created_at,
    updated_at,
    created_by,
    updated_by,
    deleted_at
FROM pm_work_items
WHERE item_type = 'project';

-- Step 3: Recreate pm_sprints with FK to pm_projects
CREATE TABLE pm_sprints_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    name TEXT NOT NULL,
    goal TEXT,
    start_date INTEGER,
    end_date INTEGER,
    status TEXT NOT NULL DEFAULT 'planning' CHECK(status IN ('planning', 'active', 'completed', 'cancelled')),
    velocity INTEGER,
    version INTEGER NOT NULL DEFAULT 1,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    created_by TEXT NOT NULL,
    updated_by TEXT NOT NULL,
    deleted_at INTEGER,
    FOREIGN KEY (project_id) REFERENCES pm_projects(id) ON DELETE CASCADE
);
INSERT INTO pm_sprints_new SELECT * FROM pm_sprints;
DROP TABLE pm_sprints;
ALTER TABLE pm_sprints_new RENAME TO pm_sprints;
CREATE INDEX idx_pm_sprints_project ON pm_sprints(project_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_sprints_status ON pm_sprints(status) WHERE deleted_at IS NULL;

-- Step 4: Recreate pm_swim_lanes with FK to pm_projects
CREATE TABLE pm_swim_lanes_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    name TEXT NOT NULL,
    position INTEGER NOT NULL DEFAULT 0,
    wip_limit INTEGER,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    deleted_at INTEGER,
    FOREIGN KEY (project_id) REFERENCES pm_projects(id) ON DELETE CASCADE
);
INSERT INTO pm_swim_lanes_new SELECT * FROM pm_swim_lanes;
DROP TABLE pm_swim_lanes;
ALTER TABLE pm_swim_lanes_new RENAME TO pm_swim_lanes;
CREATE INDEX idx_pm_swim_lanes_project ON pm_swim_lanes(project_id) WHERE deleted_at IS NULL;

-- Step 5: Recreate pm_project_members with FK to pm_projects
CREATE TABLE pm_project_members_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK(role IN ('viewer', 'editor', 'admin')),
    created_at INTEGER NOT NULL,
    FOREIGN KEY (project_id) REFERENCES pm_projects(id) ON DELETE CASCADE,
    UNIQUE(project_id, user_id)
);
INSERT INTO pm_project_members_new SELECT * FROM pm_project_members;
DROP TABLE pm_project_members;
ALTER TABLE pm_project_members_new RENAME TO pm_project_members;
CREATE INDEX idx_pm_project_members_project ON pm_project_members(project_id);
CREATE INDEX idx_pm_project_members_user ON pm_project_members(user_id);

-- Step 6: Recreate pm_work_items (remove 'project' type, FK to pm_projects)
CREATE TABLE pm_work_items_new (
    id TEXT PRIMARY KEY,
    item_type TEXT NOT NULL CHECK(item_type IN ('epic', 'story', 'task')),
    parent_id TEXT,
    project_id TEXT NOT NULL,
    position INTEGER NOT NULL DEFAULT 0,
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'backlog' CHECK(status IN ('backlog', 'todo', 'in_progress', 'review', 'done')),
    priority TEXT NOT NULL DEFAULT 'medium' CHECK(priority IN ('critical', 'high', 'medium', 'low')),
    story_points INTEGER,
    assignee_id TEXT,
    sprint_id TEXT,
    version INTEGER NOT NULL DEFAULT 1,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    created_by TEXT NOT NULL,
    updated_by TEXT NOT NULL,
    deleted_at INTEGER,
    FOREIGN KEY (project_id) REFERENCES pm_projects(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_id) REFERENCES pm_work_items_new(id) ON DELETE SET NULL,
    FOREIGN KEY (sprint_id) REFERENCES pm_sprints(id) ON DELETE SET NULL
);
INSERT INTO pm_work_items_new
SELECT * FROM pm_work_items WHERE item_type != 'project';
DROP TABLE pm_work_items;
ALTER TABLE pm_work_items_new RENAME TO pm_work_items;
CREATE INDEX idx_pm_work_items_project ON pm_work_items(project_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_work_items_parent ON pm_work_items(parent_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_work_items_sprint ON pm_work_items(sprint_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_work_items_status ON pm_work_items(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_work_items_assignee ON pm_work_items(assignee_id) WHERE deleted_at IS NULL;

-- Step 7: Create indexes on pm_projects
CREATE INDEX idx_pm_projects_status ON pm_projects(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_pm_projects_key ON pm_projects(key) WHERE deleted_at IS NULL;
```

**Note**: Back up `.pm/data.db` before running. SQLite does not support transactional DDL fully.

**Verification**: `cargo sqlx prepare -p pm-db --check` (if using sqlx offline mode)

---

### Step 2: Create Rust Project Model

**Create**: `backend/crates/pm-core/src/models/project.rs`

```rust
//! Project entity - organizational container for work items.

use chrono::{DateTime, Utc};
use uuid::Uuid;

/// A project is a top-level organizational container.
/// Unlike work items, projects have a unique key and status (active/archived).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Project {
    pub id: Uuid,
    pub title: String,
    pub description: Option<String>,
    /// Unique short identifier (e.g., "PROJ", "WEBAPP")
    pub key: String,
    pub status: ProjectStatus,
    /// Optimistic locking version
    pub version: i32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub created_by: Uuid,
    pub updated_by: Uuid,
    pub deleted_at: Option<DateTime<Utc>>,
}

impl Project {
    /// Create a new project with default values
    pub fn new(
        title: String,
        key: String,
        created_by: Uuid,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            title,
            description: None,
            key,
            status: ProjectStatus::Active,
            version: 1,
            created_at: now,
            updated_at: now,
            created_by,
            updated_by: created_by,
            deleted_at: None,
        }
    }

    /// Check if project is deleted (soft delete)
    pub fn is_deleted(&self) -> bool {
        self.deleted_at.is_some()
    }

    /// Check if project is archived
    pub fn is_archived(&self) -> bool {
        self.status == ProjectStatus::Archived
    }
}

/// Project lifecycle status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ProjectStatus {
    /// Project is active and accepting work
    Active,
    /// Project is archived (read-only, hidden from default views)
    Archived,
}

impl ProjectStatus {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Active => "active",
            Self::Archived => "archived",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "active" => Some(Self::Active),
            "archived" => Some(Self::Archived),
            _ => None,
        }
    }
}

impl Default for ProjectStatus {
    fn default() -> Self {
        Self::Active
    }
}

impl std::fmt::Display for ProjectStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_project_status_roundtrip() {
        assert_eq!(ProjectStatus::from_str("active"), Some(ProjectStatus::Active));
        assert_eq!(ProjectStatus::from_str("archived"), Some(ProjectStatus::Archived));
        assert_eq!(ProjectStatus::from_str("invalid"), None);

        assert_eq!(ProjectStatus::Active.as_str(), "active");
        assert_eq!(ProjectStatus::Archived.as_str(), "archived");
    }

    #[test]
    fn test_project_new() {
        let user_id = Uuid::new_v4();
        let project = Project::new("My Project".to_string(), "MYPROJ".to_string(), user_id);

        assert_eq!(project.title, "My Project");
        assert_eq!(project.key, "MYPROJ");
        assert_eq!(project.status, ProjectStatus::Active);
        assert_eq!(project.version, 1);
        assert_eq!(project.created_by, user_id);
        assert!(!project.is_deleted());
        assert!(!project.is_archived());
    }
}
```

**Update**: `backend/crates/pm-core/src/models/mod.rs`

Add these lines:
```rust
mod project;

pub use project::{Project, ProjectStatus};
```

**Verification**: `cargo check -p pm-core && cargo test -p pm-core`

---

### Step 3: Create Project Repository

**Create**: `backend/crates/pm-db/src/repositories/project_repository.rs`

```rust
//! Repository for Project CRUD operations.

use chrono::{DateTime, TimeZone, Utc};
use pm_core::models::{Project, ProjectStatus};
use sqlx::{Executor, Row, Sqlite};
use uuid::Uuid;

use crate::DbError;

/// Repository for project database operations
pub struct ProjectRepository;

impl ProjectRepository {
    /// Create a new project
    pub async fn create<'e, E>(executor: E, project: &Project) -> Result<(), DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let id = project.id.to_string();
        let status = project.status.as_str();
        let created_at = project.created_at.timestamp();
        let updated_at = project.updated_at.timestamp();
        let created_by = project.created_by.to_string();
        let updated_by = project.updated_by.to_string();
        let deleted_at = project.deleted_at.map(|dt| dt.timestamp());

        sqlx::query(
            r#"
            INSERT INTO pm_projects (id, title, description, key, status, version,
                created_at, updated_at, created_by, updated_by, deleted_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(&id)
        .bind(&project.title)
        .bind(&project.description)
        .bind(&project.key)
        .bind(status)
        .bind(project.version)
        .bind(created_at)
        .bind(updated_at)
        .bind(&created_by)
        .bind(&updated_by)
        .bind(deleted_at)
        .execute(executor)
        .await?;

        Ok(())
    }

    /// Get project by ID (excludes soft-deleted)
    pub async fn get_by_id<'e, E>(executor: E, id: Uuid) -> Result<Option<Project>, DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let id_str = id.to_string();

        let row = sqlx::query(
            r#"SELECT * FROM pm_projects WHERE id = ? AND deleted_at IS NULL"#,
        )
        .bind(&id_str)
        .fetch_optional(executor)
        .await?;

        Ok(row.map(|r| Self::row_to_project(&r)))
    }

    /// Get project by unique key (excludes soft-deleted)
    pub async fn get_by_key<'e, E>(executor: E, key: &str) -> Result<Option<Project>, DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let row = sqlx::query(
            r#"SELECT * FROM pm_projects WHERE key = ? AND deleted_at IS NULL"#,
        )
        .bind(key)
        .fetch_optional(executor)
        .await?;

        Ok(row.map(|r| Self::row_to_project(&r)))
    }

    /// Get all projects (excludes soft-deleted), ordered by title
    pub async fn get_all<'e, E>(executor: E) -> Result<Vec<Project>, DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let rows = sqlx::query(
            r#"SELECT * FROM pm_projects WHERE deleted_at IS NULL ORDER BY title"#,
        )
        .fetch_all(executor)
        .await?;

        Ok(rows.iter().map(|r| Self::row_to_project(r)).collect())
    }

    /// Get all active projects (excludes archived and soft-deleted)
    pub async fn get_active<'e, E>(executor: E) -> Result<Vec<Project>, DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let rows = sqlx::query(
            r#"SELECT * FROM pm_projects WHERE status = 'active' AND deleted_at IS NULL ORDER BY title"#,
        )
        .fetch_all(executor)
        .await?;

        Ok(rows.iter().map(|r| Self::row_to_project(r)).collect())
    }

    /// Update an existing project
    pub async fn update<'e, E>(executor: E, project: &Project) -> Result<(), DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let id = project.id.to_string();
        let status = project.status.as_str();
        let updated_at = project.updated_at.timestamp();
        let updated_by = project.updated_by.to_string();

        let result = sqlx::query(
            r#"
            UPDATE pm_projects
            SET title = ?, description = ?, status = ?, version = ?,
                updated_at = ?, updated_by = ?
            WHERE id = ? AND deleted_at IS NULL
            "#,
        )
        .bind(&project.title)
        .bind(&project.description)
        .bind(status)
        .bind(project.version)
        .bind(updated_at)
        .bind(&updated_by)
        .bind(&id)
        .execute(executor)
        .await?;

        if result.rows_affected() == 0 {
            return Err(DbError::NotFound {
                entity: "Project".to_string(),
                id: id.clone(),
            });
        }

        Ok(())
    }

    /// Soft delete a project
    pub async fn soft_delete<'e, E>(
        executor: E,
        id: Uuid,
        deleted_by: Uuid,
    ) -> Result<(), DbError>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        let id_str = id.to_string();
        let deleted_by_str = deleted_by.to_string();
        let now = Utc::now().timestamp();

        let result = sqlx::query(
            r#"UPDATE pm_projects SET deleted_at = ?, updated_by = ?, updated_at = ? WHERE id = ? AND deleted_at IS NULL"#,
        )
        .bind(now)
        .bind(&deleted_by_str)
        .bind(now)
        .bind(&id_str)
        .execute(executor)
        .await?;

        if result.rows_affected() == 0 {
            return Err(DbError::NotFound {
                entity: "Project".to_string(),
                id: id_str,
            });
        }

        Ok(())
    }

    /// Convert a database row to a Project
    fn row_to_project(row: &sqlx::sqlite::SqliteRow) -> Project {
        let id: String = row.get("id");
        let title: String = row.get("title");
        let description: Option<String> = row.get("description");
        let key: String = row.get("key");
        let status: String = row.get("status");
        let version: i32 = row.get("version");
        let created_at: i64 = row.get("created_at");
        let updated_at: i64 = row.get("updated_at");
        let created_by: String = row.get("created_by");
        let updated_by: String = row.get("updated_by");
        let deleted_at: Option<i64> = row.get("deleted_at");

        Project {
            id: Uuid::parse_str(&id).expect("Invalid UUID in database"),
            title,
            description,
            key,
            status: ProjectStatus::from_str(&status).unwrap_or(ProjectStatus::Active),
            version,
            created_at: Utc.timestamp_opt(created_at, 0).unwrap(),
            updated_at: Utc.timestamp_opt(updated_at, 0).unwrap(),
            created_by: Uuid::parse_str(&created_by).expect("Invalid UUID in database"),
            updated_by: Uuid::parse_str(&updated_by).expect("Invalid UUID in database"),
            deleted_at: deleted_at.map(|ts| Utc.timestamp_opt(ts, 0).unwrap()),
        }
    }
}
```

**Update**: `backend/crates/pm-db/src/repositories/mod.rs`

Add these lines:
```rust
mod project_repository;

pub use project_repository::ProjectRepository;
```

**Verification**: `cargo check -p pm-db`

---

## Session 41.1 Completion Checklist

After completing all steps:

- [ ] `cargo check -p pm-core` passes
- [ ] `cargo check -p pm-db` passes
- [ ] `cargo check --workspace` passes
- [ ] `cargo test -p pm-core` passes
- [ ] Migration file exists with correct timestamp

### Files Created (3)
- `pm-db/migrations/20260121000001_create_projects_table.sql`
- `pm-core/src/models/project.rs`
- `pm-db/src/repositories/project_repository.rs`

### Files Modified (2)
- `pm-core/src/models/mod.rs`
- `pm-db/src/repositories/mod.rs`

---

## Next Session

**Session 41.2** will implement:
- Protobuf messages for Project
- WebSocket handlers (create, update, delete, list)
- Response builders
- Validation helpers
- Backend tests
