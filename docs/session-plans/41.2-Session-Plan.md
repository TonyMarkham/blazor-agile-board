# Session 41.2: Backend Protobuf & Handlers

**Parent Plan**: `41-Session-Plan.md`
**Target**: ~40-50k tokens
**Prerequisites**: Session 41.1 complete, `cargo check --workspace` passes

---

## Scope

This session implements the WebSocket protocol and handlers for Projects:

1. **Protobuf Messages** - Project message types and Payload variants
2. **WebSocket Handlers** - Create/Update/Delete/List handlers
3. **Response Builders** - Build project response messages
4. **Validation** - Key format validation
5. **Backend Tests** - Repository and handler tests

---

## Implementation Order

### Step 1: Add Protobuf Messages

**Update**: `proto/messages.proto`

Add after existing enums (find next available field numbers for Payload oneof):

```protobuf
// ============================================================
// Project Messages
// ============================================================

enum ProjectStatus {
  PROJECT_STATUS_UNSPECIFIED = 0;
  PROJECT_STATUS_ACTIVE = 1;
  PROJECT_STATUS_ARCHIVED = 2;
}

message Project {
  string id = 1;
  string title = 2;
  optional string description = 3;
  string key = 4;
  ProjectStatus status = 5;
  int32 version = 6;
  int64 created_at = 7;
  int64 updated_at = 8;
  string created_by = 9;
  string updated_by = 10;
  optional int64 deleted_at = 11;
}

message CreateProjectRequest {
  string title = 1;
  optional string description = 2;
  string key = 3;
}

message UpdateProjectRequest {
  string project_id = 1;
  int32 expected_version = 2;
  optional string title = 3;
  optional string description = 4;
  optional ProjectStatus status = 5;
}

message DeleteProjectRequest {
  string project_id = 1;
  int32 expected_version = 2;
}

message ListProjectsRequest {}

message ProjectCreated {
  Project project = 1;
  string user_id = 2;
}

message ProjectUpdated {
  Project project = 1;
  repeated FieldChange changes = 2;
  string user_id = 3;
}

message ProjectDeleted {
  string project_id = 1;
  string user_id = 2;
}

message ProjectList {
  repeated Project projects = 1;
}
```

**Update WebSocketMessage.payload oneof** (use next available field numbers):

```protobuf
message WebSocketMessage {
  // ... existing fields ...

  oneof payload {
    // ... existing payloads ...

    // Project payloads (use next available numbers, e.g., 50-57)
    CreateProjectRequest create_project_request = 50;
    UpdateProjectRequest update_project_request = 51;
    DeleteProjectRequest delete_project_request = 52;
    ListProjectsRequest list_projects_request = 53;
    ProjectCreated project_created = 54;
    ProjectUpdated project_updated = 55;
    ProjectDeleted project_deleted = 56;
    ProjectList project_list = 57;
  }
}
```

**Verification**: `cargo build -p pm-proto`

---

### Step 2: Add Validation Helper

**Update**: `backend/crates/pm-ws/src/handlers/validation.rs`

Add this function:

```rust
use crate::error::WsError;
use std::panic::Location;
use error_location::ErrorLocation;

/// Validate project key format
/// - Must be 2-20 characters
/// - Must be alphanumeric with underscores only
/// - Will be stored uppercase
#[track_caller]
pub fn validate_key(key: &str) -> Result<(), WsError> {
    if key.len() < 2 || key.len() > 20 {
        return Err(WsError::ValidationError {
            message: "Key must be 2-20 characters".to_string(),
            field: Some("key".to_string()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    if !key.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
        return Err(WsError::ValidationError {
            message: "Key must contain only letters, numbers, and underscores".to_string(),
            field: Some("key".to_string()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    Ok(())
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 3: Add Response Builders

**Update**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

Add these functions:

```rust
use pm_core::models::Project;
use pm_proto::{
    web_socket_message::Payload, FieldChange, Project as ProtoProject,
    ProjectCreated, ProjectDeleted, ProjectList, ProjectStatus as ProtoProjectStatus,
    ProjectUpdated, WebSocketMessage,
};
use chrono::Utc;
use uuid::Uuid;

/// Convert domain Project to proto Project
pub fn project_to_proto(project: &Project) -> ProtoProject {
    ProtoProject {
        id: project.id.to_string(),
        title: project.title.clone(),
        description: project.description.clone(),
        key: project.key.clone(),
        status: match project.status {
            pm_core::models::ProjectStatus::Active => ProtoProjectStatus::Active.into(),
            pm_core::models::ProjectStatus::Archived => ProtoProjectStatus::Archived.into(),
        },
        version: project.version,
        created_at: project.created_at.timestamp(),
        updated_at: project.updated_at.timestamp(),
        created_by: project.created_by.to_string(),
        updated_by: project.updated_by.to_string(),
        deleted_at: project.deleted_at.map(|dt| dt.timestamp()),
    }
}

/// Build ProjectCreated response
pub fn build_project_created_response(
    message_id: &str,
    project: &Project,
    actor_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::ProjectCreated(ProjectCreated {
            project: Some(project_to_proto(project)),
            user_id: actor_id.to_string(),
        })),
    }
}

/// Build ProjectUpdated response
pub fn build_project_updated_response(
    message_id: &str,
    project: &Project,
    changes: &[FieldChange],
    actor_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::ProjectUpdated(ProjectUpdated {
            project: Some(project_to_proto(project)),
            changes: changes.to_vec(),
            user_id: actor_id.to_string(),
        })),
    }
}

/// Build ProjectDeleted response
pub fn build_project_deleted_response(
    message_id: &str,
    project_id: Uuid,
    actor_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::ProjectDeleted(ProjectDeleted {
            project_id: project_id.to_string(),
            user_id: actor_id.to_string(),
        })),
    }
}

/// Build ProjectList response
pub fn build_project_list_response(
    message_id: &str,
    projects: &[Project],
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::ProjectList(ProjectList {
            projects: projects.iter().map(project_to_proto).collect(),
        })),
    }
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 4: Create Project Handlers

**Create**: `backend/crates/pm-ws/src/handlers/project.rs`

```rust
//! WebSocket handlers for Project CRUD operations.

use chrono::Utc;
use pm_core::models::{Project, ProjectStatus};
use pm_db::repositories::{ProjectRepository, WorkItemRepository, ActivityLogRepository};
use pm_proto::{
    CreateProjectRequest, DeleteProjectRequest, ListProjectsRequest,
    UpdateProjectRequest, WebSocketMessage, FieldChange,
};
use uuid::Uuid;

use crate::error::{WsError, WsErrorResult};
use crate::handlers::{
    context::HandlerContext,
    db_ops::{db_read, db_write},
    idempotency::{check_idempotency, store_idempotency},
    response_builder::{
        build_project_created_response, build_project_deleted_response,
        build_project_list_response, build_project_updated_response,
    },
    validation::{validate_key, validate_title, validate_description, sanitize_string},
};
use crate::log_handler_entry;

/// Handle CreateProjectRequest
pub async fn handle_create(
    req: CreateProjectRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log_handler_entry!(ctx.request_ctx, "CreateProject");

    // 1. Validate input
    validate_title(&req.title, 1, 200)?;
    validate_key(&req.key)?;
    if let Some(ref desc) = req.description {
        validate_description(desc, 10000)?;
    }

    // 2. Check idempotency
    if let Some(cached) = db_read(&ctx, "check_idempotency", || {
        check_idempotency(&ctx.pool, &ctx.message_id)
    })
    .await?
    {
        log::info!("{} Returning cached idempotent response", ctx.log_prefix());
        return Ok(cached);
    }

    // 3. Check key uniqueness
    let key_upper = req.key.to_uppercase();
    let existing = db_read(&ctx, "get_by_key", || {
        ProjectRepository::get_by_key(&ctx.pool, &key_upper)
    })
    .await?;

    if existing.is_some() {
        return Err(WsError::ValidationError {
            message: "Project key already exists".to_string(),
            field: Some("key".to_string()),
            location: error_location::ErrorLocation::from(std::panic::Location::caller()),
        });
    }

    // 4. Build project
    let project = Project {
        id: Uuid::new_v4(),
        title: sanitize_string(&req.title),
        description: req.description.as_ref().map(|d| sanitize_string(d)),
        key: key_upper,
        status: ProjectStatus::Active,
        version: 1,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        created_by: ctx.user_id,
        updated_by: ctx.user_id,
        deleted_at: None,
    };

    // 5. Transaction: create + activity log
    let project_clone = project.clone();
    db_write(&ctx, "create_project_tx", || async {
        let mut tx = ctx.pool.begin().await?;
        ProjectRepository::create(&mut *tx, &project_clone).await?;

        let activity = pm_core::models::ActivityLog::created(
            "project",
            project_clone.id,
            ctx.user_id,
        );
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    // 6. Build response + store idempotency
    let response = build_project_created_response(&ctx.message_id, &project, ctx.user_id);
    store_idempotency(&ctx.pool, &ctx.message_id, "create_project", &response).await;

    log::info!(
        "{} Created project {} (key={})",
        ctx.log_prefix(),
        project.id,
        project.key
    );

    Ok(response)
}

/// Handle UpdateProjectRequest
pub async fn handle_update(
    req: UpdateProjectRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log_handler_entry!(ctx.request_ctx, "UpdateProject");

    // 1. Parse + fetch existing
    let project_id = crate::handlers::parse_uuid(&req.project_id, "project_id")?;

    let mut project = db_read(&ctx, "get_project", || {
        ProjectRepository::get_by_id(&ctx.pool, project_id)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "Project".to_string(),
        id: project_id.to_string(),
        location: error_location::ErrorLocation::from(std::panic::Location::caller()),
    })?;

    // 2. Optimistic locking
    if project.version != req.expected_version {
        return Err(WsError::ConflictError {
            current_version: project.version,
            location: error_location::ErrorLocation::from(std::panic::Location::caller()),
        });
    }

    // 3. Validate updates
    if let Some(ref title) = req.title {
        validate_title(title, 1, 200)?;
    }
    if let Some(ref desc) = req.description {
        validate_description(desc, 10000)?;
    }

    // 4. Track changes
    let mut changes = Vec::new();

    if let Some(ref new_title) = req.title {
        if &project.title != new_title {
            changes.push(FieldChange {
                field_name: "title".to_string(),
                old_value: Some(project.title.clone()),
                new_value: Some(new_title.clone()),
            });
            project.title = sanitize_string(new_title);
        }
    }

    if let Some(ref new_desc) = req.description {
        let old_desc = project.description.clone().unwrap_or_default();
        if &old_desc != new_desc {
            changes.push(FieldChange {
                field_name: "description".to_string(),
                old_value: project.description.clone(),
                new_value: Some(new_desc.clone()),
            });
            project.description = Some(sanitize_string(new_desc));
        }
    }

    if let Some(new_status) = req.status {
        let domain_status = match new_status {
            1 => ProjectStatus::Active,
            2 => ProjectStatus::Archived,
            _ => ProjectStatus::Active,
        };
        if project.status != domain_status {
            changes.push(FieldChange {
                field_name: "status".to_string(),
                old_value: Some(project.status.as_str().to_string()),
                new_value: Some(domain_status.as_str().to_string()),
            });
            project.status = domain_status;
        }
    }

    // 5. No changes? Return current state
    if changes.is_empty() {
        return Ok(build_project_updated_response(
            &ctx.message_id,
            &project,
            &[],
            ctx.user_id,
        ));
    }

    // 6. Apply metadata updates
    project.updated_at = Utc::now();
    project.updated_by = ctx.user_id;
    project.version += 1;

    // 7. Transaction
    let project_clone = project.clone();
    let changes_clone = changes.clone();
    db_write(&ctx, "update_project_tx", || async {
        let mut tx = ctx.pool.begin().await?;
        ProjectRepository::update(&mut *tx, &project_clone).await?;

        let activity = pm_core::models::ActivityLog::updated(
            "project",
            project_clone.id,
            ctx.user_id,
            &changes_clone,
        );
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    log::info!(
        "{} Updated project {} ({} changes)",
        ctx.log_prefix(),
        project.id,
        changes.len()
    );

    Ok(build_project_updated_response(
        &ctx.message_id,
        &project,
        &changes,
        ctx.user_id,
    ))
}

/// Handle DeleteProjectRequest
pub async fn handle_delete(
    req: DeleteProjectRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log_handler_entry!(ctx.request_ctx, "DeleteProject");

    // 1. Parse project ID
    let project_id = crate::handlers::parse_uuid(&req.project_id, "project_id")?;

    // 2. Fetch existing
    let project = db_read(&ctx, "get_project", || {
        ProjectRepository::get_by_id(&ctx.pool, project_id)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "Project".to_string(),
        id: project_id.to_string(),
        location: error_location::ErrorLocation::from(std::panic::Location::caller()),
    })?;

    // 3. Optimistic locking
    if project.version != req.expected_version {
        return Err(WsError::ConflictError {
            current_version: project.version,
            location: error_location::ErrorLocation::from(std::panic::Location::caller()),
        });
    }

    // 4. Check no work items exist
    let items = db_read(&ctx, "get_work_items", || {
        WorkItemRepository::find_by_project(&ctx.pool, project_id)
    })
    .await?;

    if !items.is_empty() {
        return Err(WsError::DeleteBlocked {
            message: format!(
                "Cannot delete project: has {} work item(s). Delete or move them first.",
                items.len()
            ),
            location: error_location::ErrorLocation::from(std::panic::Location::caller()),
        });
    }

    // 5. Transaction with soft delete
    db_write(&ctx, "delete_project_tx", || async {
        let mut tx = ctx.pool.begin().await?;
        ProjectRepository::soft_delete(&mut *tx, project_id, ctx.user_id).await?;

        let activity = pm_core::models::ActivityLog::deleted(
            "project",
            project_id,
            ctx.user_id,
        );
        ActivityLogRepository::create(&mut *tx, &activity).await?;

        tx.commit().await?;
        Ok::<_, WsError>(())
    })
    .await?;

    log::info!(
        "{} Deleted project {} (key={})",
        ctx.log_prefix(),
        project_id,
        project.key
    );

    Ok(build_project_deleted_response(
        &ctx.message_id,
        project_id,
        ctx.user_id,
    ))
}

/// Handle ListProjectsRequest
pub async fn handle_list(
    _req: ListProjectsRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log_handler_entry!(ctx.request_ctx, "ListProjects");

    let projects = db_read(&ctx, "get_all_projects", || {
        ProjectRepository::get_all(&ctx.pool)
    })
    .await?;

    log::debug!(
        "{} Listed {} projects",
        ctx.log_prefix(),
        projects.len()
    );

    Ok(build_project_list_response(&ctx.message_id, &projects))
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub mod project;

pub use project::{
    handle_create as handle_create_project,
    handle_update as handle_update_project,
    handle_delete as handle_delete_project,
    handle_list as handle_list_projects,
};
```

**Verification**: `cargo check -p pm-ws`

---

### Step 5: Update Dispatcher

**Update**: `backend/crates/pm-ws/src/handlers/dispatcher.rs`

Add dispatch arms in the `dispatch_inner` function:

```rust
use pm_proto::web_socket_message::Payload;

// Inside dispatch_inner match statement, add:
Some(Payload::CreateProjectRequest(req)) => {
    project::handle_create(req, ctx).await
}
Some(Payload::UpdateProjectRequest(req)) => {
    project::handle_update(req, ctx).await
}
Some(Payload::DeleteProjectRequest(req)) => {
    project::handle_delete(req, ctx).await
}
Some(Payload::ListProjectsRequest(req)) => {
    project::handle_list(req, ctx).await
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 6: Create Backend Tests

**Create**: `backend/crates/pm-db/tests/project_repository_tests.rs`

```rust
use pm_core::models::{Project, ProjectStatus};
use pm_db::repositories::ProjectRepository;
use sqlx::SqlitePool;
use uuid::Uuid;
use chrono::Utc;

async fn create_test_project(pool: &SqlitePool, key: &str) -> Project {
    let user_id = Uuid::new_v4();
    let project = Project {
        id: Uuid::new_v4(),
        title: format!("Test Project {}", key),
        description: Some("Test description".to_string()),
        key: key.to_string(),
        status: ProjectStatus::Active,
        version: 1,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        created_by: user_id,
        updated_by: user_id,
        deleted_at: None,
    };
    ProjectRepository::create(pool, &project).await.unwrap();
    project
}

#[sqlx::test]
async fn test_create_and_get_by_id(pool: SqlitePool) {
    let project = create_test_project(&pool, "TEST1").await;

    let found = ProjectRepository::get_by_id(&pool, project.id)
        .await
        .unwrap()
        .unwrap();

    assert_eq!(found.id, project.id);
    assert_eq!(found.title, project.title);
    assert_eq!(found.key, "TEST1");
}

#[sqlx::test]
async fn test_get_by_key(pool: SqlitePool) {
    let project = create_test_project(&pool, "UNIQUE_KEY").await;

    let found = ProjectRepository::get_by_key(&pool, "UNIQUE_KEY")
        .await
        .unwrap()
        .unwrap();

    assert_eq!(found.id, project.id);
}

#[sqlx::test]
async fn test_get_all_excludes_deleted(pool: SqlitePool) {
    let p1 = create_test_project(&pool, "PROJ1").await;
    let p2 = create_test_project(&pool, "PROJ2").await;

    // Soft delete p2
    ProjectRepository::soft_delete(&pool, p2.id, p2.created_by)
        .await
        .unwrap();

    let all = ProjectRepository::get_all(&pool).await.unwrap();

    assert_eq!(all.len(), 1);
    assert_eq!(all[0].id, p1.id);
}

#[sqlx::test]
async fn test_update_increments_version(pool: SqlitePool) {
    let mut project = create_test_project(&pool, "UPDATE_TEST").await;

    project.title = "Updated Title".to_string();
    project.version = 2;
    ProjectRepository::update(&pool, &project).await.unwrap();

    let found = ProjectRepository::get_by_id(&pool, project.id)
        .await
        .unwrap()
        .unwrap();

    assert_eq!(found.title, "Updated Title");
    assert_eq!(found.version, 2);
}

#[sqlx::test]
async fn test_soft_delete(pool: SqlitePool) {
    let project = create_test_project(&pool, "DELETE_TEST").await;

    ProjectRepository::soft_delete(&pool, project.id, project.created_by)
        .await
        .unwrap();

    // Should not be found via normal get
    let found = ProjectRepository::get_by_id(&pool, project.id).await.unwrap();
    assert!(found.is_none());
}
```

**Verification**: `cargo test -p pm-db`

---

## Session 41.2 Completion Checklist

After completing all steps:

- [ ] `cargo build -p pm-proto` passes
- [ ] `cargo check -p pm-ws` passes
- [ ] `cargo check --workspace` passes
- [ ] `cargo test -p pm-db` passes
- [ ] `cargo test --workspace` passes

### Files Created (2)
- `pm-ws/src/handlers/project.rs`
- `pm-db/tests/project_repository_tests.rs`

### Files Modified (5)
- `proto/messages.proto`
- `pm-ws/src/handlers/mod.rs`
- `pm-ws/src/handlers/dispatcher.rs`
- `pm-ws/src/handlers/response_builder.rs`
- `pm-ws/src/handlers/validation.rs`

---

## Next Session

**Session 41.3** will implement:
- C# Project models and DTOs
- WebSocket client extensions
- ProtoConverter updates
