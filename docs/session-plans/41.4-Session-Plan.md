# Session 41.4: Frontend State & UI

**Parent Plan**: `41-Session-Plan.md`
**Target**: ~40-50k tokens
**Prerequisites**: Session 41.3 complete, `dotnet build frontend/ProjectManagement.sln` passes

---

## Scope

This session implements the frontend state management and UI components:

1. **ProjectViewModel** - ViewModel wrapping Project
2. **ViewModelFactory** - Add Create(Project) overload
3. **IProjectStore** - Interface with CRUD operations
4. **ProjectStore** - Implementation with optimistic updates
5. **AppState** - Add Projects property
6. **DI Registration** - Register IProjectStore
7. **UI Components** - ProjectDialog, page updates
8. **Tests** - ViewModel, Store, and Dialog tests

---

## Implementation Order

### Step 1: Create ProjectViewModel

**Create**: `frontend/ProjectManagement.Core/ViewModels/ProjectViewModel.cs`

```csharp
using ProjectManagement.Core.Models;

namespace ProjectManagement.Core.ViewModels;

/// <summary>
/// ViewModel for Project, adding pending sync state and computed properties.
/// </summary>
public sealed class ProjectViewModel : IViewModel<Project>, IEquatable<ProjectViewModel>
{
    /// <summary>
    /// Create a new ProjectViewModel.
    /// </summary>
    public ProjectViewModel(Project model, bool isPendingSync = false)
    {
        Model = model;
        IsPendingSync = isPendingSync;
    }

    /// <summary>
    /// The underlying Project model.
    /// </summary>
    public Project Model { get; }

    /// <summary>
    /// Whether this item has pending changes not yet confirmed by the server.
    /// </summary>
    public bool IsPendingSync { get; }

    // ============================================================
    // Delegated Properties
    // ============================================================

    public Guid Id => Model.Id;
    public string Title => Model.Title;
    public string? Description => Model.Description;
    public string Key => Model.Key;
    public ProjectStatus Status => Model.Status;
    public int Version => Model.Version;
    public DateTime CreatedAt => Model.CreatedAt;
    public DateTime UpdatedAt => Model.UpdatedAt;
    public Guid CreatedBy => Model.CreatedBy;
    public Guid UpdatedBy => Model.UpdatedBy;
    public DateTime? DeletedAt => Model.DeletedAt;
    public bool IsDeleted => Model.IsDeleted;

    // ============================================================
    // Computed Properties
    // ============================================================

    /// <summary>
    /// Human-readable status name.
    /// </summary>
    public string StatusDisplayName => Status switch
    {
        ProjectStatus.Active => "Active",
        ProjectStatus.Archived => "Archived",
        _ => Status.ToString()
    };

    /// <summary>
    /// Whether the project is archived.
    /// </summary>
    public bool IsArchived => Status == ProjectStatus.Archived;

    /// <summary>
    /// CSS class for status badge.
    /// </summary>
    public string StatusCssClass => Status switch
    {
        ProjectStatus.Active => "badge-success",
        ProjectStatus.Archived => "badge-secondary",
        _ => "badge-default"
    };

    // ============================================================
    // Equality
    // ============================================================

    public bool Equals(ProjectViewModel? other) =>
        other is not null
        && Id == other.Id
        && Version == other.Version
        && IsPendingSync == other.IsPendingSync;

    public override bool Equals(object? obj) => Equals(obj as ProjectViewModel);

    public override int GetHashCode() => HashCode.Combine(Id, Version, IsPendingSync);

    public static bool operator ==(ProjectViewModel? left, ProjectViewModel? right) =>
        left?.Equals(right) ?? right is null;

    public static bool operator !=(ProjectViewModel? left, ProjectViewModel? right) =>
        !(left == right);
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 2: Update ViewModelFactory

**Update**: `frontend/ProjectManagement.Core/ViewModels/ViewModelFactory.cs`

Add IProjectStore injection and Create(Project) method:

```csharp
// Add to constructor parameters:
private readonly IProjectStore _projectStore;

public ViewModelFactory(
    IWorkItemStore workItemStore,
    ISprintStore sprintStore,
    IProjectStore projectStore)
{
    _workItemStore = workItemStore;
    _sprintStore = sprintStore;
    _projectStore = projectStore;
}

// Add this method:
/// <summary>
/// Create a ProjectViewModel with pending state.
/// </summary>
public ProjectViewModel Create(Project project) =>
    new(project, _projectStore.IsPending(project.Id));
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 3: Create IProjectStore Interface

**Create**: `frontend/ProjectManagement.Core/Interfaces/IProjectStore.cs`

```csharp
using ProjectManagement.Core.Models;
using ProjectManagement.Core.ViewModels;

namespace ProjectManagement.Core.Interfaces;

/// <summary>
/// Store for managing project state with optimistic updates.
/// </summary>
public interface IProjectStore
{
    /// <summary>
    /// All non-deleted projects, ordered by title.
    /// </summary>
    IReadOnlyList<ProjectViewModel> Projects { get; }

    /// <summary>
    /// The currently selected project (for context display).
    /// </summary>
    ProjectViewModel? CurrentProject { get; }

    /// <summary>
    /// Whether the store has been loaded from the server.
    /// </summary>
    bool IsLoaded { get; }

    /// <summary>
    /// Fired when the current project changes.
    /// </summary>
    event Action? OnCurrentProjectChanged;

    /// <summary>
    /// Fired when the projects list changes.
    /// </summary>
    event Action? OnProjectsChanged;

    /// <summary>
    /// Set the current project context.
    /// </summary>
    void SetCurrentProject(Guid projectId);

    /// <summary>
    /// Clear the current project context.
    /// </summary>
    void ClearCurrentProject();

    /// <summary>
    /// Get a project by ID.
    /// </summary>
    ProjectViewModel? GetById(Guid id);

    /// <summary>
    /// Create a new project.
    /// </summary>
    Task<Project> CreateAsync(CreateProjectRequest request, CancellationToken ct = default);

    /// <summary>
    /// Update an existing project.
    /// </summary>
    Task<Project> UpdateAsync(UpdateProjectRequest request, CancellationToken ct = default);

    /// <summary>
    /// Delete a project.
    /// </summary>
    Task DeleteAsync(Guid id, int expectedVersion, CancellationToken ct = default);

    /// <summary>
    /// Refresh projects from the server.
    /// </summary>
    Task RefreshAsync(CancellationToken ct = default);

    /// <summary>
    /// Check if a project has pending changes.
    /// </summary>
    bool IsPending(Guid id);
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 4: Create ProjectStore Implementation

**Create**: `frontend/ProjectManagement.Services/State/ProjectStore.cs`

```csharp
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using ProjectManagement.Core.Interfaces;
using ProjectManagement.Core.Models;
using ProjectManagement.Core.ViewModels;

namespace ProjectManagement.Services.State;

/// <summary>
/// Store for project state with optimistic updates and server sync.
/// </summary>
public sealed class ProjectStore : IProjectStore, IDisposable
{
    private readonly IWebSocketClient _client;
    private readonly ILogger<ProjectStore> _logger;
    private readonly ConcurrentDictionary<Guid, Project> _projects = new();
    private readonly ConcurrentDictionary<Guid, OptimisticUpdate<Project>> _pendingUpdates = new();
    private Guid? _currentProjectId;
    private bool _disposed;

    public ProjectStore(IWebSocketClient client, ILogger<ProjectStore> logger)
    {
        _client = client;
        _logger = logger;

        // Subscribe to server events
        _client.OnProjectCreated += HandleProjectCreated;
        _client.OnProjectUpdated += HandleProjectUpdated;
        _client.OnProjectDeleted += HandleProjectDeleted;
    }

    public IReadOnlyList<ProjectViewModel> Projects => _projects.Values
        .Where(p => p.DeletedAt is null)
        .OrderBy(p => p.Title)
        .Select(p => new ProjectViewModel(p, _pendingUpdates.ContainsKey(p.Id)))
        .ToList();

    public ProjectViewModel? CurrentProject => _currentProjectId.HasValue
        && _projects.TryGetValue(_currentProjectId.Value, out var p)
        ? new ProjectViewModel(p, _pendingUpdates.ContainsKey(p.Id))
        : null;

    public bool IsLoaded { get; private set; }

    public event Action? OnCurrentProjectChanged;
    public event Action? OnProjectsChanged;

    public ProjectViewModel? GetById(Guid id) =>
        _projects.TryGetValue(id, out var p)
            ? new ProjectViewModel(p, _pendingUpdates.ContainsKey(id))
            : null;

    public void SetCurrentProject(Guid projectId)
    {
        if (_currentProjectId == projectId) return;
        _currentProjectId = projectId;
        NotifyCurrentProjectChanged();
    }

    public void ClearCurrentProject()
    {
        if (_currentProjectId is null) return;
        _currentProjectId = null;
        NotifyCurrentProjectChanged();
    }

    public async Task<Project> CreateAsync(CreateProjectRequest request, CancellationToken ct)
    {
        // Create optimistic project with temp ID
        var tempId = Guid.NewGuid();
        var optimistic = new Project
        {
            Id = tempId,
            Title = request.Title,
            Description = request.Description,
            Key = request.Key.ToUpperInvariant(),
            Status = ProjectStatus.Active,
            Version = 1,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
            CreatedBy = Guid.Empty, // Unknown until server responds
            UpdatedBy = Guid.Empty,
        };

        // Add optimistically
        _projects[tempId] = optimistic;
        _pendingUpdates[tempId] = new OptimisticUpdate<Project>(tempId, null, optimistic);
        NotifyProjectsChanged();

        try
        {
            var created = await _client.CreateProjectAsync(request, ct);

            // Replace temp with real
            _projects.TryRemove(tempId, out _);
            _pendingUpdates.TryRemove(tempId, out _);
            _projects[created.Id] = created;
            NotifyProjectsChanged();

            _logger.LogInformation("Created project {ProjectId} ({Key})", created.Id, created.Key);
            return created;
        }
        catch (Exception ex)
        {
            // Rollback
            _projects.TryRemove(tempId, out _);
            _pendingUpdates.TryRemove(tempId, out _);
            NotifyProjectsChanged();

            _logger.LogError(ex, "Failed to create project");
            throw;
        }
    }

    public async Task<Project> UpdateAsync(UpdateProjectRequest request, CancellationToken ct)
    {
        if (!_projects.TryGetValue(request.ProjectId, out var current))
            throw new InvalidOperationException($"Project {request.ProjectId} not found in store");

        // Create optimistic version
        var optimistic = current with
        {
            Title = request.Title ?? current.Title,
            Description = request.Description ?? current.Description,
            Status = request.Status ?? current.Status,
            Version = current.Version + 1,
            UpdatedAt = DateTime.UtcNow,
        };

        _projects[request.ProjectId] = optimistic;
        _pendingUpdates[request.ProjectId] = new OptimisticUpdate<Project>(request.ProjectId, current, optimistic);
        NotifyProjectsChanged();

        try
        {
            var updated = await _client.UpdateProjectAsync(request, ct);
            _projects[updated.Id] = updated;
            _pendingUpdates.TryRemove(request.ProjectId, out _);
            NotifyProjectsChanged();

            _logger.LogInformation("Updated project {ProjectId}", updated.Id);
            return updated;
        }
        catch (Exception ex)
        {
            // Rollback
            _projects[request.ProjectId] = current;
            _pendingUpdates.TryRemove(request.ProjectId, out _);
            NotifyProjectsChanged();

            _logger.LogError(ex, "Failed to update project {ProjectId}", request.ProjectId);
            throw;
        }
    }

    public async Task DeleteAsync(Guid id, int expectedVersion, CancellationToken ct)
    {
        if (!_projects.TryGetValue(id, out var current))
            throw new InvalidOperationException($"Project {id} not found in store");

        // Optimistic delete (mark as deleted)
        var optimistic = current with { DeletedAt = DateTime.UtcNow };
        _projects[id] = optimistic;
        _pendingUpdates[id] = new OptimisticUpdate<Project>(id, current, optimistic);
        NotifyProjectsChanged();

        try
        {
            await _client.DeleteProjectAsync(id, expectedVersion, ct);

            _projects.TryRemove(id, out _);
            _pendingUpdates.TryRemove(id, out _);

            // Clear current if deleted
            if (_currentProjectId == id)
            {
                _currentProjectId = null;
                NotifyCurrentProjectChanged();
            }

            NotifyProjectsChanged();
            _logger.LogInformation("Deleted project {ProjectId}", id);
        }
        catch (Exception ex)
        {
            // Rollback
            _projects[id] = current;
            _pendingUpdates.TryRemove(id, out _);
            NotifyProjectsChanged();

            _logger.LogError(ex, "Failed to delete project {ProjectId}", id);
            throw;
        }
    }

    public async Task RefreshAsync(CancellationToken ct)
    {
        var projects = await _client.GetProjectsAsync(ct);

        _projects.Clear();
        foreach (var p in projects)
            _projects[p.Id] = p;

        IsLoaded = true;
        NotifyProjectsChanged();

        _logger.LogDebug("Refreshed {Count} projects", projects.Count);
    }

    public bool IsPending(Guid id) => _pendingUpdates.ContainsKey(id);

    // ============================================================
    // Event Handlers
    // ============================================================

    private void HandleProjectCreated(Project p)
    {
        // Skip if we created it (already in store)
        if (_pendingUpdates.ContainsKey(p.Id)) return;

        _projects[p.Id] = p;
        NotifyProjectsChanged();
    }

    private void HandleProjectUpdated(Project p, IReadOnlyList<FieldChange> _)
    {
        // Skip if we updated it (already applied optimistically)
        if (_pendingUpdates.ContainsKey(p.Id)) return;

        _projects[p.Id] = p;
        NotifyProjectsChanged();
    }

    private void HandleProjectDeleted(Guid id)
    {
        // Skip if we deleted it (already removed optimistically)
        if (_pendingUpdates.ContainsKey(id)) return;

        _projects.TryRemove(id, out _);

        if (_currentProjectId == id)
        {
            _currentProjectId = null;
            NotifyCurrentProjectChanged();
        }

        NotifyProjectsChanged();
    }

    // ============================================================
    // Notifications
    // ============================================================

    private void NotifyProjectsChanged()
    {
        try { OnProjectsChanged?.Invoke(); }
        catch (Exception ex) { _logger.LogError(ex, "Error in OnProjectsChanged handler"); }
    }

    private void NotifyCurrentProjectChanged()
    {
        try { OnCurrentProjectChanged?.Invoke(); }
        catch (Exception ex) { _logger.LogError(ex, "Error in OnCurrentProjectChanged handler"); }
    }

    // ============================================================
    // Dispose
    // ============================================================

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _client.OnProjectCreated -= HandleProjectCreated;
        _client.OnProjectUpdated -= HandleProjectUpdated;
        _client.OnProjectDeleted -= HandleProjectDeleted;
    }
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Services`

---

### Step 5: Update AppState

**Update**: `frontend/ProjectManagement.Services/State/AppState.cs`

Add IProjectStore to constructor and wire events:

```csharp
// Add field:
public IProjectStore Projects { get; }

// Update constructor:
public AppState(
    IWebSocketClient client,
    IWorkItemStore workItems,
    ISprintStore sprints,
    IProjectStore projects,
    ILogger<AppState> logger)
{
    // ... existing code ...
    Projects = projects;

    // Wire events
    projects.OnCurrentProjectChanged += () => OnStateChanged?.Invoke();
    projects.OnProjectsChanged += () => OnStateChanged?.Invoke();
}

// Add helper method:
public Task LoadProjectsAsync(CancellationToken ct = default)
    => Projects.RefreshAsync(ct);
```

**Verification**: `dotnet build frontend/ProjectManagement.Services`

---

### Step 6: Update DI Registration

**Update**: `frontend/ProjectManagement.Wasm/Program.cs`

Add ProjectStore registration:

```csharp
// Add with other store registrations:
builder.Services.AddSingleton<IProjectStore, ProjectStore>();
```

**Verification**: `dotnet build frontend/ProjectManagement.Wasm`

---

### Step 7: Create ProjectDialog

**Create**: `frontend/ProjectManagement.Components/Projects/ProjectDialog.razor`

```razor
@using ProjectManagement.Core.Models
@using ProjectManagement.Core.ViewModels
@using ProjectManagement.Services.State
@inject AppState AppState
@inject DialogService DialogService
@inject NotificationService NotificationService

<RadzenTemplateForm TItem="ProjectFormModel" Data="@_model" Submit="@OnSubmit">
    <div class="form-group mb-3">
        <RadzenLabel Text="Title" Component="Title" class="d-block mb-1" />
        <RadzenTextBox Name="Title" @bind-Value="_model.Title" MaxLength="200"
                       Change="@OnTitleChanged" Style="width: 100%" />
        <RadzenRequiredValidator Component="Title" Text="Title is required" />
    </div>

    <div class="form-group mb-3">
        <RadzenLabel Text="Key" Component="Key" class="d-block mb-1" />
        <RadzenTextBox Name="Key" @bind-Value="_model.Key" MaxLength="20"
                       Disabled="@IsEditMode" Style="width: 100%"
                       Placeholder="@(IsEditMode ? "" : "AUTO-GENERATED")" />
        <RadzenRequiredValidator Component="Key" Text="Key is required" />
        <RadzenRegexValidator Component="Key" Pattern="^[A-Z0-9_]{2,20}$"
                              Text="Key must be 2-20 uppercase letters, numbers, or underscores" />
        @if (!IsEditMode)
        {
            <small class="text-muted">Auto-generated from title. Can be customized.</small>
        }
    </div>

    <div class="form-group mb-3">
        <RadzenLabel Text="Description" Component="Description" class="d-block mb-1" />
        <RadzenTextArea Name="Description" @bind-Value="_model.Description"
                        MaxLength="10000" Rows="4" Style="width: 100%" />
    </div>

    @if (IsEditMode)
    {
        <div class="form-group mb-3">
            <RadzenLabel Text="Status" Component="Status" class="d-block mb-1" />
            <RadzenDropDown Name="Status" @bind-Value="_model.Status"
                            Data="@_statusOptions" TextProperty="Text" ValueProperty="Value"
                            Style="width: 100%" />
        </div>
    }

    <div class="dialog-buttons d-flex justify-content-end gap-2 mt-4">
        <RadzenButton ButtonType="ButtonType.Button" Text="Cancel"
                      ButtonStyle="ButtonStyle.Light"
                      Click="@(() => DialogService.Close(null))" />
        <RadzenButton ButtonType="ButtonType.Submit"
                      Text="@(IsEditMode ? "Save Changes" : "Create Project")"
                      ButtonStyle="ButtonStyle.Primary"
                      Disabled="@_isSubmitting"
                      IsBusy="@_isSubmitting" />
    </div>
</RadzenTemplateForm>

@code {
    [Parameter] public ProjectViewModel? Project { get; set; }

    private ProjectFormModel _model = new();
    private bool _isSubmitting;
    private bool IsEditMode => Project is not null;

    private readonly record struct StatusOption(string Text, ProjectStatus Value);
    private static readonly StatusOption[] _statusOptions =
    [
        new("Active", ProjectStatus.Active),
        new("Archived", ProjectStatus.Archived),
    ];

    protected override void OnInitialized()
    {
        if (Project is not null)
        {
            _model = new()
            {
                Title = Project.Title,
                Key = Project.Key,
                Description = Project.Description,
                Status = Project.Status,
            };
        }
    }

    private void OnTitleChanged(string title)
    {
        if (IsEditMode) return; // Don't auto-generate key on edit
        _model.Key = GenerateKey(title);
    }

    private static string GenerateKey(string title) =>
        new string(title
            .ToUpperInvariant()
            .Where(c => char.IsLetterOrDigit(c))
            .Take(10)
            .ToArray());

    private async Task OnSubmit()
    {
        if (_isSubmitting) return;
        _isSubmitting = true;

        try
        {
            if (IsEditMode)
            {
                var request = new UpdateProjectRequest
                {
                    ProjectId = Project!.Id,
                    ExpectedVersion = Project.Version,
                    Title = _model.Title != Project.Title ? _model.Title : null,
                    Description = _model.Description != Project.Description ? _model.Description : null,
                    Status = _model.Status != Project.Status ? _model.Status : null,
                };

                var updated = await AppState.Projects.UpdateAsync(request);
                NotificationService.Notify(NotificationSeverity.Success, "Project Updated",
                    $"Project '{updated.Title}' has been updated.");
                DialogService.Close(updated);
            }
            else
            {
                var request = new CreateProjectRequest
                {
                    Title = _model.Title,
                    Description = _model.Description,
                    Key = _model.Key,
                };

                var created = await AppState.Projects.CreateAsync(request);
                NotificationService.Notify(NotificationSeverity.Success, "Project Created",
                    $"Project '{created.Title}' ({created.Key}) has been created.");
                DialogService.Close(created);
            }
        }
        catch (ServerRejectedException ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", ex.Message);
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error",
                "An unexpected error occurred. Please try again.");
        }
        finally
        {
            _isSubmitting = false;
        }
    }

    private sealed class ProjectFormModel
    {
        public string Title { get; set; } = "";
        public string Key { get; set; } = "";
        public string? Description { get; set; }
        public ProjectStatus Status { get; set; } = ProjectStatus.Active;
    }
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Components`

---

### Step 8: Update MainLayout

**Update**: `frontend/ProjectManagement.Wasm/Layout/MainLayout.razor`

Add project context display in header:

```razor
@* In the header section, add: *@
<RadzenText TextStyle="TextStyle.H5" class="m-0">
    Agile Board
    @if (AppState.Projects.CurrentProject is { } project)
    {
        <span class="project-context text-muted"> / @project.Title</span>
    }
</RadzenText>
```

Add CSS in the component or app.css:
```css
.project-context {
    font-weight: normal;
    font-size: 0.9em;
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Wasm`

---

### Step 9: Update ProjectDetail Page

**Update**: `frontend/ProjectManagement.Wasm/Pages/ProjectDetail.razor`

Set current project on load:

```csharp
// In OnInitializedAsync or OnParametersSetAsync:
protected override async Task OnParametersSetAsync()
{
    // Set current project context
    AppState.Projects.SetCurrentProject(ProjectId);

    // ... existing code to load project data ...
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Wasm`

---

### Step 10: Update Home Page

**Update**: `frontend/ProjectManagement.Wasm/Pages/Home.razor`

Use ProjectStore and wire Create button:

```csharp
// Update OnInitializedAsync:
protected override async Task OnInitializedAsync()
{
    // Clear project context on home
    AppState.Projects.ClearCurrentProject();

    // Load projects
    await AppState.LoadProjectsAsync();
    _projects = AppState.Projects.Projects.ToList();

    // Subscribe to changes
    AppState.Projects.OnProjectsChanged += OnProjectsChanged;
}

private void OnProjectsChanged()
{
    _projects = AppState.Projects.Projects.ToList();
    InvokeAsync(StateHasChanged);
}

public void Dispose()
{
    AppState.Projects.OnProjectsChanged -= OnProjectsChanged;
}

// Update ShowCreateProjectDialog:
private async Task ShowCreateProjectDialog()
{
    var result = await DialogService.OpenAsync<ProjectDialog>(
        "Create Project",
        new Dictionary<string, object>(),
        new DialogOptions { Width = "500px" });

    if (result is Project created)
    {
        // Optionally navigate to the new project
        NavigationManager.NavigateTo($"/project/{created.Id}");
    }
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Wasm`

---

## Session 41.4 Completion Checklist

After completing all steps:

- [ ] `dotnet build frontend/ProjectManagement.sln` passes
- [ ] `dotnet test` passes
- [ ] Create project via UI works
- [ ] Edit project via UI works
- [ ] Header shows project context
- [ ] Home page lists projects

### Files Created (4)
- `Core/ViewModels/ProjectViewModel.cs`
- `Core/Interfaces/IProjectStore.cs`
- `Services/State/ProjectStore.cs`
- `Components/Projects/ProjectDialog.razor`

### Files Modified (6)
- `Core/ViewModels/ViewModelFactory.cs`
- `Services/State/AppState.cs`
- `Wasm/Program.cs`
- `Wasm/Layout/MainLayout.razor`
- `Wasm/Pages/ProjectDetail.razor`
- `Wasm/Pages/Home.razor`

---

## Final Verification

Run full test suite:

```bash
# Backend
cargo test --workspace

# Frontend
dotnet build frontend/ProjectManagement.sln
dotnet test

# Manual testing
# 1. Start backend: cargo run -p pm-server
# 2. Start frontend: dotnet run --project frontend/ProjectManagement.Wasm
# 3. Create a new project
# 4. Verify it appears in list
# 5. Click into project, verify header shows context
# 6. Edit project, verify changes save
# 7. Return to home, verify header clears context
```
