# Session 42.1: Core Identity Models & Backend

**Parent Plan**: `42-Session-Plan-Overview.md`
**Target**: ~35-40k tokens
**Prerequisites**: Existing codebase compiles (`dotnet build && cargo check --workspace`)

---

## Teaching Focus

This session teaches:
- **Data modeling** with schema versioning for future migrations
- **Validation patterns** with centralized error handling
- **Production error handling** - Structured errors with `thiserror` + `error_location`
- **Rust/C# interop** via Tauri commands
- **Security considerations** for desktop vs web authentication

---

## Scope

1. **UserIdentity Model** - Schema-versioned identity with validation
2. **ValidationResult Helper** - Reusable validation patterns
3. **Tauri Rust Commands** - Load, save, backup identity files
4. **Backend Security** - Reject user_id param when auth enabled

---

## Implementation Order

### Step 1: Create User Identity Model with Schema Versioning

**Create**: `frontend/ProjectManagement.Core/Models/UserIdentity.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

namespace ProjectManagement.Core.Models;

/// <summary>
/// Persistent user identity stored locally on the desktop.
/// Used to maintain consistent user ID across app restarts.
/// </summary>
public sealed record UserIdentity
{
    /// <summary>Current schema version for migration support.</summary>
    public const int CurrentSchemaVersion = 1;

    [JsonPropertyName("id")]
    public required Guid Id { get; init; }

    [JsonPropertyName("name")]
    [StringLength(100, ErrorMessage = "Name cannot exceed 100 characters")]
    public string? Name { get; init; }

    [JsonPropertyName("email")]
    [EmailAddress(ErrorMessage = "Invalid email format")]
    public string? Email { get; init; }

    [JsonPropertyName("created_at")]
    public required DateTime CreatedAt { get; init; }

    [JsonPropertyName("schema_version")]
    public int SchemaVersion { get; init; } = CurrentSchemaVersion;

    /// <summary>
    /// Creates a new user identity with a fresh UUID.
    /// </summary>
    public static UserIdentity Create(string? name = null, string? email = null)
    {
        // Validate email format if provided
        if (!string.IsNullOrWhiteSpace(email) && !IsValidEmail(email))
        {
            throw new ArgumentException("Invalid email format", nameof(email));
        }

        return new UserIdentity
        {
            Id = Guid.NewGuid(),
            Name = name?.Trim(),
            Email = email?.Trim().ToLowerInvariant(),
            CreatedAt = DateTime.UtcNow,
            SchemaVersion = CurrentSchemaVersion
        };
    }

    /// <summary>
    /// Validates email format using regex.
    /// </summary>
    public static bool IsValidEmail(string? email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return true; // Empty is valid (optional field)

        // RFC 5322 simplified pattern
        const string pattern = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";
        return Regex.IsMatch(email, pattern, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Migrates identity from older schema version if needed.
    /// </summary>
    public static UserIdentity Migrate(UserIdentity old)
    {
        if (old.SchemaVersion >= CurrentSchemaVersion)
            return old;

        // Future migrations go here
        // if (old.SchemaVersion < 2) { ... migrate to v2 ... }

        return old with { SchemaVersion = CurrentSchemaVersion };
    }
}
```

**Why Schema Versioning?**
- The identity file format may need to change in future versions
- Including a version number enables automatic migration without breaking existing users
- Example: Adding a `preferences` field in v2 would require migrating v1 files

---

### Step 2: Create Validation Helper

> **IMPLEMENTED NOTE:** ValidationResult.cs already existed with a better implementation (uses ValidationError objects instead of strings). We created RegistrationValidator.cs as a separate file instead.

**Create**: `frontend/ProjectManagement.Core/Validation/RegistrationValidator.cs`

```csharp
namespace ProjectManagement.Core.Validation;

/// <summary>
/// Result of a validation operation.
/// </summary>
public sealed record ValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<string> Errors { get; init; } = Array.Empty<string>();

    public static ValidationResult Success() => new() { IsValid = true };

    public static ValidationResult Failure(params string[] errors) => new()
    {
        IsValid = false,
        Errors = errors
    };

    public static ValidationResult Failure(IEnumerable<string> errors) => new()
    {
        IsValid = false,
        Errors = errors.ToList()
    };
}

/// <summary>
/// Validates user registration input.
/// </summary>
public static class RegistrationValidator
{
    public const int MaxNameLength = 100;
    public const int MaxEmailLength = 254; // RFC 5321

    public static ValidationResult Validate(string? name, string? email)
    {
        var errors = new List<string>();

        if (!string.IsNullOrWhiteSpace(name) && name.Length > MaxNameLength)
        {
            errors.Add($"Name cannot exceed {MaxNameLength} characters");
        }

        if (!string.IsNullOrWhiteSpace(email))
        {
            if (email.Length > MaxEmailLength)
            {
                errors.Add($"Email cannot exceed {MaxEmailLength} characters");
            }
            else if (!UserIdentity.IsValidEmail(email))
            {
                errors.Add("Please enter a valid email address");
            }
        }

        return errors.Count == 0
            ? ValidationResult.Success()
            : ValidationResult.Failure(errors);
    }
}
```

**Why Centralized Validation?**
- Validation logic is reused across UI and service layers
- Error messages are consistent throughout the app
- Easy to add new validation rules in one place

---

### Step 3: Create Identity Error Type

> **IMPORTANT**: The crate already has production-grade error handling in `server/error.rs`.
> We MUST follow the same pattern: `thiserror` + `error_location` for stack traces,
> structured variants with context, `is_transient()` for retry logic, and `recovery_hint()`
> for user-friendly messages. No lame `Result<T, String>` shortcuts!

**Create**: `desktop/src-tauri/src/identity/error.rs`

Following the existing `ServerError` pattern with `thiserror` and `error_location`:

```rust
use std::panic::Location;
use std::path::PathBuf;

use error_location::ErrorLocation;
use thiserror::Error;

/// Errors related to user identity management.
#[derive(Error, Debug)]
pub enum IdentityError {
    #[error("Failed to get app data directory: {message} {location}")]
    AppDataDir {
        message: String,
        location: ErrorLocation,
    },

    #[error("Failed to create directory at {path}: {source} {location}")]
    DirCreation {
        path: PathBuf,
        #[source]
        source: std::io::Error,
        location: ErrorLocation,
    },

    #[error("Failed to read identity file at {path}: {source} {location}")]
    FileRead {
        path: PathBuf,
        #[source]
        source: std::io::Error,
        location: ErrorLocation,
    },

    #[error("Failed to write identity file at {path}: {source} {location}")]
    FileWrite {
        path: PathBuf,
        #[source]
        source: std::io::Error,
        location: ErrorLocation,
    },

    #[error("Identity file corrupted at {path}: {message} {location}")]
    Corrupted {
        path: PathBuf,
        message: String,
        location: ErrorLocation,
    },

    #[error("Failed to serialize identity: {source} {location}")]
    Serialization {
        #[source]
        source: serde_json::Error,
        location: ErrorLocation,
    },

    #[error("Atomic rename failed from {from} to {to}: {source} {location}")]
    AtomicRename {
        from: PathBuf,
        to: PathBuf,
        #[source]
        source: std::io::Error,
        location: ErrorLocation,
    },

    #[error("Failed to backup corrupted file: {source} {location}")]
    BackupFailed {
        #[source]
        source: std::io::Error,
        location: ErrorLocation,
    },
}

impl IdentityError {
    /// Whether this error is recoverable via retry.
    pub fn is_transient(&self) -> bool {
        matches!(
            self,
            Self::FileRead { .. } | Self::FileWrite { .. } | Self::AtomicRename { .. }
        )
    }

    /// User-friendly recovery hint.
    pub fn recovery_hint(&self) -> &'static str {
        match self {
            Self::AppDataDir { .. } => {
                "Unable to locate application data directory. \
                 Try restarting the application or reinstalling."
            }
            Self::DirCreation { .. } | Self::FileWrite { .. } => {
                "Unable to write to application data directory. \
                 Check disk space and file permissions."
            }
            Self::FileRead { .. } => {
                "Unable to read identity file. \
                 The file may be locked by another process."
            }
            Self::Corrupted { .. } => {
                "Your identity file is corrupted. \
                 A backup will be created and you'll need to re-register."
            }
            Self::Serialization { .. } => {
                "Internal error preparing identity data. \
                 Please report this issue."
            }
            Self::AtomicRename { .. } => {
                "Unable to save identity file safely. \
                 Check disk space and try again."
            }
            Self::BackupFailed { .. } => {
                "Unable to backup corrupted file. \
                 Check file permissions in the application directory."
            }
        }
    }

    /// Creates AppDataDir error at caller location.
    #[track_caller]
    pub fn app_data_dir(message: impl Into<String>) -> Self {
        Self::AppDataDir {
            message: message.into(),
            location: ErrorLocation::from(Location::caller()),
        }
    }

    /// Creates Corrupted error at caller location.
    #[track_caller]
    pub fn corrupted(path: PathBuf, message: impl Into<String>) -> Self {
        Self::Corrupted {
            path,
            message: message.into(),
            location: ErrorLocation::from(Location::caller()),
        }
    }

    /// Creates DirCreation error at caller location.
    #[track_caller]
    pub fn dir_creation(path: PathBuf, source: std::io::Error) -> Self {
        Self::DirCreation {
            path,
            source,
            location: ErrorLocation::from(Location::caller()),
        }
    }

    /// Creates FileRead error at caller location.
    #[track_caller]
    pub fn file_read(path: PathBuf, source: std::io::Error) -> Self {
        Self::FileRead {
            path,
            source,
            location: ErrorLocation::from(Location::caller()),
        }
    }

    /// Creates FileWrite error at caller location.
    #[track_caller]
    pub fn file_write(path: PathBuf, source: std::io::Error) -> Self {
        Self::FileWrite {
            path,
            source,
            location: ErrorLocation::from(Location::caller()),
        }
    }

    /// Creates AtomicRename error at caller location.
    #[track_caller]
    pub fn atomic_rename(from: PathBuf, to: PathBuf, source: std::io::Error) -> Self {
        Self::AtomicRename {
            from,
            to,
            source,
            location: ErrorLocation::from(Location::caller()),
        }
    }
}

impl From<serde_json::Error> for IdentityError {
    #[track_caller]
    fn from(source: serde_json::Error) -> Self {
        Self::Serialization {
            source,
            location: ErrorLocation::from(Location::caller()),
        }
    }
}

pub type Result<T> = std::result::Result<T, IdentityError>;
```

**Why This Pattern?**
- **Structured errors**: Each variant captures specific context (path, source error)
- **Error location**: `#[track_caller]` + `ErrorLocation` shows WHERE the error originated
- **Recovery hints**: User-friendly messages for each error type
- **Transient detection**: `is_transient()` enables intelligent retry logic

---

### Step 4: Create Identity Module

> **IMPLEMENTED NOTE:** Identity module was refactored into 4 separate files for better organization:
> - `error.rs` - Error types only
> - `load_result.rs` - LoadResult type only
> - `user_identity.rs` - UserIdentity struct only
> - `mod.rs` - Functions (load, save, backup_corrupted)

**Create**: `desktop/src-tauri/src/identity/` (module with 4 files)

```rust
mod error;

pub use error::{IdentityError, Result};

use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use tauri::Manager;
use tracing::{info, warn};
use uuid::Uuid;

/// Persistent user identity stored locally.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserIdentity {
    pub id: Uuid,
    pub name: Option<String>,
    pub email: Option<String>,
    pub created_at: String,
    pub schema_version: i32,
}

/// Result of loading identity - distinguishes "not found" from errors.
#[derive(Debug, Serialize)]
pub struct LoadResult {
    pub user: Option<UserIdentity>,
    /// Present if file exists but is corrupted
    pub corruption_error: Option<String>,
}

/// Gets the user identity file path.
fn get_identity_path(app: &tauri::AppHandle) -> Result<PathBuf> {
    app.path()
        .app_data_dir()
        .map(|p| p.join("user.json"))
        .map_err(|e| IdentityError::app_data_dir(e.to_string()))
}

/// Loads user identity from app data directory.
///
/// Returns:
/// - `Ok(LoadResult { user: Some(...), corruption_error: None })` - loaded successfully
/// - `Ok(LoadResult { user: None, corruption_error: None })` - file doesn't exist (first launch)
/// - `Ok(LoadResult { user: None, corruption_error: Some(...) })` - file exists but corrupted
pub fn load(app: &tauri::AppHandle) -> Result<LoadResult> {
    let path = get_identity_path(app)?;

    if !path.exists() {
        info!("No identity file at {:?} (first launch)", path);
        return Ok(LoadResult {
            user: None,
            corruption_error: None,
        });
    }

    let contents = fs::read_to_string(&path)
        .map_err(|e| IdentityError::file_read(path.clone(), e))?;

    match serde_json::from_str::<UserIdentity>(&contents) {
        Ok(user) => {
            info!("Loaded identity: {} (schema v{})", user.id, user.schema_version);
            Ok(LoadResult {
                user: Some(user),
                corruption_error: None,
            })
        }
        Err(e) => {
            warn!("Identity file corrupted at {:?}: {}", path, e);
            Ok(LoadResult {
                user: None,
                corruption_error: Some(e.to_string()),
            })
        }
    }
}

/// Saves user identity using atomic write pattern.
///
/// 1. Writes to temp file
/// 2. Syncs to disk (fsync)
/// 3. Atomic rename to final location
///
/// This prevents corruption if the app crashes mid-write.
pub fn save(app: &tauri::AppHandle, user: &UserIdentity) -> Result<()> {
    let app_data = app
        .path()
        .app_data_dir()
        .map_err(|e| IdentityError::app_data_dir(e.to_string()))?;

    // Ensure directory exists
    fs::create_dir_all(&app_data)
        .map_err(|e| IdentityError::dir_creation(app_data.clone(), e))?;

    let final_path = app_data.join("user.json");
    let temp_path = app_data.join(format!("user.json.tmp.{}", std::process::id()));

    // Serialize with pretty printing for debuggability
    let json = serde_json::to_string_pretty(user)?;

    // Write to temp file with explicit sync
    {
        let mut file = fs::File::create(&temp_path)
            .map_err(|e| IdentityError::file_write(temp_path.clone(), e))?;

        file.write_all(json.as_bytes())
            .map_err(|e| IdentityError::file_write(temp_path.clone(), e))?;

        file.sync_all()
            .map_err(|e| IdentityError::file_write(temp_path.clone(), e))?;
    }

    // Atomic rename
    fs::rename(&temp_path, &final_path).map_err(|e| {
        // Clean up temp file on failure
        let _ = fs::remove_file(&temp_path);
        IdentityError::atomic_rename(temp_path, final_path.clone(), e)
    })?;

    info!("Saved identity: {}", user.id);
    Ok(())
}

/// Backs up corrupted identity file for debugging.
///
/// Renames `user.json` to `user.json.corrupted.{timestamp}`.
pub fn backup_corrupted(app: &tauri::AppHandle) -> Result<Option<PathBuf>> {
    let path = get_identity_path(app)?;

    if !path.exists() {
        return Ok(None);
    }

    let app_data = path.parent().unwrap();
    let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
    let backup_path = app_data.join(format!("user.json.corrupted.{}", timestamp));

    fs::rename(&path, &backup_path).map_err(|e| IdentityError::BackupFailed {
        source: e,
        location: error_location::ErrorLocation::from(std::panic::Location::caller()),
    })?;

    warn!("Backed up corrupted identity to {:?}", backup_path);
    Ok(Some(backup_path))
}
```

> **NO INLINE TESTS!** Tests go in `src/tests/` module - see Step 7.

---

### Step 5: Add Tauri Commands Using the Module

**File**: `desktop/src-tauri/src/commands.rs`

Add identity commands that delegate to the module:

```rust
use crate::identity::{self, LoadResult, UserIdentity};

/// Loads user identity from app data directory.
#[tauri::command]
pub async fn load_user_identity(app: tauri::AppHandle) -> Result<LoadResult, String> {
    identity::load(&app).map_err(|e| {
        // Log full error with location for debugging
        tracing::error!("Failed to load identity: {}", e);
        // Return user-friendly message
        format!("{}\n\nHint: {}", e, e.recovery_hint())
    })
}

/// Saves user identity using atomic write pattern.
#[tauri::command]
pub async fn save_user_identity(
    app: tauri::AppHandle,
    user: UserIdentity,
) -> Result<(), String> {
    identity::save(&app, &user).map_err(|e| {
        tracing::error!("Failed to save identity: {}", e);
        format!("{}\n\nHint: {}", e, e.recovery_hint())
    })
}

/// Backs up corrupted user.json for debugging.
#[tauri::command]
pub async fn backup_corrupted_user_identity(app: tauri::AppHandle) -> Result<(), String> {
    identity::backup_corrupted(&app)
        .map(|_| ())
        .map_err(|e| {
            tracing::error!("Failed to backup corrupted identity: {}", e);
            format!("{}\n\nHint: {}", e, e.recovery_hint())
        })
}
```

**Why This Structure?**
- **Separation of concerns**: Pure logic in `identity/mod.rs`, Tauri glue in `commands.rs`
- **Testable**: The `identity` module can be unit tested without Tauri
- **Consistent error handling**: Commands convert `IdentityError` to user-friendly strings
- **Full context in logs**: `tracing::error!` captures the full error chain with locations

---

### Step 6: Update lib.rs

**File**: `desktop/src-tauri/src/lib.rs`

Add module declaration:

```rust
mod identity;  // NEW

// ... existing code ...
```

**Why Atomic Writes?**
- Writing directly to `user.json` risks corruption if the app crashes mid-write
- Write to temp file first, sync to disk, then rename
- Rename is atomic on most filesystems - either succeeds completely or fails

---

### Step 4: Register Tauri Commands

**File**: `desktop/src-tauri/src/lib.rs`

Add the new commands to the invoke_handler:

```rust
.invoke_handler(tauri::generate_handler![
    commands::get_server_status,
    commands::get_websocket_url,
    commands::load_user_identity,      // NEW
    commands::save_user_identity,      // NEW
    commands::backup_corrupted_user_identity,  // NEW
    commands::restart_server,
    commands::export_diagnostics,
])
```

---

### Step 5: Backend Security Validation

> **IMPLEMENTED NOTE:** Used existing `WsError` type instead of creating custom `ConnectionError` enum. This maintains consistency with the rest of the pm-ws crate and includes ErrorLocation tracking.

**Create**: `backend/crates/pm-ws/src/handlers/connection.rs`

```rust
use crate::{Result as WsResult, WsError};

use std::collections::HashMap;
use std::env;
use std::panic::Location;

use error_location::ErrorLocation;
use pm_auth::Claims;
use tracing::{error, warn};
use uuid::Uuid;

/// Extracts user identity from WebSocket connection.
/// - When auth disabled (desktop mode): Accepts user_id from query params
/// - When auth enabled (web mode): REJECTS user_id param, requires JWT
pub fn extract_user_id(
    query_params: &HashMap<String, String>,
    jwt_claims: Option<&JwtClaims>,
) -> Result<Uuid, ConnectionError> {
    let auth_enabled = env::var("PM_AUTH_ENABLED")
        .map(|v| v.to_lowercase() == "true")
        .unwrap_or(false);

    // SECURITY: Reject user_id param when auth is enabled
    if auth_enabled && query_params.contains_key("user_id") {
        error!("Attempted user_id bypass with auth enabled");
        return Err(ConnectionError::SecurityViolation(
            "user_id parameter not allowed when authentication is enabled".into()
        ));
    }

    // Auth enabled: require valid JWT
    if auth_enabled {
        return jwt_claims
            .map(|c| c.user_id)
            .ok_or_else(|| ConnectionError::Unauthorized("Valid JWT required".into()));
    }

    // Auth disabled (desktop mode): use user_id from query params
    if let Some(id_str) = query_params.get("user_id") {
        Uuid::parse_str(id_str)
            .map_err(|_| ConnectionError::InvalidUserId(id_str.clone()))
    } else {
        // Fallback for legacy clients - generate session ID
        warn!("No user_id provided in desktop mode, generating session ID");
        Ok(Uuid::new_v4())
    }
}
```

> **NO INLINE TESTS!** Tests for `pm-ws` go in `src/tests/` - see existing pattern in that crate.

**Why This Security Model?**
- Desktop mode: Single user, no authentication needed, trust the local app
- Web mode: Multi-user, authentication required, NEVER trust client-provided user_id
- The `PM_AUTH_ENABLED` flag controls which mode is active
- Rejecting user_id when auth enabled prevents impersonation attacks

---

### Step 7: Add Unit Tests (Proper Structure)

> **IMPORTANT**: Follow the existing test pattern in `pm-ws`:
> - Unit tests go in `src/tests/` module (can access crate internals)
> - Integration tests go in `tests/` directory (only public API)
> - NO inline `#[cfg(test)] mod tests {}` blocks in source files

**Create**: `desktop/src-tauri/src/tests/mod.rs`

```rust
mod identity;
```

**Create**: `desktop/src-tauri/src/tests/identity.rs`

```rust
//! Unit tests for identity module.
//!
//! These tests can access crate internals via `use crate::`.

use crate::identity::{IdentityError, LoadResult, UserIdentity};
use std::path::PathBuf;
use tempfile::TempDir;

// =============================================================================
// IdentityError Tests
// =============================================================================

#[test]
fn given_file_read_error_when_is_transient_then_returns_true() {
    let err = IdentityError::file_read(
        PathBuf::from("/test"),
        std::io::Error::new(std::io::ErrorKind::Other, "test"),
    );
    assert!(err.is_transient());
}

#[test]
fn given_corrupted_error_when_is_transient_then_returns_false() {
    let err = IdentityError::corrupted(PathBuf::from("/test"), "bad json");
    assert!(!err.is_transient());
}

#[test]
fn given_any_error_when_recovery_hint_then_returns_non_empty_string() {
    let errors = vec![
        IdentityError::app_data_dir("test"),
        IdentityError::corrupted(PathBuf::from("/test"), "bad"),
        IdentityError::file_read(
            PathBuf::from("/test"),
            std::io::Error::new(std::io::ErrorKind::Other, "test"),
        ),
    ];

    for err in errors {
        let hint = err.recovery_hint();
        assert!(!hint.is_empty(), "recovery_hint should not be empty for {:?}", err);
    }
}

// =============================================================================
// UserIdentity Tests
// =============================================================================

#[test]
fn given_valid_data_when_serialize_roundtrip_then_preserves_all_fields() {
    let original = UserIdentity {
        id: uuid::Uuid::new_v4(),
        name: Some("Test User".into()),
        email: Some("test@example.com".into()),
        created_at: "2024-01-01T00:00:00Z".into(),
        schema_version: 1,
    };

    let json = serde_json::to_string(&original).unwrap();
    let restored: UserIdentity = serde_json::from_str(&json).unwrap();

    assert_eq!(original.id, restored.id);
    assert_eq!(original.name, restored.name);
    assert_eq!(original.email, restored.email);
    assert_eq!(original.schema_version, restored.schema_version);
}

#[test]
fn given_missing_optional_fields_when_deserialize_then_defaults_to_none() {
    let json = r#"{"id":"550e8400-e29b-41d4-a716-446655440000","created_at":"2024-01-01T00:00:00Z","schema_version":1}"#;
    let user: UserIdentity = serde_json::from_str(json).unwrap();

    assert!(user.name.is_none());
    assert!(user.email.is_none());
}
```

**Update**: `desktop/src-tauri/src/lib.rs`

Add at the bottom of the file:

```rust
#[cfg(test)]
mod tests;
```

---

**Create**: `backend/crates/pm-ws/src/tests/connection.rs`

> **IMPLEMENTED NOTE:** Tests use RAII EnvGuard pattern (found in pm-config/src/tests/mod.rs) with serial_test crate to ensure environment variables are properly cleaned up even on panic.

Add tests for the connection security logic:

```rust
//! Unit tests for connection handling.

use crate::handlers::connection::extract_user_id;
use crate::WsError;

use std::collections::HashMap;
use std::env;

use pm_auth::Claims;
use serial_test::serial;
use uuid::Uuid;

/// RAII guard for environment variables - automatically restores on drop
struct EnvGuard {
    key: &'static str,
    original: Option<String>,
}

impl EnvGuard {
    fn set(key: &'static str, value: &str) -> Self {
        let original = env::var(key).ok();
        env::set_var(key, value);
        Self { key, original }
    }
}

impl Drop for EnvGuard {
    fn drop(&mut self) {
        match &self.original {
            Some(val) => env::set_var(self.key, val),
            None => env::remove_var(self.key),
        }
    }
}

#[test]
#[serial]
fn given_auth_enabled_and_user_id_param_when_extract_then_unauthorized() {
    let _guard = EnvGuard::set("PM_AUTH_ENABLED", "true");

    let mut params = HashMap::new();
    params.insert("user_id".into(), Uuid::new_v4().to_string());

    let result = extract_user_id(&params, None);
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), WsError::Unauthorized { .. }));
}

#[test]
fn given_auth_disabled_and_valid_user_id_when_extract_then_returns_uuid() {
    std::env::set_var("PM_AUTH_ENABLED", "false");

    let user_id = Uuid::new_v4();
    let mut params = HashMap::new();
    params.insert("user_id".into(), user_id.to_string());

    let result = extract_user_id(&params, None);
    assert_eq!(result.unwrap(), user_id);

    std::env::remove_var("PM_AUTH_ENABLED");
}

#[test]
fn given_auth_disabled_and_no_user_id_when_extract_then_generates_new_uuid() {
    std::env::set_var("PM_AUTH_ENABLED", "false");

    let params = HashMap::new();
    let result = extract_user_id(&params, None);

    assert!(result.is_ok());
    assert_ne!(result.unwrap(), Uuid::nil());

    std::env::remove_var("PM_AUTH_ENABLED");
}

#[test]
fn given_auth_disabled_and_invalid_uuid_when_extract_then_invalid_user_id_error() {
    std::env::set_var("PM_AUTH_ENABLED", "false");

    let mut params = HashMap::new();
    params.insert("user_id".into(), "not-a-valid-uuid".into());

    let result = extract_user_id(&params, None);
    assert!(matches!(result, Err(ConnectionError::InvalidUserId(_))));

    std::env::remove_var("PM_AUTH_ENABLED");
}
```

**Update**: `backend/crates/pm-ws/src/tests/mod.rs`

Add module declaration:

```rust
mod connection;  // NEW
```

---

## Session 42.1 Completion Checklist

**Status: âœ… COMPLETE**

After completing all steps:

- [x] `dotnet build frontend/ProjectManagement.sln` passes (0 warnings, 0 errors)
- [x] `cargo check -p pm-ws` passes
- [x] `cd desktop && cargo check` passes (with non-blocking warnings)
- [x] `cd desktop && cargo test` passes (all 203 tests)
- [x] `cd desktop && cargo tauri build --debug` - Skipped (not required for this session)

### Files Created (10)

**Frontend (C#):**
- `frontend/ProjectManagement.Core/Models/UserIdentity.cs` - Identity model with schema versioning
- `frontend/ProjectManagement.Core/Validation/RegistrationValidator.cs` - Validation logic
  - **Note:** ValidationResult.cs already existed with better implementation, so we created RegistrationValidator separately

**Desktop (Rust):**
- `desktop/src-tauri/src/identity/error.rs` - Production-grade error types
- `desktop/src-tauri/src/identity/load_result.rs` - Three-state load result
- `desktop/src-tauri/src/identity/user_identity.rs` - Rust identity struct
- `desktop/src-tauri/src/identity/mod.rs` - Load/save/backup with atomic writes
  - **Note:** Split into 4 files for better organization (plan showed monolithic mod.rs)
- `desktop/src-tauri/src/tests/mod.rs` - Test module declaration
- `desktop/src-tauri/src/tests/identity.rs` - 10 unit tests (error handling + serialization)

**Backend (Rust):**
- `backend/crates/pm-ws/src/handlers/connection.rs` - Security validation with WsError
  - **Note:** Used existing WsError type instead of custom ConnectionError enum
- `backend/crates/pm-ws/src/tests/connection.rs` - 8 unit tests with RAII EnvGuard pattern
  - **Note:** Followed existing pm-config test pattern with serial_test crate

### Files Modified (4)
- `desktop/src-tauri/src/commands.rs` - Added 3 identity commands (load, save, backup)
- `desktop/src-tauri/src/lib.rs` - Registered commands in invoke_handler, added `mod identity;`
- `backend/crates/pm-ws/src/handlers/mod.rs` - Exported `pub(crate) mod connection;`
- `backend/crates/pm-ws/src/tests/mod.rs` - Added `mod connection;`

---

## Key Concepts Learned

1. **Schema Versioning** - Include version numbers in persisted data for future migrations
2. **Atomic Writes** - Write to temp file, then rename to prevent corruption
3. **Centralized Validation** - Keep validation logic in one place for consistency
4. **Security Modes** - Different authentication strategies for desktop vs web
5. **Structured Error Types** - Use `thiserror` + `error_location` for rich error context
6. **Recovery Hints** - User-friendly messages separate from technical error details
7. **Transient Detection** - `is_transient()` enables intelligent retry logic
8. **Module Separation** - Pure logic in module, Tauri glue in commands (testability)
9. **Test Organization** - Unit tests in `src/tests/`, integration tests in `tests/`, NO inline test blocks

---

---

## Implementation Notes (Actual vs Planned)

This section documents adaptations made during implementation:

### 1. ValidationResult Already Existed
**Plan:** Create ValidationResult.cs with `IReadOnlyList<string>` for errors
**Reality:** ValidationResult.cs already existed with better design (uses `ValidationError` objects)
**Adaptation:** Created `RegistrationValidator.cs` separately, used existing ValidationResult

### 2. Identity Module Refactored
**Plan:** Single `identity/mod.rs` file (~150 lines)
**Reality:** Split into 4 focused files for better maintainability
**Benefit:** Easier to navigate, follows single-responsibility principle

### 3. Backend Used Existing Error Type
**Plan:** Create custom `ConnectionError` enum
**Reality:** Used existing `WsError` type from pm-ws crate
**Benefit:** Maintains consistency, includes ErrorLocation tracking, integrates with existing error handling

### 4. Tests Use RAII Pattern
**Plan:** Manual env var cleanup with `set_var()` and `remove_var()`
**Reality:** Used EnvGuard struct with Drop trait + serial_test crate
**Benefit:** Panic-safe cleanup, prevents test interference, follows existing pm-config pattern

### 5. Test Count Higher Than Expected
**Plan:** ~6-8 tests
**Reality:** 18 tests (10 identity + 8 connection)
**Benefit:** Added happy path tests for serialization, more comprehensive coverage

---

## Session Statistics

- **Token Usage:** ~88k tokens (vs estimated 35-40k)
- **Duration:** ~2 hours
- **Files Created:** 10 (vs planned 8)
- **Files Modified:** 4 (vs planned 3)
- **Tests Added:** 18 (10 desktop identity + 8 backend connection)
- **Total Tests Passing:** 203 (entire workspace)
- **Code Quality Issues Caught:** 3 (ValidationError structure, error handling pattern, RAII pattern)

---

## Next Session

**Session 42.2** will implement:
- UserIdentityService with retry logic and thread safety
- AppStartupState state machine
- AppState user context
- WebSocketClient user_id parameter
