# Session 42.2: Identity Service & App State Machine

**Parent Plan**: `42-Session-Plan-Overview.md`
**Prerequisite**: Session 42.1 completed
**Target**: ~40-45k tokens

---

## Teaching Focus

This session teaches:
- **Service architecture** with dependency injection
- **Retry patterns** with exponential backoff
- **State machines** for explicit application flow
- **Thread safety** with SemaphoreSlim
- **IAsyncDisposable** for resource cleanup

---

## Scope

1. **UserIdentityService** - Load/save identity with retry logic
2. **AppStartupState** - State machine for startup flow
3. **AppState Extensions** - Add user context and connection callbacks
4. **WebSocketClient Updates** - Pass user_id in query params

---

## Prerequisites Check

Before starting, verify Session 42.1 is complete:

```bash
dotnet build frontend/ProjectManagement.sln
ls frontend/ProjectManagement.Core/Models/UserIdentity.cs
ls frontend/ProjectManagement.Core/Validation/ValidationResult.cs
```

---

## Implementation Order

### Step 1: Create User Identity Service with Retry Logic

**Create**: `frontend/ProjectManagement.Services/Desktop/UserIdentityService.cs`

```csharp
using System.Text.Json;
using Microsoft.Extensions.Logging;
using Microsoft.JSInterop;
using ProjectManagement.Core.Models;

namespace ProjectManagement.Services.Desktop;

/// <summary>
/// Manages persistent user identity for desktop mode.
/// Uses Tauri's file system API for cross-platform storage.
/// </summary>
public sealed class UserIdentityService : IAsyncDisposable
{
    private readonly IJSRuntime _js;
    private readonly ILogger<UserIdentityService> _logger;
    private UserIdentity? _cachedIdentity;
    private bool _disposed;
    private readonly SemaphoreSlim _lock = new(1, 1);

    // Retry configuration
    private const int MaxRetries = 3;
    private const int RetryDelayInitialMs = 100;
    private const int RetryDelayMediumMs = 500;
    private const int RetryDelayMaxMs = 1000;
    private static readonly TimeSpan[] RetryDelays = {
        TimeSpan.FromMilliseconds(RetryDelayInitialMs),
        TimeSpan.FromMilliseconds(RetryDelayMediumMs),
        TimeSpan.FromMilliseconds(RetryDelayMaxMs)
    };

    // Tauri command names
    private const string TauriCommandLoadIdentity = "load_user_identity";
    private const string TauriCommandSaveIdentity = "save_user_identity";
    private const string TauriCommandBackupCorrupted = "backup_corrupted_user_identity";
    private const string TauriInvokePath = "__TAURI__.core.invoke";

    public UserIdentityService(IJSRuntime js, ILogger<UserIdentityService> logger)
    {
        _js = js ?? throw new ArgumentNullException(nameof(js));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Gets the current user identity, loading from disk if not cached.
    /// Thread-safe with lock to prevent concurrent loads.
    /// </summary>
    public async Task<UserIdentity?> GetCurrentUserAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (_cachedIdentity != null)
            return _cachedIdentity;

        await _lock.WaitAsync(ct);
        try
        {
            // Double-check after acquiring lock
            if (_cachedIdentity != null)
                return _cachedIdentity;

            return await LoadExistingUserAsync(ct);
        }
        finally
        {
            _lock.Release();
        }
    }

    /// <summary>
    /// Loads existing user identity from persistent storage with retry logic.
    /// Returns null if file doesn't exist.
    /// Attempts recovery if file is corrupted.
    /// </summary>
    public async Task<UserIdentity?> LoadExistingUserAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();

        Exception? lastException = null;

        for (int attempt = 0; attempt <= MaxRetries; attempt++)
        {
            try
            {
                if (attempt > 0)
                {
                    var delay = RetryDelays[Math.Min(attempt - 1, RetryDelays.Length - 1)];
                    _logger.LogDebug("Retry attempt {Attempt} after {Delay}ms", attempt, delay.TotalMilliseconds);
                    await Task.Delay(delay, ct);
                }

                var result = await _js.InvokeAsync<UserIdentityResult>(
                    TauriInvokePath,
                    ct,
                    TauriCommandLoadIdentity
                );

                if (result == null)
                {
                    _logger.LogWarning("Null result from load_user_identity");
                    continue;
                }

                if (!string.IsNullOrEmpty(result.Error))
                {
                    _logger.LogWarning("Error from Tauri: {Error}", result.Error);
                    return await HandleCorruptedFileAsync(ct);
                }

                if (result.User == null)
                {
                    _logger.LogInformation("No existing user identity found (first launch)");
                    return null;
                }

                // Migrate if needed
                var user = UserIdentity.Migrate(result.User);
                if (user.SchemaVersion != result.User.SchemaVersion)
                {
                    _logger.LogInformation("Migrated user from v{Old} to v{New}",
                        result.User.SchemaVersion, user.SchemaVersion);
                    await SaveUserInternalAsync(user, ct);
                }

                _cachedIdentity = user;
                _logger.LogInformation("Loaded existing user: {UserId}", _cachedIdentity.Id);
                return _cachedIdentity;
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (JsonException ex)
            {
                _logger.LogWarning(ex, "Corrupted user.json detected");
                return await HandleCorruptedFileAsync(ct);
            }
            catch (JSException ex) when (attempt < MaxRetries)
            {
                lastException = ex;
                _logger.LogWarning(ex, "JS interop failed, attempt {Attempt}/{MaxRetries}",
                    attempt + 1, MaxRetries + 1);
            }
            catch (Exception ex)
            {
                lastException = ex;
                _logger.LogError(ex, "Unexpected error loading user identity");
                break;
            }
        }

        _logger.LogError(lastException, "Failed to load user identity after {MaxRetries} retries", MaxRetries);
        return null;
    }

    /// <summary>
    /// Creates a new user identity and persists it.
    /// Thread-safe - prevents concurrent creation.
    /// </summary>
    public async Task<UserIdentity> CreateNewUserAsync(
        string? name,
        string? email,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();

        await _lock.WaitAsync(ct);
        try
        {
            // Validate input
            var validation = Core.Validation.RegistrationValidator.Validate(name, email);
            if (!validation.IsValid)
            {
                throw new ArgumentException(string.Join("; ", validation.Errors));
            }

            var user = UserIdentity.Create(name, email);
            await SaveUserInternalAsync(user, ct);
            _cachedIdentity = user;

            _logger.LogInformation("Created new user identity: {UserId}", user.Id);
            return user;
        }
        finally
        {
            _lock.Release();
        }
    }

    /// <summary>
    /// Persists user identity using atomic write pattern with retry.
    /// </summary>
    private async Task SaveUserInternalAsync(UserIdentity user, CancellationToken ct)
    {
        Exception? lastException = null;

        for (int attempt = 0; attempt <= MaxRetries; attempt++)
        {
            try
            {
                if (attempt > 0)
                {
                    var delay = RetryDelays[Math.Min(attempt - 1, RetryDelays.Length - 1)];
                    await Task.Delay(delay, ct);
                }

                await _js.InvokeVoidAsync(
                    TauriInvokePath,
                    ct,
                    TauriCommandSaveIdentity,
                    new { user }
                );

                _logger.LogDebug("User identity saved successfully");
                return;
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (JSException ex) when (attempt < MaxRetries)
            {
                lastException = ex;
                _logger.LogWarning(ex, "Save failed, attempt {Attempt}/{MaxRetries}",
                    attempt + 1, MaxRetries + 1);
            }
        }

        _logger.LogError(lastException, "Failed to save user identity");
        throw new InvalidOperationException("Could not persist user identity", lastException);
    }

    /// <summary>
    /// Handles corrupted user.json by backing up and forcing re-registration.
    /// </summary>
    private async Task<UserIdentity?> HandleCorruptedFileAsync(CancellationToken ct)
    {
        try
        {
            await _js.InvokeVoidAsync(
                TauriInvokePath,
                ct,
                TauriCommandBackupCorrupted
            );

            _logger.LogWarning("Backed up corrupted user.json, user must re-register");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to backup corrupted file");
        }

        return null; // Force re-registration
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(UserIdentityService));
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        _cachedIdentity = null;
        _lock.Dispose();

        await ValueTask.CompletedTask;
    }
}

/// <summary>
/// Result wrapper for Tauri command response.
/// </summary>
internal sealed record UserIdentityResult
{
    public UserIdentity? User { get; init; }
    public string? Error { get; init; }
}
```

**Why Retry Logic?**
- Transient failures (disk busy, JS interop glitch) shouldn't crash the app
- Exponential backoff: 100ms → 500ms → 1s gives the system time to recover
- Max 3 retries balances reliability vs user wait time

**Why SemaphoreSlim?**
- Multiple Blazor components might call `GetCurrentUserAsync()` simultaneously
- Without locking, we could load the file multiple times
- SemaphoreSlim is async-aware, unlike regular `lock`

---

### Step 2: Create App Startup State Machine

**Create**: `frontend/ProjectManagement.Core/State/AppStartupState.cs`

```csharp
namespace ProjectManagement.Core.State;

/// <summary>
/// State machine for app startup flow.
/// Ensures proper sequencing: Identity → Server → WebSocket → UI
/// </summary>
public enum AppStartupState
{
    /// <summary>Initial state - checking if desktop mode</summary>
    Initializing,

    /// <summary>Desktop mode - waiting for server to start</summary>
    WaitingForServer,

    /// <summary>Server ready, checking for existing user identity</summary>
    CheckingIdentity,

    /// <summary>First launch - user must register</summary>
    NeedsRegistration,

    /// <summary>Identity loaded, connecting WebSocket</summary>
    ConnectingWebSocket,

    /// <summary>All systems ready - show main UI</summary>
    Ready,

    /// <summary>Recoverable error - show retry option</summary>
    Error,

    /// <summary>WebSocket disconnected - attempting reconnect</summary>
    Reconnecting
}

/// <summary>
/// Valid state transitions for the startup state machine.
/// </summary>
public static class AppStartupStateTransitions
{
    private static readonly Dictionary<AppStartupState, AppStartupState[]> ValidTransitions = new()
    {
        [AppStartupState.Initializing] = new[] {
            AppStartupState.WaitingForServer,
            AppStartupState.Ready, // Web mode
            AppStartupState.Error
        },
        [AppStartupState.WaitingForServer] = new[] {
            AppStartupState.CheckingIdentity,
            AppStartupState.Error
        },
        [AppStartupState.CheckingIdentity] = new[] {
            AppStartupState.NeedsRegistration,
            AppStartupState.ConnectingWebSocket,
            AppStartupState.Error
        },
        [AppStartupState.NeedsRegistration] = new[] {
            AppStartupState.ConnectingWebSocket,
            AppStartupState.Error
        },
        [AppStartupState.ConnectingWebSocket] = new[] {
            AppStartupState.Ready,
            AppStartupState.Error
        },
        [AppStartupState.Ready] = new[] {
            AppStartupState.Reconnecting,
            AppStartupState.Error
        },
        [AppStartupState.Reconnecting] = new[] {
            AppStartupState.Ready,
            AppStartupState.Error
        },
        [AppStartupState.Error] = new[] {
            AppStartupState.Initializing // Retry
        }
    };

    /// <summary>
    /// Validates if a state transition is allowed.
    /// </summary>
    public static bool CanTransition(AppStartupState from, AppStartupState to)
    {
        return ValidTransitions.TryGetValue(from, out var valid) && valid.Contains(to);
    }

    /// <summary>
    /// Transitions to new state, throwing if invalid.
    /// </summary>
    public static AppStartupState Transition(AppStartupState from, AppStartupState to)
    {
        if (!CanTransition(from, to))
        {
            throw new InvalidOperationException(
                $"Invalid state transition from {from} to {to}");
        }
        return to;
    }
}
```

**Why State Machine?**
- Explicit states prevent "impossible" UI situations (e.g., showing main UI while connecting)
- Transition validation catches bugs early
- Easy to add new states or change flow later
- Enables better error handling - each state knows what errors are possible

---

### Step 3: Update AppState with User Context

**File**: `frontend/ProjectManagement.Services/State/AppState.cs`

Add these members to the existing AppState class:

```csharp
private UserIdentity? _currentUser;
private readonly List<Action<ConnectionState>> _connectionStateCallbacks = new();

public UserIdentity? CurrentUser => _currentUser;

public void SetCurrentUser(UserIdentity user)
{
    _currentUser = user ?? throw new ArgumentNullException(nameof(user));
    _logger.LogInformation("AppState user set: {UserId}", user.Id);
}

public IDisposable SubscribeToConnectionStateChanged(Action<ConnectionState> callback)
{
    _connectionStateCallbacks.Add(callback);
    return new CallbackDisposable(() => _connectionStateCallbacks.Remove(callback));
}

// Note: Renamed from OnConnectionStateChanged to avoid conflict with existing event

private void NotifyConnectionStateChanged(ConnectionState state)
{
    foreach (var callback in _connectionStateCallbacks.ToList())
    {
        try
        {
            callback(state);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in connection state callback");
        }
    }
}

public async Task InitializeAsync(CancellationToken ct = default)
{
    if (_currentUser == null)
    {
        throw new InvalidOperationException(
            "CurrentUser must be set before InitializeAsync. Call SetCurrentUser() first.");
    }

    await _webSocketClient.ConnectAsync(_currentUser.Id, ct);
    // ... rest of initialization
}

private sealed class CallbackDisposable : IDisposable
{
    private readonly Action _onDispose;
    public CallbackDisposable(Action onDispose) => _onDispose = onDispose;
    public void Dispose() => _onDispose();
}
```

**Why Callback Pattern?**
- Components can subscribe to connection state without tight coupling
- Disposable return enables automatic cleanup when components unmount
- ToList() in notification loop prevents modification during iteration

---

### Step 4: Update WebSocketClient with User ID

**File**: `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

Add/modify the ConnectAsync method:

```csharp
using System.Web;

// Query parameter names
private const string QueryParamUserId = "user_id";
private const string QueryParamToken = "token";

/// <summary>
/// Connects to WebSocket server with explicit user identity.
/// </summary>
public async Task ConnectAsync(Guid userId, CancellationToken ct = default)
{
    if (userId == Guid.Empty)
    {
        throw new ArgumentException("User ID cannot be empty", nameof(userId));
    }

    // Build URI with user_id query parameter
    var uriBuilder = new UriBuilder(_options.ServerUrl);
    var query = HttpUtility.ParseQueryString(uriBuilder.Query);
    query[QueryParamUserId] = userId.ToString();

    if (!string.IsNullOrEmpty(_options.JwtToken))
    {
        query[QueryParamToken] = _options.JwtToken;
    }

    uriBuilder.Query = query.ToString();

    _logger.LogInformation("Connecting to WebSocket: {Uri}", uriBuilder.Uri);

    await _connection.ConnectAsync(uriBuilder.Uri, ct);
}
```

**Why Query Parameter?**
- Desktop mode doesn't use JWT authentication
- Server needs to know which user is connecting
- Query params work before WebSocket upgrade (unlike message-based auth)
- Backend security validation ensures this only works when auth is disabled

---

## Session 42.2 Completion Checklist

After completing all steps:

- [x] `dotnet build frontend/ProjectManagement.sln` passes
- [x] No compiler warnings
- [x] State transitions are well-defined
- [x] Service has proper disposal
- [x] All 364 tests pass

### Files Created (2)
- `frontend/ProjectManagement.Services/Desktop/UserIdentityService.cs`
- `frontend/ProjectManagement.Core/State/AppStartupState.cs`

### Files Modified (6)
- `frontend/ProjectManagement.Services/State/AppState.cs`
- `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`
- `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs` *(interface update)*
- `frontend/ProjectManagement.Services/Resilience/ResilientWebSocketClient.cs` *(wrapper update)*
- `frontend/ProjectManagement.Components.Tests/Pages/PageIntegrationTests.cs` *(test fixes)*
- `frontend/ProjectManagement.Wasm/Pages/Home.razor` *(cleanup)*

---

## Key Concepts Learned

1. **Retry with Exponential Backoff** - Start fast (100ms), slow down on failures
2. **State Machines** - Explicit states prevent invalid UI combinations
3. **Thread Safety** - SemaphoreSlim for async-aware locking
4. **IAsyncDisposable** - Proper cleanup for async resources
5. **Callback Subscriptions** - Loose coupling with automatic cleanup

---

---

## Session 42.2 Actual Implementation

**Status**: ✅ **COMPLETED**
**Actual Tokens Used**: ~78k tokens
**Actual Duration**: Educational teaching session with detailed explanations

### Implementation Notes

1. **Method Name Change**: The callback subscription method was renamed from `OnConnectionStateChanged` to `SubscribeToConnectionStateChanged` to avoid conflict with the existing event of the same name on line 105 of AppState.cs. This is a better design that makes the subscription pattern explicit.

2. **Additional Files Modified**: The plan correctly identified the core files, but interface-driven architecture required updating:
   - `IWebSocketClient.cs` - Added interface signature for new ConnectAsync overload
   - `ResilientWebSocketClient.cs` - Added pass-through implementation

3. **Test Fixes Required**: Component tests were failing because they mocked `IWorkItemStore.GetById()` when components actually used `IProjectStore.GetById()`. Fixed by:
   - Adding `CreateProjectViewModel()` helper method
   - Updating all 5 failing tests to mock the correct store
   - Adding test user setup with `SetCurrentUser()` call

4. **Cleanup**: Removed 7 diagnostic Console.WriteLine statements from Home.razor that were spamming test output.

### Files Actually Modified (6 total)

**Planned (2):**
- ✅ `frontend/ProjectManagement.Services/State/AppState.cs`
- ✅ `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

**Required by Interface Changes (2):**
- ✅ `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs`
- ✅ `frontend/ProjectManagement.Services/Resilience/ResilientWebSocketClient.cs`

**Test & Cleanup (2):**
- ✅ `frontend/ProjectManagement.Components.Tests/Pages/PageIntegrationTests.cs`
- ✅ `frontend/ProjectManagement.Wasm/Pages/Home.razor`

### Final Verification

- ✅ `dotnet build` passes with 0 warnings, 0 errors
- ✅ `dotnet test` passes all 364 tests (25 Core + 61 Services + 278 Components)
- ✅ State transitions well-defined with validation
- ✅ Service has proper IAsyncDisposable implementation
- ✅ Retry logic with exponential backoff implemented
- ✅ Thread safety with SemaphoreSlim verified

---

## Next Session

**Session 42.3** will implement:
- TauriService to replace desktop-interop.js
- DesktopConfigService for server lifecycle
- Delete JavaScript files
