# Session 42.5: Build Scripts, CI/CD & Testing

**Parent Plan**: `42-Session-Plan-Overview.md`
**Prerequisite**: Session 42.4 completed
**Target**: ~35-40k tokens

---

## Teaching Focus

This session teaches:
- **Cross-platform build automation** - Shell scripts for Unix and PowerShell for Windows
- **CI/CD best practices** - GitHub Actions matrix builds
- **Unit testing patterns** - Mocking, async testing, thread safety verification
- **Manual testing checklists** - Systematic verification process

---

## Scope

1. **Build Scripts** - dev.sh, dev.ps1, build.sh, build.ps1
2. **GitHub Actions** - Matrix build for macOS, Windows, Linux
3. **Unit Tests** - UserIdentityService, RegistrationValidator
4. **Manual Checklist** - TESTING.md for systematic verification

---

## Prerequisites Check

Before starting, verify Sessions 42.1-42.4 are complete:

```bash
dotnet build frontend/ProjectManagement.sln
cd desktop && cargo tauri build --debug
```

---

## Implementation Order

### Step 1: Create Development Build Script (Unix)

**Create**: `desktop/scripts/dev.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

# Development script for desktop app
# Usage: ./scripts/dev.sh [--frontend-only] [--backend-only]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

cd "$PROJECT_ROOT"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    if ! command -v rustc &> /dev/null; then
        log_error "Rust not found. Install from https://rustup.rs"
        exit 1
    fi

    if ! command -v cargo &> /dev/null; then
        log_error "Cargo not found. Install from https://rustup.rs"
        exit 1
    fi

    if ! command -v dotnet &> /dev/null; then
        log_error ".NET SDK not found. Install from https://dot.net"
        exit 1
    fi

    if ! command -v npm &> /dev/null; then
        log_warn "npm not found. Tauri CLI may not be installed."
    fi

    log_info "Prerequisites OK"
}

# Build frontend in watch mode
build_frontend() {
    log_info "Building frontend (watch mode)..."
    cd "$PROJECT_ROOT/../frontend"
    dotnet watch run --project ProjectManagement.Wasm &
    FRONTEND_PID=$!
    cd "$PROJECT_ROOT"
}

# Run Tauri in dev mode
run_tauri_dev() {
    log_info "Starting Tauri development mode..."
    cargo tauri dev
}

# Main
main() {
    check_prerequisites

    case "${1:-}" in
        --frontend-only)
            build_frontend
            wait $FRONTEND_PID
            ;;
        --backend-only)
            log_info "Building Rust backend..."
            cargo build
            ;;
        *)
            run_tauri_dev
            ;;
    esac
}

main "$@"
```

Make executable:
```bash
chmod +x desktop/scripts/dev.sh
```

---

### Step 2: Create Development Build Script (Windows)

**Create**: `desktop/scripts/dev.ps1`

```powershell
#Requires -Version 5.1
<#
.SYNOPSIS
    Development script for desktop app
.DESCRIPTION
    Builds and runs the desktop application in development mode
.PARAMETER FrontendOnly
    Only build and watch the frontend
.PARAMETER BackendOnly
    Only build the Rust backend
#>

[CmdletBinding()]
param(
    [switch]$FrontendOnly,
    [switch]$BackendOnly
)

$ErrorActionPreference = 'Stop'
$InformationPreference = 'Continue'

$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$ProjectRoot = Split-Path -Parent $ScriptDir

Set-Location $ProjectRoot

function Write-LogInfo {
    param([string]$Message)
    Write-Host "[INFO] $Message" -ForegroundColor Green
}

function Write-LogWarn {
    param([string]$Message)
    Write-Host "[WARN] $Message" -ForegroundColor Yellow
}

function Write-LogError {
    param([string]$Message)
    Write-Host "[ERROR] $Message" -ForegroundColor Red
}

function Test-Prerequisites {
    Write-LogInfo "Checking prerequisites..."

    if (-not (Get-Command rustc -ErrorAction SilentlyContinue)) {
        Write-LogError "Rust not found. Install from https://rustup.rs"
        exit 1
    }

    if (-not (Get-Command cargo -ErrorAction SilentlyContinue)) {
        Write-LogError "Cargo not found. Install from https://rustup.rs"
        exit 1
    }

    if (-not (Get-Command dotnet -ErrorAction SilentlyContinue)) {
        Write-LogError ".NET SDK not found. Install from https://dot.net"
        exit 1
    }

    Write-LogInfo "Prerequisites OK"
}

function Start-TauriDev {
    Write-LogInfo "Starting Tauri development mode..."
    cargo tauri dev
}

function Build-Frontend {
    Write-LogInfo "Building frontend (watch mode)..."
    Push-Location "$ProjectRoot\..\frontend"
    try {
        dotnet watch run --project ProjectManagement.Wasm
    }
    finally {
        Pop-Location
    }
}

function Build-Backend {
    Write-LogInfo "Building Rust backend..."
    cargo build
}

# Main
Test-Prerequisites

if ($FrontendOnly) {
    Build-Frontend
}
elseif ($BackendOnly) {
    Build-Backend
}
else {
    Start-TauriDev
}
```

---

### Step 3: Create Production Build Script (Unix)

**Create**: `desktop/scripts/build.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

# Production build script for desktop app
# Usage: ./scripts/build.sh [--target <platform>] [--debug]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

cd "$PROJECT_ROOT"

# Default values
TARGET=""
DEBUG_BUILD=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --target)
            TARGET="$2"
            shift 2
            ;;
        --debug)
            DEBUG_BUILD=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Build frontend first
build_frontend() {
    log_info "Building frontend (Release)..."
    cd "$PROJECT_ROOT/../frontend"
    dotnet publish ProjectManagement.Wasm -c Release -o ../desktop/src-tauri/target/wwwroot
    cd "$PROJECT_ROOT"
}

# Build Tauri app
build_tauri() {
    log_info "Building Tauri app..."

    local args=()

    if [ "$DEBUG_BUILD" = true ]; then
        args+=(--debug)
    fi

    if [ -n "$TARGET" ]; then
        args+=(--target "$TARGET")
    fi

    cargo tauri build "${args[@]}"
}

# Get output path
print_output() {
    local platform
    case "$(uname -s)" in
        Darwin*) platform="macos" ;;
        Linux*) platform="linux" ;;
        *) platform="unknown" ;;
    esac

    local output_dir="$PROJECT_ROOT/src-tauri/target"
    if [ "$DEBUG_BUILD" = true ]; then
        output_dir="$output_dir/debug"
    else
        output_dir="$output_dir/release"
    fi

    log_info "Build complete!"
    log_info "Output directory: $output_dir/bundle"
}

# Main
main() {
    log_info "Starting production build..."

    build_frontend
    build_tauri
    print_output
}

main
```

---

### Step 4: Create Production Build Script (Windows)

**Create**: `desktop/scripts/build.ps1`

```powershell
#Requires -Version 5.1
<#
.SYNOPSIS
    Production build script for desktop app
.PARAMETER Target
    Build target platform (e.g., x86_64-pc-windows-msvc)
.PARAMETER Debug
    Build in debug mode instead of release
#>

[CmdletBinding()]
param(
    [string]$Target,
    [switch]$Debug
)

$ErrorActionPreference = 'Stop'
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$ProjectRoot = Split-Path -Parent $ScriptDir

Set-Location $ProjectRoot

function Write-LogInfo {
    param([string]$Message)
    Write-Host "[INFO] $Message" -ForegroundColor Green
}

function Write-LogError {
    param([string]$Message)
    Write-Host "[ERROR] $Message" -ForegroundColor Red
}

function Build-Frontend {
    Write-LogInfo "Building frontend (Release)..."
    Push-Location "$ProjectRoot\..\frontend"
    try {
        dotnet publish ProjectManagement.Wasm -c Release -o ..\desktop\src-tauri\target\wwwroot
    }
    finally {
        Pop-Location
    }
}

function Build-TauriApp {
    Write-LogInfo "Building Tauri app..."

    $args = @()

    if ($Debug) {
        $args += '--debug'
    }

    if ($Target) {
        $args += @('--target', $Target)
    }

    if ($args.Count -gt 0) {
        cargo tauri build @args
    }
    else {
        cargo tauri build
    }
}

function Get-OutputPath {
    $outputDir = Join-Path $ProjectRoot "src-tauri\target"
    if ($Debug) {
        $outputDir = Join-Path $outputDir "debug"
    }
    else {
        $outputDir = Join-Path $outputDir "release"
    }

    Write-LogInfo "Build complete!"
    Write-LogInfo "Output directory: $outputDir\bundle"
}

# Main
Write-LogInfo "Starting production build..."

Build-Frontend
Build-TauriApp
Get-OutputPath
```

---

### Step 5: Create GitHub Actions Workflow

**Create**: `.github/workflows/desktop-build.yml`

```yaml
name: Desktop Build

on:
  push:
    branches: [main]
    paths:
      - 'desktop/**'
      - 'frontend/**'
      - '.github/workflows/desktop-build.yml'
  pull_request:
    branches: [main]
    paths:
      - 'desktop/**'
      - 'frontend/**'
      - '.github/workflows/desktop-build.yml'

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-x64
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-arm64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows

    runs-on: ${{ matrix.os }}
    name: Build (${{ matrix.name }})

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'desktop/src-tauri -> target'

      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev

      - name: Build frontend
        run: |
          cd frontend
          dotnet restore
          dotnet build -c Release
          dotnet publish ProjectManagement.Wasm -c Release -o ../desktop/src-tauri/target/wwwroot

      - name: Build Tauri app
        run: |
          cd desktop
          cargo tauri build --target ${{ matrix.target }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.name }}
          path: |
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/
          retention-days: 7

  test:
    runs-on: ubuntu-latest
    name: Run tests

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Run .NET tests
        run: |
          cd frontend
          dotnet test --verbosity normal

      - name: Run Rust tests
        run: |
          cd backend
          cargo test --workspace
```

---

### Step 6: Create Unit Tests for UserIdentityService

**Create**: `frontend/ProjectManagement.Services.Tests/Desktop/UserIdentityServiceTests.cs`

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.JSInterop;
using Moq;
using ProjectManagement.Core.Models;
using ProjectManagement.Services.Desktop;

namespace ProjectManagement.Services.Tests.Desktop;

public class UserIdentityServiceTests : IAsyncDisposable
{
    // Test configuration constants
    private const int ConcurrentCallCount = 10;
    private const int SimulatedSlowOperationMs = 100;

    // Tauri command constants (must match UserIdentityService)
    private const string TauriInvokePath = "__TAURI__.core.invoke";
    private const string TauriCommandLoadIdentity = "load_user_identity";
    private const string TauriCommandSaveIdentity = "save_user_identity";
    private const string TauriCommandBackupCorrupted = "backup_corrupted_user_identity";

    private readonly Mock<IJSRuntime> _mockJs;
    private readonly UserIdentityService _service;

    public UserIdentityServiceTests()
    {
        _mockJs = new Mock<IJSRuntime>();
        _service = new UserIdentityService(
            _mockJs.Object,
            NullLogger<UserIdentityService>.Instance
        );
    }

    public async ValueTask DisposeAsync()
    {
        await _service.DisposeAsync();
    }

    #region LoadExistingUserAsync Tests

    [Fact]
    public async Task LoadExistingUser_ReturnsNull_WhenNoUserExists()
    {
        // Arrange
        SetupLoadUserResult(new UserIdentityResult { User = null, Error = null });

        // Act
        var result = await _service.LoadExistingUserAsync();

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task LoadExistingUser_ReturnsUser_WhenExists()
    {
        // Arrange
        var expectedUser = UserIdentity.Create("Test User", "test@example.com");
        SetupLoadUserResult(new UserIdentityResult { User = expectedUser });

        // Act
        var result = await _service.LoadExistingUserAsync();

        // Assert
        Assert.NotNull(result);
        Assert.Equal(expectedUser.Id, result.Id);
        Assert.Equal("Test User", result.Name);
        Assert.Equal("test@example.com", result.Email);
    }

    [Fact]
    public async Task LoadExistingUser_HandlesCorruptedFile()
    {
        // Arrange
        SetupLoadUserResult(new UserIdentityResult { User = null, Error = "JSON parse error" });
        _mockJs.Setup(x => x.InvokeVoidAsync(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandBackupCorrupted))
            .Returns(ValueTask.CompletedTask);

        // Act
        var result = await _service.LoadExistingUserAsync();

        // Assert
        Assert.Null(result);
        _mockJs.Verify(x => x.InvokeVoidAsync(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandBackupCorrupted), Times.Once);
    }

    [Fact]
    public async Task LoadExistingUser_MigratesOldSchema()
    {
        // Arrange
        var oldUser = new UserIdentity
        {
            Id = Guid.NewGuid(),
            Name = "Old User",
            Email = null,
            CreatedAt = DateTime.UtcNow.AddDays(-30),
            SchemaVersion = 0 // Old version
        };
        SetupLoadUserResult(new UserIdentityResult { User = oldUser });
        SetupSaveUserSuccess();

        // Act
        var result = await _service.LoadExistingUserAsync();

        // Assert
        Assert.NotNull(result);
        Assert.Equal(UserIdentity.CurrentSchemaVersion, result.SchemaVersion);
    }

    #endregion

    #region CreateNewUserAsync Tests

    [Fact]
    public async Task CreateNewUser_GeneratesValidUuid()
    {
        // Arrange
        SetupSaveUserSuccess();

        // Act
        var user = await _service.CreateNewUserAsync("New User", null);

        // Assert
        Assert.NotEqual(Guid.Empty, user.Id);
        Assert.Equal("New User", user.Name);
        Assert.Null(user.Email);
    }

    [Fact]
    public async Task CreateNewUser_ValidatesEmail()
    {
        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(
            () => _service.CreateNewUserAsync("Test", "invalid-email"));
    }

    [Fact]
    public async Task CreateNewUser_AcceptsValidEmail()
    {
        // Arrange
        SetupSaveUserSuccess();

        // Act
        var user = await _service.CreateNewUserAsync("Test", "valid@example.com");

        // Assert
        Assert.Equal("valid@example.com", user.Email);
    }

    [Fact]
    public async Task CreateNewUser_TrimsAndLowercasesEmail()
    {
        // Arrange
        SetupSaveUserSuccess();

        // Act
        var user = await _service.CreateNewUserAsync("Test", "  TEST@Example.COM  ");

        // Assert
        Assert.Equal("test@example.com", user.Email);
    }

    [Fact]
    public async Task CreateNewUser_ThrowsOnSaveFailure()
    {
        // Arrange
        _mockJs.Setup(x => x.InvokeVoidAsync(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandSaveIdentity,
            It.IsAny<object>()))
            .Throws(new JSException("Save failed"));

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _service.CreateNewUserAsync("Test", null));
    }

    #endregion

    #region GetCurrentUserAsync Tests

    [Fact]
    public async Task GetCurrentUser_CachesResult()
    {
        // Arrange
        var user = UserIdentity.Create("Cached", null);
        SetupLoadUserResult(new UserIdentityResult { User = user });

        // Act
        var first = await _service.GetCurrentUserAsync();
        var second = await _service.GetCurrentUserAsync();

        // Assert
        Assert.Same(first, second);
        _mockJs.Verify(x => x.InvokeAsync<UserIdentityResult>(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandLoadIdentity), Times.Once);
    }

    [Fact]
    public async Task GetCurrentUser_IsThreadSafe()
    {
        // Arrange
        var user = UserIdentity.Create("Concurrent", null);
        var callCount = 0;

        _mockJs.Setup(x => x.InvokeAsync<UserIdentityResult>(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandLoadIdentity))
            .ReturnsAsync(() =>
            {
                Interlocked.Increment(ref callCount);
                Thread.Sleep(SimulatedSlowOperationMs); // Simulate slow operation
                return new UserIdentityResult { User = user };
            });

        // Act - concurrent calls
        var tasks = Enumerable.Range(0, ConcurrentCallCount)
            .Select(_ => _service.GetCurrentUserAsync())
            .ToArray();

        var results = await Task.WhenAll(tasks);

        // Assert - should only load once
        Assert.All(results, r => Assert.Same(user, r));
        Assert.Equal(1, callCount);
    }

    #endregion

    #region Disposal Tests

    [Fact]
    public async Task Dispose_PreventsSubsequentCalls()
    {
        // Act
        await _service.DisposeAsync();

        // Assert
        await Assert.ThrowsAsync<ObjectDisposedException>(
            () => _service.LoadExistingUserAsync());
    }

    #endregion

    #region Helpers

    private void SetupLoadUserResult(UserIdentityResult result)
    {
        _mockJs.Setup(x => x.InvokeAsync<UserIdentityResult>(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandLoadIdentity))
            .ReturnsAsync(result);
    }

    private void SetupSaveUserSuccess()
    {
        _mockJs.Setup(x => x.InvokeVoidAsync(
            TauriInvokePath,
            It.IsAny<CancellationToken>(),
            TauriCommandSaveIdentity,
            It.IsAny<object>()))
            .Returns(ValueTask.CompletedTask);
    }

    #endregion
}
```

---

### Step 7: Create Validation Tests

**Create**: `frontend/ProjectManagement.Core.Tests/Validation/RegistrationValidatorTests.cs`

```csharp
using ProjectManagement.Core.Models;
using ProjectManagement.Core.Validation;

namespace ProjectManagement.Core.Tests.Validation;

public class RegistrationValidatorTests
{
    [Theory]
    [InlineData(null, null, true)]
    [InlineData("", "", true)]
    [InlineData("John Doe", null, true)]
    [InlineData(null, "test@example.com", true)]
    [InlineData("John Doe", "test@example.com", true)]
    public void Validate_ValidInputs_ReturnsSuccess(string? name, string? email, bool expected)
    {
        var result = RegistrationValidator.Validate(name, email);
        Assert.Equal(expected, result.IsValid);
    }

    [Fact]
    public void Validate_NameTooLong_ReturnsError()
    {
        var longName = new string('a', RegistrationValidator.MaxNameLength + 1);
        var result = RegistrationValidator.Validate(longName, null);

        Assert.False(result.IsValid);
        Assert.Contains(result.Errors, e => e.Contains("Name"));
    }

    [Theory]
    [InlineData("invalid")]
    [InlineData("@example.com")]
    [InlineData("test@")]
    [InlineData("test@.com")]
    public void Validate_InvalidEmail_ReturnsError(string email)
    {
        var result = RegistrationValidator.Validate(null, email);

        Assert.False(result.IsValid);
        Assert.Contains(result.Errors, e => e.Contains("email", StringComparison.OrdinalIgnoreCase));
    }

    [Theory]
    [InlineData("test@example.com")]
    [InlineData("user.name@domain.co.uk")]
    [InlineData("user+tag@example.org")]
    public void Validate_ValidEmail_ReturnsSuccess(string email)
    {
        var result = RegistrationValidator.Validate(null, email);
        Assert.True(result.IsValid);
    }
}
```

---

### Step 8: Create Manual Testing Checklist

**Create**: `desktop/TESTING.md`

```markdown
# Desktop Manual Testing Checklist

## Pre-Test Setup
- [ ] Delete app data directory completely
- [ ] Ensure no pm-server processes running
- [ ] Have browser dev tools ready (F12 in Tauri webview)
- [ ] Have Activity Monitor/Task Manager ready

---

## 1. First Launch Experience

### 1.1 Startup Screen
- [ ] App window appears within 100ms
- [ ] Startup screen displays immediately
- [ ] Spinner animates smoothly
- [ ] Progress bar advances: 10% → 30% → 50% → 70%
- [ ] Status messages update correctly
- [ ] Reduced motion respected if OS setting enabled

### 1.2 Registration Screen
- [ ] Registration screen appears after startup
- [ ] "Welcome" heading visible
- [ ] Name field: accepts input, shows optional badge
- [ ] Email field: accepts input, shows optional badge
- [ ] Tab navigation works between fields
- [ ] Focus indicators visible on all interactive elements

### 1.3 Input Validation
- [ ] Empty form submits successfully (both optional)
- [ ] Name > 100 chars shows error inline
- [ ] Invalid email shows error inline
- [ ] Error clears when field focused
- [ ] "Get Started" button disabled while processing

### 1.4 Registration Completion
- [ ] Click "Get Started" → button shows spinner
- [ ] user.json created in app data dir
- [ ] JSON file readable and valid
- [ ] Main UI loads after registration
- [ ] No console errors

---

## 2. Persistent Identity

### 2.1 Session Persistence
- [ ] Close app completely (Cmd+Q / Alt+F4)
- [ ] Relaunch app
- [ ] NO registration screen (user.json exists)
- [ ] Same user ID in logs

### 2.2 Project Membership
- [ ] Create project "Test Project"
- [ ] Verify added as admin member
- [ ] Close app completely
- [ ] Relaunch app
- [ ] "Test Project" visible in project list
- [ ] Can open "Test Project"
- [ ] Membership persisted correctly

### 2.3 Multiple Restarts
- [ ] Restart app 5+ times
- [ ] Same user ID every time
- [ ] All projects remain accessible

---

## 3. Error Recovery

### 3.1 Corrupted User File
- [ ] Manually corrupt user.json (invalid JSON)
- [ ] Launch app
- [ ] App shows registration screen (not crash)
- [ ] Backup file created: user.json.corrupted.*
- [ ] Complete registration again
- [ ] New user.json created
- [ ] App works normally

### 3.2 Missing User File
- [ ] Delete user.json (keep other app data)
- [ ] Launch app
- [ ] Registration screen appears
- [ ] No errors in console

### 3.3 Permissions Error
- [ ] Make app data dir read-only
- [ ] Launch app
- [ ] Error screen appears with retry option
- [ ] Fix permissions → Retry → Works

---

## 4. Server Lifecycle

### 4.1 Normal Startup
- [ ] Server starts within 30 seconds
- [ ] Health check passes
- [ ] WebSocket connects successfully

### 4.2 Server Crash Recovery
- [ ] Kill pm-server process manually
- [ ] App shows error/reconnecting state
- [ ] Server auto-restarts
- [ ] App recovers automatically
- [ ] OR: Click "Retry" → works

### 4.3 Startup Timeout
- [ ] Block server from starting (e.g., port conflict)
- [ ] Timeout error shown after 30s
- [ ] Retry button available
- [ ] Fix issue → Retry → Works

---

## 5. JavaScript Elimination

- [ ] Open dev tools console (F12)
- [ ] NO errors about "DesktopInterop"
- [ ] NO "function not defined" errors
- [ ] Verify wwwroot/js/ is empty
- [ ] index.html has only blazor.webassembly.js

---

## 6. Accessibility

### 6.1 Keyboard Navigation
- [ ] Tab through all interactive elements
- [ ] Enter/Space activates buttons
- [ ] Focus visible on all elements
- [ ] Logical tab order

### 6.2 Screen Reader
- [ ] Status messages announced (aria-live)
- [ ] Error messages announced (role=alert)
- [ ] Form labels associated correctly
- [ ] Progress bar has ARIA attributes

### 6.3 Visual
- [ ] Text readable at 200% zoom
- [ ] Colors have sufficient contrast
- [ ] No text in images

---

## 7. Build & Distribution

### 7.1 Development Build
- [ ] `./scripts/dev.sh` (Unix) works
- [ ] `.\scripts\dev.ps1` (Windows) works
- [ ] App launches in dev mode
- [ ] Hot reload works

### 7.2 Production Build
- [ ] `./scripts/build.sh` (Unix) produces bundle
- [ ] `.\scripts\build.ps1` (Windows) produces bundle
- [ ] Bundle size reasonable

### 7.3 Installation
- [ ] macOS: .dmg mounts, app installs to /Applications
- [ ] Windows: .exe/.msi installs correctly
- [ ] Linux: .AppImage runs, .deb installs
- [ ] First launch works from installed location

---

## 8. Edge Cases

- [ ] Very long name (100 chars) - truncated/scrolls
- [ ] Unicode name (emoji, CJK) - displays correctly
- [ ] Rapid click "Get Started" - no double submission
- [ ] Close during registration - no corruption
- [ ] Network disconnect during WebSocket - reconnects
- [ ] System sleep/wake - app recovers

---

## Sign-Off

- [ ] All critical tests pass
- [ ] No console errors in normal flow
- [ ] Performance acceptable (startup < 5s)
- [ ] Memory usage stable (no leaks)

Tested by: _____________
Date: _____________
Version: _____________
```

---

## Session 42.5 Completion Checklist

After completing all steps:

- [ ] `chmod +x desktop/scripts/*.sh`
- [ ] `./scripts/dev.sh` runs successfully
- [ ] `dotnet test frontend/*.Tests` passes
- [ ] GitHub Actions workflow syntax valid: `gh workflow lint`

### Files Created (8)
- `desktop/scripts/dev.sh`
- `desktop/scripts/dev.ps1`
- `desktop/scripts/build.sh`
- `desktop/scripts/build.ps1`
- `.github/workflows/desktop-build.yml`
- `frontend/ProjectManagement.Services.Tests/Desktop/UserIdentityServiceTests.cs`
- `frontend/ProjectManagement.Core.Tests/Validation/RegistrationValidatorTests.cs`
- `desktop/TESTING.md`

---

## Key Concepts Learned

1. **Cross-Platform Scripts** - Shell (Unix) + PowerShell (Windows) for same functionality
2. **Matrix Builds** - GitHub Actions builds for all target platforms in parallel
3. **Test Isolation** - IAsyncDisposable ensures clean state between tests
4. **Thread Safety Testing** - Concurrent calls verify SemaphoreSlim works
5. **Manual Test Checklists** - Systematic verification prevents regressions

---

## Session 42 Complete!

With all five sub-sessions completed, you now have:

1. **Persistent User Identity** - Users keep their ID across restarts
2. **No JavaScript** - All interop is type-safe C#
3. **Professional Startup UI** - Loading progress, registration, error handling
4. **Cross-Platform CI/CD** - Automated builds for macOS, Windows, Linux
5. **Comprehensive Testing** - Unit tests + manual checklist

### Verification Commands

```bash
# Backend check
cargo check --workspace
cargo test --workspace

# Frontend check
dotnet build frontend/ProjectManagement.sln
dotnet test

# Desktop build
cd desktop && cargo tauri build

# Manual testing
# Follow desktop/TESTING.md checklist
```
