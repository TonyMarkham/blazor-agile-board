# Session 45.1: Radzen Drag-and-Drop Integration

**Parent Plan**: `45-Session-Plan.md`
**Target**: ~35-40k tokens
**Prerequisites**: Existing Kanban board compiles and runs (`just check-frontend`)

---

## Scope

This session replaces the unreliable HTML5 drag-and-drop with Radzen's `RadzenDropZoneContainer` / `RadzenDropZone` components:

1. **CSS for Radzen drag states** (Step 1)
2. **CardTemplate infrastructure** (Step 2) - RenderFragment for card rendering
3. **RadzenDropZoneContainer** (Step 3) - Wrap columns, add drop handler
4. **RadzenDropZone** (Step 4) - Restructure KanbanColumn
5. **Remove drag callbacks** (Step 5) - Coordinated cleanup
6. **Simplify KanbanCard** (Step 6) - Remove HTML5 drag attributes
7. **Update Tests** (Step 7) - Delete obsolete tests, update parameters

---

## Critical Architecture Notes (from Radzen source analysis)

**RadzenDropZone DOM structure:**
```
<div class="rz-dropzone">       <!-- RadzenDropZone wrapper -->
  ├── ChildContent              <!-- Renders first (header, empty state) -->
  ├── Items (foreach)           <!-- Items render AFTER ChildContent -->
  └── Footer                    <!-- Optional footer -->
</div>
```

**Key insight:** Items render as siblings AFTER ChildContent, not inside a container. This means:
- Column header must be in ChildContent
- RadzenDropZone itself becomes the "column body"
- Empty state goes in ChildContent (visible when no items)

**Draggability control:** Use `args.Attributes["draggable"] = "false"` (no dedicated `Draggable` property)

---

## Implementation Order

### Step 1: Add CSS for Radzen drag states

**File**: `frontend/ProjectManagement.Components/wwwroot/css/kanban.css`

Add at the end of the file:

```css
/* =============================================================================
   RADZEN DROPZONE INTEGRATION
   ============================================================================= */

/* DropZone as column body */
.kanban-column > .rz-dropzone {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

/* Drop target highlight (Radzen applies .rz-can-drop to the zone) */
.rz-dropzone.rz-can-drop {
    box-shadow: 0 0 0 2px var(--rz-primary);
    background: var(--rz-primary-lighter);
}

/* Dragging card style */
.rz-drag-source .kanban-card,
.kanban-card.rz-drag-source {
    cursor: grabbing;
    transform: rotate(2deg);
    box-shadow: var(--rz-shadow-3);
    opacity: 0.9;
}

/* Keyboard drag overlay - captures mouse clicks to cancel keyboard drag */
.keyboard-drag-overlay {
    position: absolute;
    inset: 0;
    z-index: 100;
    background: transparent;
    cursor: default;
}
```

**Verification**: `just build-cs-components`

---

### Step 2: Add CardTemplate infrastructure

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanColumn.razor`

Add parameter (don't use yet - will be wired in Step 4):

```csharp
[Parameter]
public RenderFragment<WorkItemViewModel>? CardTemplate { get; set; }
```

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanBoard.razor`

Add these methods in the `@code` block:

```csharp
// CardTemplate - RenderFragment with builder pattern
// Note: In @code block, use __builder pattern for type safety
private RenderFragment<WorkItemViewModel> CardTemplate => item => __builder =>
{
    __builder.OpenComponent<KanbanCard>(0);
    __builder.AddAttribute(1, "Item", item);
    __builder.AddAttribute(2, "IsConnected", _isConnected);
    __builder.AddAttribute(3, "OnClick", HandleCardClick);
    __builder.AddAttribute(4, "OnEdit", HandleCardEdit);
    __builder.CloseComponent();
};

private bool ItemBelongsToZone(WorkItemViewModel item, RadzenDropZone<WorkItemViewModel> zone)
    => item.Status == zone.Value?.ToString();

// CANONICAL HandleItemRender - controls draggability and accessibility
private void HandleItemRender(RadzenDropZoneItemRenderEventArgs<WorkItemViewModel> args)
{
    if (args?.Item is null) return;

    args.Attributes ??= new Dictionary<string, object>();

    // Always add aria-label for accessibility
    args.Attributes["aria-label"] = $"Drag {args.Item.Title} to move between columns";

    // Disable drag when not connected or syncing
    if (!_isConnected || args.Item.IsPendingSync)
    {
        args.Attributes["draggable"] = "false";
        args.Attributes["aria-disabled"] = "true";
    }
}

// Placeholder for Step 3
private async Task HandleRadzenDrop(RadzenDropZoneItemEventArgs<WorkItemViewModel> args)
{
    // Will be implemented in Step 3
}
```

Update KanbanColumn calls to pass CardTemplate:

```razor
<KanbanColumn Status="@column.Status"
              Title="@column.Title"
              Items="@GetColumnItems(column.Status)"
              IsConnected="@_isConnected"
              IsDragTarget="@(_draggedItem is not null && _dragTargetColumn == column.Status)"
              CardTemplate="@CardTemplate"
              OnDragStart="@HandleDragStart"
              OnDragEnd="@HandleDragEnd"
              OnDragEnter="@(() => HandleDragEnter(column.Status))"
              OnDrop="@(() => HandleDrop(column.Status))"
              OnCardClick="@HandleCardClick"
              OnCardEdit="@HandleCardEdit" />
```

**Verification**: `just build-cs-components`

---

### Step 3: Add RadzenDropZoneContainer to KanbanBoard

**Why this step comes before Column restructure:** `RadzenDropZone` requires a `RadzenDropZoneContainer` parent to function. We add the Container first so that when we restructure Column in Step 4, the DropZone has a parent.

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanBoard.razor`

Wrap the columns div with RadzenDropZoneContainer and add keyboard drag overlay:

Find the existing columns div and wrap it:

```razor
<RadzenDropZoneContainer TItem="WorkItemViewModel"
                         Data="@_filteredItems"
                         ItemSelector="@ItemBelongsToZone"
                         Drop="@HandleRadzenDrop"
                         ItemRender="@HandleItemRender">
    <div class="kanban-columns" role="listbox" aria-orientation="horizontal" style="position: relative;">
        @* Overlay captures mouse clicks during keyboard drag *@
        @if (_draggedItem is not null)
        {
            <div class="keyboard-drag-overlay"
                 @onclick="CancelKeyboardDrag"
                 @onclick:stopPropagation="true">
            </div>
        }
        @foreach (var column in Columns)
        {
            <KanbanColumn Status="@column.Status"
                          Title="@column.Title"
                          Items="@GetColumnItems(column.Status)"
                          IsConnected="@_isConnected"
                          IsDragTarget="@(_draggedItem is not null && _dragTargetColumn == column.Status)"
                          CardTemplate="@CardTemplate"
                          OnDragStart="@HandleDragStart"
                          OnDragEnd="@HandleDragEnd"
                          OnDragEnter="@(() => HandleDragEnter(column.Status))"
                          OnDrop="@(() => HandleDrop(column.Status))"
                          OnCardClick="@HandleCardClick"
                          OnCardEdit="@HandleCardEdit" />
        }
    </div>
</RadzenDropZoneContainer>
```

Add cancel method and full HandleRadzenDrop implementation in `@code` block:

```csharp
private void CancelKeyboardDrag()
{
    _announcement = "Drag cancelled.";
    HandleDragEnd();
}

private async Task HandleRadzenDrop(RadzenDropZoneItemEventArgs<WorkItemViewModel> args)
{
    if (args?.Item is null || args.DropZone?.Value is null || !_isConnected)
        return;

    var item = args.Item;
    var newStatus = args.DropZone.Value.ToString()!;
    var oldStatus = item.Status;

    if (oldStatus == newStatus)
    {
        _announcement = $"{item.Title} returned to {GetColumnTitle(newStatus)}.";
        return;
    }

    _announcement = $"Moving {item.Title} to {GetColumnTitle(newStatus)}...";
    await InvokeAsync(StateHasChanged);

    try
    {
        var request = new UpdateWorkItemRequest
        {
            WorkItemId = item.Id,
            ExpectedVersion = item.Version,
            Status = newStatus
        };
        await AppState.WorkItems.UpdateAsync(request);

        _announcement = $"{item.Title} moved to {GetColumnTitle(newStatus)}.";
        NotificationService.Notify(NotificationSeverity.Success, "Moved", $"Moved to {GetColumnTitle(newStatus)}");
    }
    catch (Exception ex)
    {
        _announcement = $"Failed to move {item.Title}: {ex.Message}";
        NotificationService.Notify(NotificationSeverity.Error, "Error", ex.Message);
    }
}

private string GetColumnTitle(string status) =>
    Columns.FirstOrDefault(c => c.Status == status).Title ?? status;
```

**Note:** At this point, the board still renders cards via the old foreach loop in KanbanColumn. The Container is ready but Column hasn't switched to DropZone yet.

**Verification**: `just build-cs-components`

---

### Step 4: Restructure KanbanColumn with RadzenDropZone

**Now that Container exists**, Column can use RadzenDropZone.

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanColumn.razor`

Replace the entire component markup with:

```razor
@using ProjectManagement.Core.ViewModels

<div class="kanban-column @(IsKeyboardDragTarget ? "drag-target" : "")"
     role="listbox"
     aria-label="@($"{Title} column, {ItemCount} items")">

    <!-- Header stays outside the DropZone -->
    <div class="kanban-column-header">
        <RadzenText TextStyle="TextStyle.Subtitle1" class="m-0">@Title</RadzenText>
        <RadzenBadge BadgeStyle="@HeaderBadgeStyle" Text="@ItemCount.ToString()" IsPill="true" />
    </div>

    <!-- DropZone replaces the body - items rendered via Template -->
    <RadzenDropZone TItem="WorkItemViewModel" Value="@Status" Template="@CardTemplate">
        @if (ItemCount == 0)
        {
            <div class="kanban-empty-column">
                <RadzenIcon Icon="inbox" Style="font-size: 1.5rem; opacity: 0.5;" />
                <RadzenText TextStyle="TextStyle.Caption" class="text-muted mt-2">No items</RadzenText>
            </div>
        }
    </RadzenDropZone>
</div>

@code {
    [Parameter, EditorRequired]
    public string Status { get; set; } = "";

    [Parameter, EditorRequired]
    public string Title { get; set; } = "";

    [Parameter]
    public IEnumerable<WorkItemViewModel> Items { get; set; } = Enumerable.Empty<WorkItemViewModel>();

    [Parameter]
    public bool IsConnected { get; set; }

    [Parameter]
    public bool IsKeyboardDragTarget { get; set; }  // Renamed from IsDragTarget

    [Parameter]
    public RenderFragment<WorkItemViewModel>? CardTemplate { get; set; }

    // KEEP these for now - Board still passes them (will remove in Step 5)
    [Parameter]
    public EventCallback<WorkItemViewModel> OnDragStart { get; set; }

    [Parameter]
    public EventCallback OnDragEnd { get; set; }

    [Parameter]
    public EventCallback OnDragEnter { get; set; }

    [Parameter]
    public EventCallback<string> OnDrop { get; set; }

    [Parameter]
    public EventCallback<WorkItemViewModel> OnCardClick { get; set; }

    [Parameter]
    public EventCallback<WorkItemViewModel> OnCardEdit { get; set; }

    private int ItemCount => Items.Count();

    private BadgeStyle HeaderBadgeStyle => Status switch
    {
        "backlog" => BadgeStyle.Light,
        "todo" => BadgeStyle.Info,
        "in_progress" => BadgeStyle.Warning,
        "review" => BadgeStyle.Secondary,
        "done" => BadgeStyle.Success,
        _ => BadgeStyle.Light
    };
}
```

**What was removed from the original:**
- `@ondragover`, `@ondragover:preventDefault`, `@ondrop` attributes from the div
- `HandleDragOver()` and `HandleDrop()` methods (they were Column's internal handlers)
- The `foreach` loop that iterated over Items (Radzen renders items via Template now)

**Verification**: `just build-cs-components`

**Test:** Run `just dev` - drag and drop should now work via Radzen!

---

### Step 5: Remove drag callbacks (coordinated change)

Now that Radzen handles mouse drag, remove the unused parameters.

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanBoard.razor`

Update KanbanColumn calls - stop passing callbacks, rename param:

```razor
<KanbanColumn Status="@column.Status"
              Title="@column.Title"
              Items="@GetColumnItems(column.Status)"
              IsConnected="@_isConnected"
              IsKeyboardDragTarget="@(_draggedItem is not null && _dragTargetColumn == column.Status)"
              CardTemplate="@CardTemplate"
              OnCardClick="@HandleCardClick"
              OnCardEdit="@HandleCardEdit" />
@* REMOVED: OnDragStart, OnDragEnd, OnDragEnter, OnDrop *@
@* RENAMED: IsDragTarget → IsKeyboardDragTarget *@
```

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanColumn.razor`

Remove the unused parameters from `@code` block:

```csharp
@code {
    [Parameter, EditorRequired]
    public string Status { get; set; } = "";

    [Parameter, EditorRequired]
    public string Title { get; set; } = "";

    [Parameter]
    public IEnumerable<WorkItemViewModel> Items { get; set; } = Enumerable.Empty<WorkItemViewModel>();

    [Parameter]
    public bool IsConnected { get; set; }

    [Parameter]
    public bool IsKeyboardDragTarget { get; set; }

    [Parameter]
    public RenderFragment<WorkItemViewModel>? CardTemplate { get; set; }

    // REMOVED: OnDragStart, OnDragEnd, OnDragEnter, OnDrop

    [Parameter]
    public EventCallback<WorkItemViewModel> OnCardClick { get; set; }

    [Parameter]
    public EventCallback<WorkItemViewModel> OnCardEdit { get; set; }

    private int ItemCount => Items.Count();

    private BadgeStyle HeaderBadgeStyle => Status switch
    {
        "backlog" => BadgeStyle.Light,
        "todo" => BadgeStyle.Info,
        "in_progress" => BadgeStyle.Warning,
        "review" => BadgeStyle.Secondary,
        "done" => BadgeStyle.Success,
        _ => BadgeStyle.Light
    };
}
```

**Verification**: `just build-cs-components`

---

### Step 6: Simplify KanbanCard.razor

Remove HTML5 drag code that's no longer needed.

**File**: `frontend/ProjectManagement.Components/WorkItems/KanbanCard.razor`

**Remove parameters** from `@code` block:

```csharp
// REMOVE these parameters:
// [Parameter] public EventCallback<WorkItemViewModel> OnDragStart { get; set; }
// [Parameter] public EventCallback OnDragEnd { get; set; }
```

**Remove internal drag code** from `@code` block:

```csharp
// REMOVE these:
// private bool _isDragging;
//
// private void HandleDragStart(DragEventArgs args)
// {
//     _isDragging = true;
//     OnDragStart.InvokeAsync(Item);
// }
//
// private void HandleDragEnd(DragEventArgs args)
// {
//     _isDragging = false;
//     OnDragEnd.InvokeAsync();
// }
```

**Remove from div** at the top of the component:
- `draggable="@(IsConnected && !Item.IsPendingSync)"` attribute
- `@ondragstart="HandleDragStart"` attribute
- `@ondragend="HandleDragEnd"` attribute
- `aria-grabbed="@(_isDragging)"` attribute

**Simplify CardCssClass** - remove `_isDragging` check:

```csharp
// Change from:
// private string CardCssClass => _isDragging ? "dragging" : (Item.IsPendingSync ? "pending-sync" : "");

// To:
private string CardCssClass => Item.IsPendingSync ? "pending-sync" : "";
```

**Simplify AriaLabel** - remove "Drag to move" hint:

```csharp
// Change from:
// private string AriaLabel => $"{Item.ItemType}: {Item.Title}. Priority: {Item.Priority}. Drag to move between columns.";

// To:
private string AriaLabel => $"{Item.ItemType}: {Item.Title}. Priority: {Item.Priority}.";
```

**Remove keyboard drag handling** from `HandleKeyDown` if present - the keyboard drag is handled at Board level, not Card level.

**Verification**: `just build-cs-components`

---

### Step 7: Update Tests

**File**: `frontend/ProjectManagement.Components.Tests/WorkItems/KanbanCardTests.cs`

Delete the entire `#region Drag Events Tests` section. Remove these 6 tests:

| Test Name | Action |
|-----------|--------|
| `KanbanCard_IsDraggable_WhenConnectedAndNotPending` | **DELETE** |
| `KanbanCard_IsNotDraggable_WhenDisconnected` | **DELETE** |
| `KanbanCard_IsNotDraggable_WhenPendingSync` | **DELETE** |
| `KanbanCard_InvokesOnDragStart_WhenDragStarts` | **DELETE** |
| `KanbanCard_InvokesOnDragEnd_WhenDragEnds` | **DELETE** |
| `KanbanCard_HasAriaGrabbedFalse_WhenNotDragging` | **DELETE** |

**File**: `frontend/ProjectManagement.Components.Tests/WorkItems/KanbanBoardTests.cs`

Update test that references `IsDragTarget`:

```csharp
// Find test: KanbanColumn_AppliesDragTargetClass_WhenIsDragTarget
// Change parameter name from IsDragTarget to IsKeyboardDragTarget

// Before:
.Add(p => p.IsDragTarget, true)

// After:
.Add(p => p.IsKeyboardDragTarget, true)
```

**Verification**: `just build-cs-components && just test-cs-components`

---

## Session 45.1 Completion Checklist

After completing all steps:

- [ ] `just build-cs-components` - compiles without errors
- [ ] `just test-cs-components` - all tests pass (minus 6 deleted drag tests)
- [ ] `just dev` - application runs
- [ ] Mouse drag works: drag card from Backlog → To Do → card moves
- [ ] Visual feedback: column highlights on hover during drag
- [ ] Drop in same column: no backend call, no notification
- [ ] Keyboard navigation still works (Tab, Space, Arrow, Space)
- [ ] Pending sync items cannot be dragged

### Files Modified (4)
- `ProjectManagement.Components/wwwroot/css/kanban.css`
- `ProjectManagement.Components/WorkItems/KanbanBoard.razor`
- `ProjectManagement.Components/WorkItems/KanbanColumn.razor`
- `ProjectManagement.Components/WorkItems/KanbanCard.razor`

### Files Modified - Tests (2)
- `ProjectManagement.Components.Tests/WorkItems/KanbanCardTests.cs` (6 tests deleted)
- `ProjectManagement.Components.Tests/WorkItems/KanbanBoardTests.cs` (1 test updated)

---

## Keyboard + Radzen State Handling

**Problem:** The existing keyboard navigation uses `_draggedItem` state while Radzen manages its own internal drag state. These must not conflict.

**Solution:**
- **Mouse drag:** Radzen handles entirely. `_draggedItem` stays null. `HandleRadzenDrop` processes drops.
- **Keyboard drag:** User presses Space on a card → existing `HandleDragStart` sets `_draggedItem` → Arrow keys call `HandleDragEnter` → Space calls `HandleDrop(status)` (existing method, not Radzen) → Escape calls `HandleDragEnd`

**Key insight:** The keyboard flow never touches Radzen's Drop callback because:
1. Keyboard drag is initiated by our `HandleDragStart`, not Radzen
2. Keyboard drop calls our `HandleDrop(string)` directly, not `HandleRadzenDrop`

**Code clarification** - Keep BOTH drop handlers:
```csharp
// For MOUSE drag (Radzen)
private async Task HandleRadzenDrop(RadzenDropZoneItemEventArgs<WorkItemViewModel> args) { ... }

// For KEYBOARD drag (existing) - Keep this!
private async Task HandleDrop(string newStatus) { ... }
```

---

## Error Handling

All error handling is built into the canonical `HandleItemRender` and `HandleRadzenDrop` methods:

Key defensive patterns:
- `if (args?.Item is null) return;` - Guard against null args
- `args.Attributes ??= new Dictionary<string, object>();` - Initialize if needed
- `if (args?.DropZone?.Value is null || !_isConnected) return;` - Validate drop target

---

## Build Failure Troubleshooting

If any step fails to build:

1. **Check the error message** - Is it a type error, missing using, or syntax error?
2. **Verify previous step** - Did you complete all changes in the prior step?
3. **Common issues:**
   - Missing `@using Radzen` → Should already be in `_Imports.razor`
   - Type mismatch in `Value="@Status"` → Ensure `Status` is `string`, `Value` accepts `object?`
   - RenderFragment compilation error → In `@code` block, use `__builder` pattern (shown in Step 2)
4. **If stuck:** Revert to last working state with `git checkout -- <file>`

---

## Next Session

**Session 45.2** will implement:
- ChildProgress model for tracking child item completion
- WorkItemViewModel updates with progress properties
- ViewModelFactory computing progress from AppState cache
- ChildProgressBar component with swimlane colors
- Type-specific card rendering (Epic shows 2 bars, Story shows 1, Task shows none)
- Progress bar tests
