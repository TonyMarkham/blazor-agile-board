# Session 50.1: Proto Schema + Backend Sprint Infrastructure

**Parent Plan**: `50-Session-Plan.md`
**Target**: ~35-40k tokens
**Prerequisites**: Existing codebase compiles (`just check`)

---

## Scope

This session implements the foundation for Sprint functionality:

1. **Proto Schema Updates** - Add version field, new messages, WebSocket payloads
2. **Backend Sprint Model** - Add version field for optimistic locking
3. **Backend Sprint Repository** - Update queries to include version
4. **Backend Sprint Handler** - Full CRUD with status transitions

---

## Learning Objectives

By completing this session, you will understand:

- **Protobuf Schema Evolution**: Adding fields without breaking compatibility
- **Optimistic Locking**: Using version fields to detect concurrent modifications
- **Status State Machines**: Validating allowed status transitions
- **Authorization Patterns**: Permission-based access control in handlers

---

## Prerequisites Check

Before starting, verify the codebase compiles:

```bash
just check  # Should pass
```

Ensure these tables exist (from previous migrations):
- `pm_sprints` with columns: id, project_id, name, goal, start_date, end_date, status, created_at, updated_at, created_by, updated_by, deleted_at

---

## Implementation Order

### Step 1: Update Proto Schema

**File**: `proto/messages.proto`

**Add version field to Sprint message (line 88, after status):**
```protobuf
  int32 version = 13;
```

**Replace UpdateSprintRequest (after line 354):**
```protobuf
message UpdateSprintRequest {
  string sprint_id = 1;
  int32 expected_version = 2;
  optional string name = 3;
  optional string goal = 4;
  optional int64 start_date = 5;
  optional int64 end_date = 6;
  optional SprintStatus status = 7;
}
```

**Update SprintUpdated to include changes (line 373-376):**
```protobuf
message SprintUpdated {
  Sprint sprint = 1;
  repeated FieldChange changes = 2;
  string user_id = 3;
}
```

**Add Get/List messages (after line 381):**
```protobuf
message GetSprintsRequest {
  string project_id = 1;
}

message SprintsList {
  repeated Sprint sprints = 1;
}

message GetCommentsRequest {
  string work_item_id = 1;
}

message CommentsList {
  repeated Comment comments = 1;
}
```

**Add to WebSocketMessage oneof (after line 245):**
```protobuf
    GetSprintsRequest get_sprints_request = 53;
    SprintsList sprints_list = 63;
    GetCommentsRequest get_comments_request = 73;
    CommentsList comments_list = 83;
```

**Verification**: `just build-backend && just build-frontend`

---

### Step 2: Update Backend Sprint Model

**File**: `backend/crates/pm-core/src/models/sprint.rs`

**Add version field to struct (after status field):**
```rust
    pub version: i32,
```

**Update `new()` constructor (add before created_at):**
```rust
            version: 1,
```

**Verification**: `just check-rs-core`

---

### Step 3: Update Backend Sprint Repository

**File**: `backend/crates/pm-db/src/repositories/sprint_repository.rs`

This step requires updating all SQL queries to include the `version` field.

**Update create() INSERT:**
```rust
        sqlx::query!(
            r#"
              INSERT INTO pm_sprints (
                  id, project_id, name, goal,
                  start_date, end_date, status, version,
                  created_at, updated_at, created_by, updated_by, deleted_at
              ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
              "#,
            id,
            project_id,
            sprint.name,
            sprint.goal,
            start_date,
            end_date,
            status,
            sprint.version,
            created_at,
            updated_at,
            created_by,
            updated_by,
            deleted_at,
        )
```

**Update find_by_id() SELECT:**
```rust
        let row = sqlx::query!(
            r#"
              SELECT id, project_id, name, goal, start_date, end_date, status, version,
                     created_at, updated_at, created_by, updated_by, deleted_at
              FROM pm_sprints
              WHERE id = ? AND deleted_at IS NULL
              "#,
            id_str
        )
```

**Update find_by_id() mapping to include version:**
```rust
        Ok(row.map(|r| Sprint {
            id: Uuid::parse_str(r.id.as_ref().unwrap()).unwrap(),
            project_id: Uuid::parse_str(&r.project_id).unwrap(),
            name: r.name,
            goal: r.goal,
            start_date: DateTime::from_timestamp(r.start_date, 0).unwrap(),
            end_date: DateTime::from_timestamp(r.end_date, 0).unwrap(),
            status: SprintStatus::from_str(&r.status).unwrap(),
            version: r.version,
            created_at: DateTime::from_timestamp(r.created_at, 0).unwrap(),
            updated_at: DateTime::from_timestamp(r.updated_at, 0).unwrap(),
            created_by: Uuid::parse_str(&r.created_by).unwrap(),
            updated_by: Uuid::parse_str(&r.updated_by).unwrap(),
            deleted_at: r.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
        }))
```

**Same changes for find_by_project() SELECT and mapping.**

**Add find_active_by_project() method (after find_by_project):**
```rust
    pub async fn find_active_by_project(&self, project_id: Uuid) -> DbErrorResult<Option<Sprint>> {
        let project_id_str = project_id.to_string();
        let active_status = SprintStatus::Active.as_str();

        let row = sqlx::query!(
            r#"
              SELECT id, project_id, name, goal, start_date, end_date, status, version,
                     created_at, updated_at, created_by, updated_by, deleted_at
              FROM pm_sprints
              WHERE project_id = ? AND status = ? AND deleted_at IS NULL
              "#,
            project_id_str,
            active_status
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(row.map(|r| Sprint {
            id: Uuid::parse_str(r.id.as_ref().unwrap()).unwrap(),
            project_id: Uuid::parse_str(&r.project_id).unwrap(),
            name: r.name,
            goal: r.goal,
            start_date: DateTime::from_timestamp(r.start_date, 0).unwrap(),
            end_date: DateTime::from_timestamp(r.end_date, 0).unwrap(),
            status: SprintStatus::from_str(&r.status).unwrap(),
            version: r.version,
            created_at: DateTime::from_timestamp(r.created_at, 0).unwrap(),
            updated_at: DateTime::from_timestamp(r.updated_at, 0).unwrap(),
            created_by: Uuid::parse_str(&r.created_by).unwrap(),
            updated_by: Uuid::parse_str(&r.updated_by).unwrap(),
            deleted_at: r.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
        }))
    }
```

**Update update() to include version:**
```rust
        sqlx::query!(
            r#"
              UPDATE pm_sprints
              SET project_id = ?, name = ?, goal = ?,
                  start_date = ?, end_date = ?, status = ?, version = ?,
                  updated_at = ?, updated_by = ?
              WHERE id = ? AND deleted_at IS NULL
              "#,
            project_id,
            sprint.name,
            sprint.goal,
            start_date,
            end_date,
            status,
            sprint.version,
            updated_at,
            updated_by,
            id,
        )
```

**Verification**: `just check-rs-db && just test-rs-db`

---

### Step 4: Create Backend Sprint Handler

**Create**: `backend/crates/pm-ws/src/handlers/sprint.rs`

```rust
use crate::handlers::{
    authorization::check_permission,
    change_tracker::FieldChangeBuilder,
    context::HandlerContext,
    db_ops::{db_read, db_write},
    idempotency::{check_idempotency, store_idempotency},
    response_builder::*,
    work_item::sanitize_string,
};
use crate::{MessageValidator, Result as WsErrorResult, WsError};

use pm_core::{ActivityLog, Permission, Sprint, SprintStatus};
use pm_db::{ActivityLogRepository, SprintRepository};
use pm_proto::{
    CreateSprintRequest, DeleteSprintRequest, GetSprintsRequest, UpdateSprintRequest,
    WebSocketMessage, SprintStatus as ProtoSprintStatus,
};

use std::panic::Location;
use std::str::FromStr;

use chrono::{DateTime, Utc};
use error_location::ErrorLocation;
use uuid::Uuid;

fn parse_uuid(s: &str, field: &str) -> Result<Uuid, WsError> {
    Uuid::parse_str(s).map_err(|_| WsError::ValidationError {
        message: format!("Invalid UUID format for {}", field),
        field: Some(field.to_string()),
        location: ErrorLocation::from(Location::caller()),
    })
}

fn proto_to_domain_status(proto_status: i32) -> Result<SprintStatus, WsError> {
    match proto_status {
        x if x == ProtoSprintStatus::Planned as i32 => Ok(SprintStatus::Planned),
        x if x == ProtoSprintStatus::Active as i32 => Ok(SprintStatus::Active),
        x if x == ProtoSprintStatus::Completed as i32 => Ok(SprintStatus::Completed),
        x if x == ProtoSprintStatus::Cancelled as i32 => Ok(SprintStatus::Cancelled),
        _ => Err(WsError::ValidationError {
            message: format!("Invalid sprint status: {}", proto_status),
            field: Some("status".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }),
    }
}

/// Handle CreateSprintRequest with full production features
pub async fn handle_create_sprint(
    req: CreateSprintRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} CreateSprint starting", ctx.log_prefix());

    // 1. Validate input
    MessageValidator::validate_sprint_create(&req.name, req.goal.as_deref())?;

    // 2. Check idempotency
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;

    if let Some(cached_response) = cached {
        log::info!("{} Returning cached idempotent response", ctx.log_prefix());
        use base64::Engine;
        use prost::Message as ProstMessage;
        let bytes = base64::engine::general_purpose::STANDARD
            .decode(&cached_response)
            .map_err(|e| WsError::Internal {
                message: format!("Failed to decode cached response: {e}"),
                location: ErrorLocation::from(Location::caller()),
            })?;
        return WebSocketMessage::decode(&*bytes).map_err(|e| WsError::Internal {
            message: format!("Failed to decode cached protobuf: {e}"),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 3. Parse IDs
    let project_id = parse_uuid(&req.project_id, "project_id")?;

    // 4. Authorization
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, project_id, Permission::Edit).await
    })
    .await?;

    // 5. Parse dates
    let start_date = DateTime::from_timestamp(req.start_date, 0).ok_or_else(|| {
        WsError::ValidationError {
            message: "Invalid start_date timestamp".to_string(),
            field: Some("start_date".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }
    })?;
    let end_date = DateTime::from_timestamp(req.end_date, 0).ok_or_else(|| {
        WsError::ValidationError {
            message: "Invalid end_date timestamp".to_string(),
            field: Some("end_date".to_string()),
            location: ErrorLocation::from(Location::caller()),
        }
    })?;

    if start_date >= end_date {
        return Err(WsError::ValidationError {
            message: "start_date must be before end_date".to_string(),
            field: Some("start_date".to_string()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 6. Build sprint
    let sprint = Sprint::new(
        project_id,
        sanitize_string(&req.name),
        req.goal.as_ref().map(|g| sanitize_string(g)),
        start_date,
        end_date,
        ctx.user_id,
    );

    // 7. Execute transaction
    let sprint_clone = sprint.clone();
    db_write(&ctx, "create_sprint_tx", || async {
        let repo = SprintRepository::new(ctx.pool.clone());
        repo.create(&sprint_clone).await?;

        let activity = ActivityLog::created("sprint", sprint_clone.id, ctx.user_id);
        ActivityLogRepository::create(&ctx.pool, &activity).await?;

        Ok::<_, WsError>(())
    })
    .await?;

    // 8. Build response
    let response = build_sprint_created_response(&ctx.message_id, &sprint, ctx.user_id);

    // 9. Store idempotency
    use base64::Engine;
    use prost::Message as ProstMessage;
    let response_bytes = response.encode_to_vec();
    let response_b64 = base64::engine::general_purpose::STANDARD.encode(&response_bytes);

    if let Err(e) = store_idempotency(&ctx.pool, &ctx.message_id, "create_sprint", &response_b64).await {
        log::warn!("{} Failed to store idempotency (non-fatal): {}", ctx.log_prefix(), e);
    }

    log::info!("{} Created sprint {} in project {}", ctx.log_prefix(), sprint.id, project_id);

    Ok(response)
}

/// Handle UpdateSprintRequest with optimistic locking and status transitions
pub async fn handle_update_sprint(
    req: UpdateSprintRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} UpdateSprint starting", ctx.log_prefix());

    // 1. Parse sprint ID
    let sprint_id = parse_uuid(&req.sprint_id, "sprint_id")?;

    // 2. Fetch existing
    let repo = SprintRepository::new(ctx.pool.clone());
    let mut sprint = db_read(&ctx, "find_sprint", || async {
        repo.find_by_id(sprint_id).await.map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        message: format!("Sprint {} not found", sprint_id),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 3. Authorization
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, sprint.project_id, Permission::Edit).await
    })
    .await?;

    // 4. Optimistic locking - version must match
    if sprint.version != req.expected_version {
        return Err(WsError::ConflictError {
            current_version: sprint.version,
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 5. Cannot modify completed sprints
    if sprint.status == SprintStatus::Completed {
        return Err(WsError::ConflictError {
            current_version: sprint.version,
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 6. Track changes and apply updates
    let mut changes = FieldChangeBuilder::new();

    if let Some(ref name) = req.name {
        MessageValidator::validate_string(name, "name", 1, 100)?;
        changes.track("name", &sprint.name, name);
        sprint.name = sanitize_string(name);
    }
    if let Some(ref goal) = req.goal {
        changes.track_option("goal", &sprint.goal, &Some(goal.clone()));
        sprint.goal = Some(sanitize_string(goal));
    }
    if let Some(start_date) = req.start_date {
        let new_start = DateTime::from_timestamp(start_date, 0).ok_or_else(|| {
            WsError::ValidationError {
                message: "Invalid start_date".to_string(),
                field: Some("start_date".to_string()),
                location: ErrorLocation::from(Location::caller()),
            }
        })?;
        changes.track("start_date", &sprint.start_date.to_rfc3339(), &new_start.to_rfc3339());
        sprint.start_date = new_start;
    }
    if let Some(end_date) = req.end_date {
        let new_end = DateTime::from_timestamp(end_date, 0).ok_or_else(|| {
            WsError::ValidationError {
                message: "Invalid end_date".to_string(),
                field: Some("end_date".to_string()),
                location: ErrorLocation::from(Location::caller()),
            }
        })?;
        changes.track("end_date", &sprint.end_date.to_rfc3339(), &new_end.to_rfc3339());
        sprint.end_date = new_end;
    }
    if let Some(status) = req.status {
        let new_status = proto_to_domain_status(status)?;

        // Validate status transition
        validate_sprint_status_transition(&ctx, &sprint, new_status.clone()).await?;

        changes.track("status", sprint.status.as_str(), new_status.as_str());
        sprint.status = new_status;
    }

    let field_changes = changes.build();
    if field_changes.is_empty() {
        return Ok(build_sprint_updated_response(&ctx.message_id, &sprint, &field_changes, ctx.user_id));
    }

    // 7. Update metadata
    sprint.updated_at = Utc::now();
    sprint.updated_by = ctx.user_id;
    sprint.version += 1;

    // 8. Transaction
    let sprint_clone = sprint.clone();
    let changes_clone = field_changes.clone();
    db_write(&ctx, "update_sprint_tx", || async {
        let repo = SprintRepository::new(ctx.pool.clone());
        repo.update(&sprint_clone).await?;

        let activity = ActivityLog::updated("sprint", sprint_clone.id, ctx.user_id, &changes_clone);
        ActivityLogRepository::create(&ctx.pool, &activity).await?;

        Ok::<_, WsError>(())
    })
    .await?;

    log::info!("{} Updated sprint {} (version {})", ctx.log_prefix(), sprint.id, sprint.version);

    Ok(build_sprint_updated_response(&ctx.message_id, &sprint, &field_changes, ctx.user_id))
}

/// Validate sprint status transitions following the state machine:
/// Planned -> Active -> Completed
/// Planned -> Cancelled
/// Active -> Cancelled
async fn validate_sprint_status_transition(
    ctx: &HandlerContext,
    sprint: &Sprint,
    new_status: SprintStatus,
) -> WsErrorResult<()> {
    let valid = match (sprint.status.clone(), new_status.clone()) {
        (SprintStatus::Planned, SprintStatus::Active) => true,
        (SprintStatus::Planned, SprintStatus::Cancelled) => true,
        (SprintStatus::Active, SprintStatus::Completed) => true,
        (SprintStatus::Active, SprintStatus::Cancelled) => true,
        (from, to) if from == to => true, // No change is always valid
        _ => false,
    };

    if !valid {
        return Err(WsError::ValidationError {
            message: format!(
                "Invalid status transition: {} -> {}",
                sprint.status.as_str(),
                new_status.as_str()
            ),
            field: Some("status".to_string()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // Business rule: Only one active sprint per project at a time
    if new_status == SprintStatus::Active && sprint.status != SprintStatus::Active {
        let repo = SprintRepository::new(ctx.pool.clone());
        let active = db_read(ctx, "find_active_sprint", || async {
            repo.find_active_by_project(sprint.project_id).await.map_err(WsError::from)
        })
        .await?;

        if active.is_some() {
            return Err(WsError::ConflictError {
                current_version: sprint.version,
                location: ErrorLocation::from(Location::caller()),
            });
        }
    }

    Ok(())
}

/// Handle DeleteSprintRequest (soft delete)
pub async fn handle_delete_sprint(
    req: DeleteSprintRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} DeleteSprint starting", ctx.log_prefix());

    let sprint_id = parse_uuid(&req.sprint_id, "sprint_id")?;

    let repo = SprintRepository::new(ctx.pool.clone());
    let sprint = db_read(&ctx, "find_sprint", || async {
        repo.find_by_id(sprint_id).await.map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        message: format!("Sprint {} not found", sprint_id),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // Authorization - Admin required for delete
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, sprint.project_id, Permission::Admin).await
    })
    .await?;

    // Cannot delete completed sprints (historical data)
    if sprint.status == SprintStatus::Completed {
        return Err(WsError::DeleteBlocked {
            message: "Cannot delete completed sprint".to_string(),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // Soft delete
    db_write(&ctx, "delete_sprint_tx", || async {
        let repo = SprintRepository::new(ctx.pool.clone());
        repo.delete(sprint_id, Utc::now().timestamp()).await?;

        let activity = ActivityLog::deleted("sprint", sprint_id, ctx.user_id);
        ActivityLogRepository::create(&ctx.pool, &activity).await?;

        Ok::<_, WsError>(())
    })
    .await?;

    log::info!("{} Deleted sprint {}", ctx.log_prefix(), sprint_id);

    Ok(build_sprint_deleted_response(&ctx.message_id, sprint_id, ctx.user_id))
}

/// Handle GetSprintsRequest - list sprints for a project
pub async fn handle_get_sprints(
    req: GetSprintsRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    log::debug!("{} GetSprints starting", ctx.log_prefix());

    let project_id = parse_uuid(&req.project_id, "project_id")?;

    // Authorization - View permission required
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, project_id, Permission::View).await
    })
    .await?;

    let repo = SprintRepository::new(ctx.pool.clone());
    let sprints = db_read(&ctx, "find_sprints", || async {
        repo.find_by_project(project_id).await.map_err(WsError::from)
    })
    .await?;

    log::info!("{} Found {} sprints for project {}", ctx.log_prefix(), sprints.len(), project_id);

    Ok(build_sprints_list_response(&ctx.message_id, sprints))
}
```

**Update**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add:
```rust
pub(crate) mod sprint;
```

**Verification**: `just check-rs-ws`

---

## Session 50.1 Completion Checklist

After completing all steps:

- [ ] `just build-backend` passes
- [ ] `just build-frontend` passes (proto regeneration)
- [ ] `just check` passes
- [ ] `just test-backend` passes

### Files Modified (3)
- `proto/messages.proto`
- `pm-core/src/models/sprint.rs`
- `pm-db/src/repositories/sprint_repository.rs`

### Files Created (1)
- `pm-ws/src/handlers/sprint.rs`

### Files Modified (1)
- `pm-ws/src/handlers/mod.rs`

---

## Key Concepts Explained

### Optimistic Locking

```rust
// Client sends expected version
if sprint.version != req.expected_version {
    return Err(WsError::ConflictError {
        current_version: sprint.version,  // Client can retry with this
        location: ErrorLocation::from(Location::caller()),
    });
}

// Increment version on successful update
sprint.version += 1;
```

The client must track the current version and send it with updates. If another client modified the resource, versions won't match and the update is rejected. The error includes the current version so the client can refresh and retry.

### Status State Machine

```
       ┌──────────────────────────────────┐
       │            PLANNED               │
       └──────────────┬───────────────────┘
                      │
           ┌──────────┼──────────┐
           │ (start)  │          │ (cancel)
           ▼          │          ▼
    ┌──────────┐      │    ┌──────────┐
    │  ACTIVE  │──────┼───►│CANCELLED │
    └────┬─────┘ (cancel)  └──────────┘
         │
         │ (complete)
         ▼
    ┌──────────┐
    │COMPLETED │
    └──────────┘
```

Only specific transitions are allowed. `validate_sprint_status_transition()` enforces this.

### Business Rule: One Active Sprint Per Project

```rust
if new_status == SprintStatus::Active && sprint.status != SprintStatus::Active {
    let active = repo.find_active_by_project(sprint.project_id).await?;
    if active.is_some() {
        return Err(WsError::ConflictError { ... });
    }
}
```

This prevents teams from having multiple concurrent sprints, which would make metrics meaningless.

---

## Next Session

**Session 50.2** will implement:
- Comment handler with author-only permissions
- Response builders for Sprint/Comment
- Dispatcher routing for new messages
- Message validator for Sprint/Comment
