# Session 50.3: Frontend Models + WebSocket Integration

**Parent Plan**: `50-Session-Plan.md`
**Prerequisite**: Sessions 50.1 and 50.2 completed
**Target**: ~40-45k tokens

---

## Scope

This session implements the frontend communication layer:

1. **Frontend Model Updates** - Add Version to Sprint, update UpdateSprintRequest
2. **Comment Models** - New Comment model and request DTOs
3. **ProtoConverter Updates** - Sprint and Comment conversions
4. **IWebSocketClient Updates** - Sprint/Comment events and operations
5. **WebSocketClient Implementation** - Implement the new operations
6. **SprintStore WebSocket Integration** - Wire store to WebSocket events

---

## Learning Objectives

By completing this session, you will understand:

- **Proto Converters**: Mapping between protobuf and domain models
- **WebSocket Client Events**: Handling server-pushed events
- **Optimistic Updates**: Updating UI before server confirmation
- **State Synchronization**: Reconciling optimistic state with server responses

---

## Prerequisites Check

Before starting, verify backend is complete:

```bash
just build-backend  # Should pass
just test-backend   # Should pass
```

---

## Implementation Order

### Step 1: Update Frontend Sprint Model

**File**: `frontend/ProjectManagement.Core/Models/Sprint.cs`

**Add Version property (after Status):**
```csharp
    public int Version { get; init; } = 1;
```

**Verification**: `just build-cs-core`

---

### Step 2: Update UpdateSprintRequest

**File**: `frontend/ProjectManagement.Core/Models/UpdateSprintRequest.cs`

**Replace entire file:**
```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to update an existing sprint.
/// Includes ExpectedVersion for optimistic locking.
/// </summary>
public sealed record UpdateSprintRequest
{
    /// <summary>
    /// ID of the sprint to update.
    /// </summary>
    public required Guid SprintId { get; init; }

    /// <summary>
    /// Expected version for optimistic locking.
    /// If the server's version doesn't match, the update is rejected.
    /// </summary>
    public required int ExpectedVersion { get; init; }

    /// <summary>
    /// New name for the sprint (optional).
    /// </summary>
    public string? Name { get; init; }

    /// <summary>
    /// New goal for the sprint (optional).
    /// </summary>
    public string? Goal { get; init; }

    /// <summary>
    /// New start date (optional).
    /// </summary>
    public DateTime? StartDate { get; init; }

    /// <summary>
    /// New end date (optional).
    /// </summary>
    public DateTime? EndDate { get; init; }

    /// <summary>
    /// New status (optional).
    /// Status transitions are validated by the server.
    /// </summary>
    public SprintStatus? Status { get; init; }
}
```

**Verification**: `just build-cs-core`

---

### Step 3: Create Comment Model

**Create**: `frontend/ProjectManagement.Core/Models/Comment.cs`

```csharp
using ProjectManagement.Core.Interfaces;

namespace ProjectManagement.Core.Models;

/// <summary>
/// A comment on a work item.
/// Comments can only be edited/deleted by their author.
/// </summary>
public sealed record Comment : IAuditable
{
    /// <summary>
    /// Unique identifier for this comment.
    /// </summary>
    public Guid Id { get; init; }

    /// <summary>
    /// ID of the work item this comment is attached to.
    /// </summary>
    public Guid WorkItemId { get; init; }

    /// <summary>
    /// The comment content (plain text).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// When the comment was created.
    /// </summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>
    /// When the comment was last updated.
    /// </summary>
    public DateTime UpdatedAt { get; init; }

    /// <summary>
    /// User who created the comment (the author).
    /// Only this user can edit/delete the comment.
    /// </summary>
    public Guid CreatedBy { get; init; }

    /// <summary>
    /// User who last updated the comment (should be same as CreatedBy).
    /// </summary>
    public Guid UpdatedBy { get; init; }

    /// <summary>
    /// When the comment was soft-deleted, or null if active.
    /// </summary>
    public DateTime? DeletedAt { get; init; }
}
```

**Verification**: `just build-cs-core`

---

### Step 4: Create Comment Request Models

**Create**: `frontend/ProjectManagement.Core/Models/CreateCommentRequest.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to create a new comment on a work item.
/// </summary>
public sealed record CreateCommentRequest
{
    /// <summary>
    /// ID of the work item to comment on.
    /// </summary>
    public required Guid WorkItemId { get; init; }

    /// <summary>
    /// The comment content.
    /// Must be 1-5000 characters.
    /// </summary>
    public required string Content { get; init; }
}
```

**Create**: `frontend/ProjectManagement.Core/Models/UpdateCommentRequest.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to update an existing comment.
/// Only the comment author can update their comment.
/// </summary>
public sealed record UpdateCommentRequest
{
    /// <summary>
    /// ID of the comment to update.
    /// </summary>
    public required Guid CommentId { get; init; }

    /// <summary>
    /// The new comment content.
    /// Must be 1-5000 characters.
    /// </summary>
    public required string Content { get; init; }
}
```

**Verification**: `just build-cs-core`

---

### Step 5: Update ProtoConverter

**File**: `frontend/ProjectManagement.Core/Converters/ProtoConverter.cs`

**Add after Project region:**

```csharp
    #region Sprint Conversions

    /// <summary>
    /// Convert protobuf Sprint to domain Sprint.
    /// </summary>
    public static Sprint ToDomain(Proto.Sprint proto)
    {
        ArgumentNullException.ThrowIfNull(proto);

        return new Sprint
        {
            Id = ParseGuid(proto.Id, "Sprint.Id"),
            ProjectId = ParseGuid(proto.ProjectId, "Sprint.ProjectId"),
            Name = proto.Name ?? string.Empty,
            Goal = string.IsNullOrEmpty(proto.Goal) ? null : proto.Goal,
            StartDate = FromUnixTimestamp(proto.StartDate),
            EndDate = FromUnixTimestamp(proto.EndDate),
            Status = ToDomain(proto.Status),
            Version = proto.Version,
            CreatedAt = FromUnixTimestamp(proto.CreatedAt),
            UpdatedAt = FromUnixTimestamp(proto.UpdatedAt),
            CreatedBy = ParseGuid(proto.CreatedBy, "Sprint.CreatedBy"),
            UpdatedBy = ParseGuid(proto.UpdatedBy, "Sprint.UpdatedBy"),
            DeletedAt = proto.DeletedAt == 0 ? null : FromUnixTimestamp(proto.DeletedAt),
        };
    }

    /// <summary>
    /// Convert CreateSprintRequest to protobuf.
    /// </summary>
    public static Proto.CreateSprintRequest ToProto(CreateSprintRequest req)
    {
        ArgumentNullException.ThrowIfNull(req);

        return new Proto.CreateSprintRequest
        {
            ProjectId = req.ProjectId.ToString(),
            Name = req.Name,
            Goal = req.Goal ?? string.Empty,
            StartDate = ToUnixTimestamp(req.StartDate),
            EndDate = ToUnixTimestamp(req.EndDate),
        };
    }

    /// <summary>
    /// Convert UpdateSprintRequest to protobuf.
    /// Only includes fields that are set (non-null).
    /// </summary>
    public static Proto.UpdateSprintRequest ToProto(UpdateSprintRequest req)
    {
        ArgumentNullException.ThrowIfNull(req);

        var proto = new Proto.UpdateSprintRequest
        {
            SprintId = req.SprintId.ToString(),
            ExpectedVersion = req.ExpectedVersion,
        };

        if (req.Name is not null) proto.Name = req.Name;
        if (req.Goal is not null) proto.Goal = req.Goal;
        if (req.StartDate.HasValue) proto.StartDate = ToUnixTimestamp(req.StartDate.Value);
        if (req.EndDate.HasValue) proto.EndDate = ToUnixTimestamp(req.EndDate.Value);
        if (req.Status.HasValue) proto.Status = ToProto(req.Status.Value);

        return proto;
    }

    /// <summary>
    /// Convert protobuf SprintStatus to domain SprintStatus.
    /// </summary>
    public static SprintStatus ToDomain(Proto.SprintStatus proto)
    {
        return proto switch
        {
            Proto.SprintStatus.Planned => SprintStatus.Planned,
            Proto.SprintStatus.Active => SprintStatus.Active,
            Proto.SprintStatus.Completed => SprintStatus.Completed,
            Proto.SprintStatus.Cancelled => SprintStatus.Cancelled,
            _ => SprintStatus.Planned
        };
    }

    /// <summary>
    /// Convert domain SprintStatus to protobuf.
    /// </summary>
    public static Proto.SprintStatus ToProto(SprintStatus domain)
    {
        return domain switch
        {
            SprintStatus.Planned => Proto.SprintStatus.Planned,
            SprintStatus.Active => Proto.SprintStatus.Active,
            SprintStatus.Completed => Proto.SprintStatus.Completed,
            SprintStatus.Cancelled => Proto.SprintStatus.Cancelled,
            _ => Proto.SprintStatus.Planned
        };
    }

    #endregion

    #region Comment Conversions

    /// <summary>
    /// Convert protobuf Comment to domain Comment.
    /// </summary>
    public static Comment ToDomain(Proto.Comment proto)
    {
        ArgumentNullException.ThrowIfNull(proto);

        return new Comment
        {
            Id = ParseGuid(proto.Id, "Comment.Id"),
            WorkItemId = ParseGuid(proto.WorkItemId, "Comment.WorkItemId"),
            Content = proto.Content ?? string.Empty,
            CreatedAt = FromUnixTimestamp(proto.CreatedAt),
            UpdatedAt = FromUnixTimestamp(proto.UpdatedAt),
            CreatedBy = ParseGuid(proto.CreatedBy, "Comment.CreatedBy"),
            UpdatedBy = ParseGuid(proto.UpdatedBy, "Comment.UpdatedBy"),
            DeletedAt = proto.DeletedAt == 0 ? null : FromUnixTimestamp(proto.DeletedAt),
        };
    }

    /// <summary>
    /// Convert CreateCommentRequest to protobuf.
    /// </summary>
    public static Proto.CreateCommentRequest ToProto(CreateCommentRequest req)
    {
        ArgumentNullException.ThrowIfNull(req);

        return new Proto.CreateCommentRequest
        {
            WorkItemId = req.WorkItemId.ToString(),
            Content = req.Content,
        };
    }

    /// <summary>
    /// Convert UpdateCommentRequest to protobuf.
    /// </summary>
    public static Proto.UpdateCommentRequest ToProto(UpdateCommentRequest req)
    {
        ArgumentNullException.ThrowIfNull(req);

        return new Proto.UpdateCommentRequest
        {
            CommentId = req.CommentId.ToString(),
            Content = req.Content,
        };
    }

    #endregion
```

**Verification**: `just build-cs-core`

---

### Step 6: Update IWebSocketClient Interface

**File**: `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs`

**Add after existing Project events:**

```csharp
    // ============================================================
    // Sprint Events (received from server)
    // ============================================================

    /// <summary>
    /// Fired when a sprint is created (by this or another client).
    /// </summary>
    event Action<Sprint>? OnSprintCreated;

    /// <summary>
    /// Fired when a sprint is updated (by this or another client).
    /// </summary>
    event Action<Sprint, IReadOnlyList<FieldChange>>? OnSprintUpdated;

    /// <summary>
    /// Fired when a sprint is deleted (by this or another client).
    /// </summary>
    event Action<Guid>? OnSprintDeleted;

    // ============================================================
    // Sprint Operations (send to server)
    // ============================================================

    /// <summary>
    /// Create a new sprint in a project.
    /// </summary>
    Task<Sprint> CreateSprintAsync(CreateSprintRequest request, CancellationToken ct = default);

    /// <summary>
    /// Update an existing sprint.
    /// Uses optimistic locking - ExpectedVersion must match server's version.
    /// </summary>
    Task<Sprint> UpdateSprintAsync(UpdateSprintRequest request, CancellationToken ct = default);

    /// <summary>
    /// Delete a sprint (soft delete).
    /// Requires admin permission. Cannot delete completed sprints.
    /// </summary>
    Task DeleteSprintAsync(Guid sprintId, CancellationToken ct = default);

    /// <summary>
    /// Get all sprints for a project.
    /// </summary>
    Task<IReadOnlyList<Sprint>> GetSprintsAsync(Guid projectId, CancellationToken ct = default);

    // ============================================================
    // Comment Events (received from server)
    // ============================================================

    /// <summary>
    /// Fired when a comment is created (by this or another client).
    /// </summary>
    event Action<Comment>? OnCommentCreated;

    /// <summary>
    /// Fired when a comment is updated (by this or another client).
    /// </summary>
    event Action<Comment>? OnCommentUpdated;

    /// <summary>
    /// Fired when a comment is deleted (by this or another client).
    /// </summary>
    event Action<Guid>? OnCommentDeleted;

    // ============================================================
    // Comment Operations (send to server)
    // ============================================================

    /// <summary>
    /// Create a comment on a work item.
    /// </summary>
    Task<Comment> CreateCommentAsync(CreateCommentRequest request, CancellationToken ct = default);

    /// <summary>
    /// Update a comment.
    /// Only the comment author can update their own comment.
    /// </summary>
    Task<Comment> UpdateCommentAsync(UpdateCommentRequest request, CancellationToken ct = default);

    /// <summary>
    /// Delete a comment.
    /// Only the comment author can delete their own comment.
    /// </summary>
    Task DeleteCommentAsync(Guid commentId, CancellationToken ct = default);

    /// <summary>
    /// Get all comments for a work item.
    /// </summary>
    Task<IReadOnlyList<Comment>> GetCommentsAsync(Guid workItemId, CancellationToken ct = default);
```

**Verification**: `just build-cs-core`

---

### Step 7: Implement WebSocketClient Operations

**File**: `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

**Add events after existing events:**
```csharp
    public event Action<Sprint>? OnSprintCreated;
    public event Action<Sprint, IReadOnlyList<FieldChange>>? OnSprintUpdated;
    public event Action<Guid>? OnSprintDeleted;
    public event Action<Comment>? OnCommentCreated;
    public event Action<Comment>? OnCommentUpdated;
    public event Action<Guid>? OnCommentDeleted;
```

**Add Sprint operations (after existing operations):**
```csharp
    public async Task<Sprint> CreateSprintAsync(CreateSprintRequest request, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            CreateSprintRequest = ProtoConverter.ToProto(request),
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.SprintCreated)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return ProtoConverter.ToDomain(response.SprintCreated.Sprint);
    }

    public async Task<Sprint> UpdateSprintAsync(UpdateSprintRequest request, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            UpdateSprintRequest = ProtoConverter.ToProto(request),
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.SprintUpdated)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return ProtoConverter.ToDomain(response.SprintUpdated.Sprint);
    }

    public async Task DeleteSprintAsync(Guid sprintId, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            DeleteSprintRequest = new Pm.DeleteSprintRequest { SprintId = sprintId.ToString() },
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.SprintDeleted)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");
    }

    public async Task<IReadOnlyList<Sprint>> GetSprintsAsync(Guid projectId, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            GetSprintsRequest = new Pm.GetSprintsRequest { ProjectId = projectId.ToString() },
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.SprintsList)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return response.SprintsList.Sprints.Select(ProtoConverter.ToDomain).ToList();
    }
```

**Add Comment operations:**
```csharp
    public async Task<Comment> CreateCommentAsync(CreateCommentRequest request, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            CreateCommentRequest = ProtoConverter.ToProto(request),
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.CommentCreated)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return ProtoConverter.ToDomain(response.CommentCreated.Comment);
    }

    public async Task<Comment> UpdateCommentAsync(UpdateCommentRequest request, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            UpdateCommentRequest = ProtoConverter.ToProto(request),
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.CommentUpdated)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return ProtoConverter.ToDomain(response.CommentUpdated.Comment);
    }

    public async Task DeleteCommentAsync(Guid commentId, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            DeleteCommentRequest = new Pm.DeleteCommentRequest { CommentId = commentId.ToString() },
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.CommentDeleted)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");
    }

    public async Task<IReadOnlyList<Comment>> GetCommentsAsync(Guid workItemId, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        EnsureConnected();

        var message = new Pm.WebSocketMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            GetCommentsRequest = new Pm.GetCommentsRequest { WorkItemId = workItemId.ToString() },
        };

        var response = await SendRequestAsync(message, ct);

        if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
            throw new ServerRejectedException(response.Error.Code, response.Error.Message);

        if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.CommentsList)
            throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

        return response.CommentsList.Comments.Select(ProtoConverter.ToDomain).ToList();
    }
```

**Add to HandleBroadcastEvent switch (after existing cases):**
```csharp
            case Pm.WebSocketMessage.PayloadOneofCase.SprintCreated:
                var createdSprint = ProtoConverter.ToDomain(message.SprintCreated.Sprint);
                OnSprintCreated?.Invoke(createdSprint);
                break;

            case Pm.WebSocketMessage.PayloadOneofCase.SprintUpdated:
                var updatedSprint = ProtoConverter.ToDomain(message.SprintUpdated.Sprint);
                var sprintChanges = message.SprintUpdated.Changes
                    .Select(c => new FieldChange(c.FieldName, c.OldValue, c.NewValue))
                    .ToList();
                OnSprintUpdated?.Invoke(updatedSprint, sprintChanges);
                break;

            case Pm.WebSocketMessage.PayloadOneofCase.SprintDeleted:
                if (Guid.TryParse(message.SprintDeleted.SprintId, out var deletedSprintId))
                    OnSprintDeleted?.Invoke(deletedSprintId);
                break;

            case Pm.WebSocketMessage.PayloadOneofCase.CommentCreated:
                var createdComment = ProtoConverter.ToDomain(message.CommentCreated.Comment);
                OnCommentCreated?.Invoke(createdComment);
                break;

            case Pm.WebSocketMessage.PayloadOneofCase.CommentUpdated:
                var updatedComment = ProtoConverter.ToDomain(message.CommentUpdated.Comment);
                OnCommentUpdated?.Invoke(updatedComment);
                break;

            case Pm.WebSocketMessage.PayloadOneofCase.CommentDeleted:
                if (Guid.TryParse(message.CommentDeleted.CommentId, out var deletedCommentId))
                    OnCommentDeleted?.Invoke(deletedCommentId);
                break;
```

**Verification**: `just build-cs-services`

---

### Step 8: Update SprintStore WebSocket Integration

**File**: `frontend/ProjectManagement.Services/State/SprintStore.cs`

**Update constructor to wire up events:**
```csharp
        _client.OnSprintCreated += HandleSprintCreated;
        _client.OnSprintUpdated += HandleSprintUpdated;
        _client.OnSprintDeleted += HandleSprintDeleted;
```

**Update Dispose:**
```csharp
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _client.OnSprintCreated -= HandleSprintCreated;
        _client.OnSprintUpdated -= HandleSprintUpdated;
        _client.OnSprintDeleted -= HandleSprintDeleted;
    }
```

**Update CreateAsync to use WebSocket:**
```csharp
    public async Task<Sprint> CreateAsync(
        CreateSprintRequest request,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();

        // Create optimistic sprint with temporary ID
        var tempId = Guid.NewGuid();
        var optimistic = new Sprint
        {
            Id = tempId,
            ProjectId = request.ProjectId,
            Name = request.Name,
            Goal = request.Goal,
            StartDate = request.StartDate,
            EndDate = request.EndDate,
            Status = SprintStatus.Planned,
            Version = 1,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
            CreatedBy = Guid.Empty,
            UpdatedBy = Guid.Empty
        };

        // Optimistic update
        _sprints[tempId] = optimistic;
        _pendingUpdates[tempId] = true;
        NotifyChanged();

        try
        {
            // Send to server
            var confirmed = await _client.CreateSprintAsync(request, ct);

            // Replace temp with confirmed
            _sprints.TryRemove(tempId, out _);
            _sprints[confirmed.Id] = confirmed;
            _pendingUpdates.TryRemove(tempId, out _);
            NotifyChanged();

            _logger.LogDebug("Sprint created: {Id}", confirmed.Id);
            return confirmed;
        }
        catch
        {
            // Rollback optimistic update
            _sprints.TryRemove(tempId, out _);
            _pendingUpdates.TryRemove(tempId, out _);
            NotifyChanged();
            throw;
        }
    }
```

**Update UpdateAsync to use WebSocket:**
```csharp
    public async Task<Sprint> UpdateAsync(
        UpdateSprintRequest request,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sprints.TryGetValue(request.SprintId, out var current))
            throw new KeyNotFoundException($"Sprint not found: {request.SprintId}");

        // Create optimistic update
        var optimistic = current with
        {
            Name = request.Name ?? current.Name,
            Goal = request.Goal ?? current.Goal,
            StartDate = request.StartDate ?? current.StartDate,
            EndDate = request.EndDate ?? current.EndDate,
            Status = request.Status ?? current.Status,
            Version = current.Version + 1,
            UpdatedAt = DateTime.UtcNow
        };

        // Store previous value for rollback
        var previousValue = _sprints[request.SprintId];
        _sprints[request.SprintId] = optimistic;
        _pendingUpdates[request.SprintId] = true;
        NotifyChanged();

        try
        {
            var confirmed = await _client.UpdateSprintAsync(request, ct);
            _sprints[request.SprintId] = confirmed;
            _pendingUpdates.TryRemove(request.SprintId, out _);
            NotifyChanged();
            return confirmed;
        }
        catch
        {
            // Rollback to previous value
            _sprints[request.SprintId] = previousValue;
            _pendingUpdates.TryRemove(request.SprintId, out _);
            NotifyChanged();
            throw;
        }
    }
```

**Update RefreshAsync:**
```csharp
    public async Task RefreshAsync(Guid projectId, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        var sprints = await _client.GetSprintsAsync(projectId, ct);

        // Remove existing sprints for this project
        var toRemove = _sprints.Values
            .Where(s => s.ProjectId == projectId)
            .Select(s => s.Id)
            .ToList();

        foreach (var id in toRemove)
            _sprints.TryRemove(id, out _);

        // Add fetched sprints
        foreach (var sprint in sprints)
            _sprints[sprint.Id] = sprint;

        NotifyChanged();
        _logger.LogDebug("Refreshed {Count} sprints for project {ProjectId}", sprints.Count, projectId);
    }
```

**Add event handlers:**
```csharp
    #region WebSocket Event Handlers

    private void HandleSprintCreated(Sprint sprint)
    {
        // Skip if we have a pending update (we created this)
        if (_pendingUpdates.ContainsKey(sprint.Id)) return;

        _sprints[sprint.Id] = sprint;
        NotifyChanged();
        _logger.LogDebug("Received sprint created: {Id}", sprint.Id);
    }

    private void HandleSprintUpdated(Sprint sprint, IReadOnlyList<FieldChange> changes)
    {
        // Skip if we have a pending update (we updated this)
        if (_pendingUpdates.ContainsKey(sprint.Id)) return;

        _sprints[sprint.Id] = sprint;
        NotifyChanged();
        _logger.LogDebug("Received sprint updated: {Id}", sprint.Id);
    }

    private void HandleSprintDeleted(Guid id)
    {
        // Skip if we have a pending update (we deleted this)
        if (_pendingUpdates.ContainsKey(id)) return;

        if (_sprints.TryGetValue(id, out var sprint))
        {
            _sprints[id] = sprint with { DeletedAt = DateTime.UtcNow };
            NotifyChanged();
        }
        _logger.LogDebug("Received sprint deleted: {Id}", id);
    }

    #endregion
```

**Verification**: `just build-frontend && just test-frontend`

---

## Session 50.3 Completion Checklist

After completing all steps:

- [ ] `just build-frontend` passes
- [ ] `just test-frontend` passes
- [ ] `just check` passes

### Files Modified (5)
- `ProjectManagement.Core/Models/Sprint.cs` - Add Version
- `ProjectManagement.Core/Models/UpdateSprintRequest.cs` - Add ExpectedVersion + Status
- `ProjectManagement.Core/Converters/ProtoConverter.cs` - Sprint/Comment conversions
- `ProjectManagement.Core/Interfaces/IWebSocketClient.cs` - Sprint/Comment events and operations
- `ProjectManagement.Services/State/SprintStore.cs` - WebSocket integration

### Files Created (3)
- `ProjectManagement.Core/Models/Comment.cs`
- `ProjectManagement.Core/Models/CreateCommentRequest.cs`
- `ProjectManagement.Core/Models/UpdateCommentRequest.cs`

### Files Modified (1)
- `ProjectManagement.Services/WebSocket/WebSocketClient.cs` - Implementation

---

## Key Concepts Explained

### Optimistic Updates

```csharp
// 1. Create optimistic version
var optimistic = current with { Name = newName, Version = current.Version + 1 };

// 2. Update local state immediately
_sprints[id] = optimistic;
NotifyChanged();  // UI updates immediately

// 3. Send to server
try
{
    var confirmed = await _client.UpdateSprintAsync(request);
    _sprints[id] = confirmed;  // Replace with server version
}
catch
{
    _sprints[id] = previousValue;  // Rollback on error
}
```

### Event Deduplication

```csharp
private void HandleSprintUpdated(Sprint sprint, ...)
{
    // Skip if WE made this change (our optimistic update is already correct)
    if (_pendingUpdates.ContainsKey(sprint.Id)) return;

    // Only apply updates from OTHER clients
    _sprints[sprint.Id] = sprint;
}
```

This prevents "double updates" when we receive our own broadcast back from the server.

---

## Next Session

**Session 50.4** will implement:
- CommentStore state management
- Sprint UI components (SprintCard, SprintDialog)
- Comment UI components (CommentList, CommentEditor)
