# Session 50.4: State Management + UI Components

**Parent Plan**: `50-Session-Plan.md`
**Prerequisite**: Sessions 50.1-50.3 completed
**Target**: ~40-45k tokens

---

## Scope

This session implements the user-facing components:

1. **ICommentStore Interface** - Comment store abstraction
2. **CommentStore** - Comment state management with WebSocket
3. **Sprint UI Components** - SprintCard, SprintDialog
4. **Comment UI Components** - CommentList, CommentEditor

---

## Learning Objectives

By completing this session, you will understand:

- **Blazor State Management**: Managing collections of entities
- **Component Design**: Reusable UI components with callbacks
- **Dialog Patterns**: Modal dialogs for create/edit operations
- **Real-time UI**: Components that react to WebSocket events

---

## Prerequisites Check

Before starting, verify Session 50.3 is complete:

```bash
just build-frontend  # Should pass
just test-frontend   # Should pass
```

---

## Implementation Order

### Step 1: Create ICommentStore Interface

**Create**: `frontend/ProjectManagement.Core/Interfaces/ICommentStore.cs`

```csharp
using ProjectManagement.Core.Models;

namespace ProjectManagement.Core.Interfaces;

/// <summary>
/// State store for comments.
/// Manages comment collections per work item with real-time updates.
/// </summary>
public interface ICommentStore : IDisposable
{
    /// <summary>
    /// Fired when the comment collection changes.
    /// </summary>
    event Action? OnChanged;

    /// <summary>
    /// Get all comments for a work item.
    /// </summary>
    IReadOnlyList<Comment> GetComments(Guid workItemId);

    /// <summary>
    /// Check if a comment has a pending update.
    /// </summary>
    bool IsPending(Guid commentId);

    /// <summary>
    /// Create a new comment on a work item.
    /// </summary>
    Task<Comment> CreateAsync(CreateCommentRequest request, CancellationToken ct = default);

    /// <summary>
    /// Update an existing comment.
    /// Only works if the current user is the author.
    /// </summary>
    Task<Comment> UpdateAsync(UpdateCommentRequest request, CancellationToken ct = default);

    /// <summary>
    /// Delete a comment.
    /// Only works if the current user is the author.
    /// </summary>
    Task DeleteAsync(Guid commentId, CancellationToken ct = default);

    /// <summary>
    /// Refresh comments for a work item from the server.
    /// </summary>
    Task RefreshAsync(Guid workItemId, CancellationToken ct = default);
}
```

**Verification**: `just build-cs-core`

---

### Step 2: Create CommentStore

**Create**: `frontend/ProjectManagement.Services/State/CommentStore.cs`

```csharp
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using ProjectManagement.Core.Interfaces;
using ProjectManagement.Core.Models;

namespace ProjectManagement.Services.State;

/// <summary>
/// State store for comments with WebSocket integration.
/// Comments are organized by work item ID.
/// </summary>
public sealed class CommentStore : ICommentStore
{
    private readonly IWebSocketClient _client;
    private readonly ILogger<CommentStore> _logger;
    private readonly ConcurrentDictionary<Guid, Comment> _comments = new();
    private readonly ConcurrentDictionary<Guid, bool> _pendingUpdates = new();
    private bool _disposed;

    public event Action? OnChanged;

    public CommentStore(IWebSocketClient client, ILogger<CommentStore> logger)
    {
        _client = client ?? throw new ArgumentNullException(nameof(client));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        // Subscribe to WebSocket events
        _client.OnCommentCreated += HandleCommentCreated;
        _client.OnCommentUpdated += HandleCommentUpdated;
        _client.OnCommentDeleted += HandleCommentDeleted;
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _client.OnCommentCreated -= HandleCommentCreated;
        _client.OnCommentUpdated -= HandleCommentUpdated;
        _client.OnCommentDeleted -= HandleCommentDeleted;
    }

    public IReadOnlyList<Comment> GetComments(Guid workItemId)
    {
        return _comments.Values
            .Where(c => c.WorkItemId == workItemId && c.DeletedAt == null)
            .OrderBy(c => c.CreatedAt)
            .ToList();
    }

    public bool IsPending(Guid commentId)
    {
        return _pendingUpdates.ContainsKey(commentId);
    }

    public async Task<Comment> CreateAsync(
        CreateCommentRequest request,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();

        // Create optimistic comment with temporary ID
        var tempId = Guid.NewGuid();
        var optimistic = new Comment
        {
            Id = tempId,
            WorkItemId = request.WorkItemId,
            Content = request.Content,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
            CreatedBy = Guid.Empty, // Will be set by server
            UpdatedBy = Guid.Empty
        };

        // Optimistic update
        _comments[tempId] = optimistic;
        _pendingUpdates[tempId] = true;
        NotifyChanged();

        try
        {
            var confirmed = await _client.CreateCommentAsync(request, ct);

            // Replace temp with confirmed
            _comments.TryRemove(tempId, out _);
            _comments[confirmed.Id] = confirmed;
            _pendingUpdates.TryRemove(tempId, out _);
            NotifyChanged();

            _logger.LogDebug("Comment created: {Id}", confirmed.Id);
            return confirmed;
        }
        catch
        {
            // Rollback
            _comments.TryRemove(tempId, out _);
            _pendingUpdates.TryRemove(tempId, out _);
            NotifyChanged();
            throw;
        }
    }

    public async Task<Comment> UpdateAsync(
        UpdateCommentRequest request,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_comments.TryGetValue(request.CommentId, out var current))
            throw new KeyNotFoundException($"Comment not found: {request.CommentId}");

        // Optimistic update
        var optimistic = current with
        {
            Content = request.Content,
            UpdatedAt = DateTime.UtcNow
        };

        var previousValue = _comments[request.CommentId];
        _comments[request.CommentId] = optimistic;
        _pendingUpdates[request.CommentId] = true;
        NotifyChanged();

        try
        {
            var confirmed = await _client.UpdateCommentAsync(request, ct);
            _comments[request.CommentId] = confirmed;
            _pendingUpdates.TryRemove(request.CommentId, out _);
            NotifyChanged();
            return confirmed;
        }
        catch
        {
            // Rollback
            _comments[request.CommentId] = previousValue;
            _pendingUpdates.TryRemove(request.CommentId, out _);
            NotifyChanged();
            throw;
        }
    }

    public async Task DeleteAsync(Guid commentId, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_comments.TryGetValue(commentId, out var current))
            throw new KeyNotFoundException($"Comment not found: {commentId}");

        // Optimistic delete (soft delete)
        var optimistic = current with { DeletedAt = DateTime.UtcNow };
        _comments[commentId] = optimistic;
        _pendingUpdates[commentId] = true;
        NotifyChanged();

        try
        {
            await _client.DeleteCommentAsync(commentId, ct);
            _pendingUpdates.TryRemove(commentId, out _);
            NotifyChanged();
            _logger.LogDebug("Comment deleted: {Id}", commentId);
        }
        catch
        {
            // Rollback
            _comments[commentId] = current;
            _pendingUpdates.TryRemove(commentId, out _);
            NotifyChanged();
            throw;
        }
    }

    public async Task RefreshAsync(Guid workItemId, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        var comments = await _client.GetCommentsAsync(workItemId, ct);

        // Remove existing comments for this work item
        var toRemove = _comments.Values
            .Where(c => c.WorkItemId == workItemId)
            .Select(c => c.Id)
            .ToList();

        foreach (var id in toRemove)
            _comments.TryRemove(id, out _);

        // Add fetched comments
        foreach (var comment in comments)
            _comments[comment.Id] = comment;

        NotifyChanged();
        _logger.LogDebug("Refreshed {Count} comments for work item {WorkItemId}", comments.Count, workItemId);
    }

    #region WebSocket Event Handlers

    private void HandleCommentCreated(Comment comment)
    {
        if (_pendingUpdates.ContainsKey(comment.Id)) return;

        _comments[comment.Id] = comment;
        NotifyChanged();
        _logger.LogDebug("Received comment created: {Id}", comment.Id);
    }

    private void HandleCommentUpdated(Comment comment)
    {
        if (_pendingUpdates.ContainsKey(comment.Id)) return;

        _comments[comment.Id] = comment;
        NotifyChanged();
        _logger.LogDebug("Received comment updated: {Id}", comment.Id);
    }

    private void HandleCommentDeleted(Guid id)
    {
        if (_pendingUpdates.ContainsKey(id)) return;

        if (_comments.TryGetValue(id, out var comment))
        {
            _comments[id] = comment with { DeletedAt = DateTime.UtcNow };
            NotifyChanged();
        }
        _logger.LogDebug("Received comment deleted: {Id}", id);
    }

    #endregion

    private void NotifyChanged() => OnChanged?.Invoke();

    private void ThrowIfDisposed()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
    }
}
```

**Verification**: `just build-cs-services`

---

### Step 3: Create SprintCard Component

**Create**: `frontend/ProjectManagement.Components/Sprint/SprintCard.razor`

```razor
@using ProjectManagement.Core.Models

<div class="sprint-card @StatusClass" @onclick="OnClick">
    <div class="sprint-header">
        <RadzenText TextStyle="TextStyle.Subtitle1" class="sprint-name">
            @Sprint.Name
        </RadzenText>
        <RadzenBadge BadgeStyle="@BadgeStyle" Text="@Sprint.Status.ToString()" />
    </div>

    @if (!string.IsNullOrEmpty(Sprint.Goal))
    {
        <RadzenText TextStyle="TextStyle.Body2" class="sprint-goal">
            @Sprint.Goal
        </RadzenText>
    }

    <div class="sprint-dates">
        <RadzenIcon Icon="event" />
        <span>@Sprint.StartDate.ToString("MMM d") - @Sprint.EndDate.ToString("MMM d, yyyy")</span>
    </div>

    @if (ShowProgress)
    {
        <div class="sprint-progress">
            <RadzenProgressBar Value="@Progress" ShowValue="true" />
            <RadzenText TextStyle="TextStyle.Caption">
                @CompletedItems / @TotalItems items
            </RadzenText>
        </div>
    }

    <div class="sprint-actions">
        @if (Sprint.Status == SprintStatus.Planned && CanStart)
        {
            <RadzenButton Text="Start Sprint" ButtonStyle="ButtonStyle.Primary"
                          Size="ButtonSize.Small" Click="OnStartClick" />
        }
        @if (Sprint.Status == SprintStatus.Active && CanComplete)
        {
            <RadzenButton Text="Complete" ButtonStyle="ButtonStyle.Success"
                          Size="ButtonSize.Small" Click="OnCompleteClick" />
        }
        @if (CanEdit)
        {
            <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light"
                          Size="ButtonSize.Small" Click="OnEditClick" />
        }
        @if (CanDelete && Sprint.Status != SprintStatus.Completed)
        {
            <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger"
                          Size="ButtonSize.Small" Click="OnDeleteClick" />
        }
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public Sprint Sprint { get; set; } = default!;

    [Parameter]
    public bool ShowProgress { get; set; } = true;

    [Parameter]
    public int TotalItems { get; set; }

    [Parameter]
    public int CompletedItems { get; set; }

    [Parameter]
    public bool CanStart { get; set; }

    [Parameter]
    public bool CanComplete { get; set; }

    [Parameter]
    public bool CanEdit { get; set; }

    [Parameter]
    public bool CanDelete { get; set; }

    [Parameter]
    public EventCallback OnClick { get; set; }

    [Parameter]
    public EventCallback OnStartClick { get; set; }

    [Parameter]
    public EventCallback OnCompleteClick { get; set; }

    [Parameter]
    public EventCallback OnEditClick { get; set; }

    [Parameter]
    public EventCallback OnDeleteClick { get; set; }

    private double Progress => TotalItems > 0 ? (double)CompletedItems / TotalItems * 100 : 0;

    private string StatusClass => Sprint.Status switch
    {
        SprintStatus.Planned => "status-planned",
        SprintStatus.Active => "status-active",
        SprintStatus.Completed => "status-completed",
        SprintStatus.Cancelled => "status-cancelled",
        _ => ""
    };

    private BadgeStyle BadgeStyle => Sprint.Status switch
    {
        SprintStatus.Planned => BadgeStyle.Secondary,
        SprintStatus.Active => BadgeStyle.Primary,
        SprintStatus.Completed => BadgeStyle.Success,
        SprintStatus.Cancelled => BadgeStyle.Warning,
        _ => BadgeStyle.Light
    };
}
```

**Create**: `frontend/ProjectManagement.Components/Sprint/SprintCard.razor.css`

```css
.sprint-card {
    padding: 1rem;
    border-radius: 8px;
    background: var(--rz-panel-background-color);
    border: 1px solid var(--rz-border-color);
    cursor: pointer;
    transition: box-shadow 0.2s;
}

.sprint-card:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.sprint-card.status-active {
    border-left: 4px solid var(--rz-primary);
}

.sprint-card.status-completed {
    border-left: 4px solid var(--rz-success);
}

.sprint-card.status-cancelled {
    opacity: 0.7;
}

.sprint-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.sprint-name {
    font-weight: 600;
}

.sprint-goal {
    color: var(--rz-text-secondary-color);
    margin-bottom: 0.5rem;
}

.sprint-dates {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--rz-text-secondary-color);
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
}

.sprint-progress {
    margin: 0.5rem 0;
}

.sprint-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
}
```

**Verification**: `just build-cs-components`

---

### Step 4: Create SprintDialog Component

**Create**: `frontend/ProjectManagement.Components/Sprint/SprintDialog.razor`

```razor
@using ProjectManagement.Core.Models

<RadzenDialog>
    <RadzenTemplateForm TItem="SprintFormModel" Data="@_model" Submit="OnSubmit">
        <RadzenStack Gap="1rem">
            <RadzenFormField Text="Name" Variant="Variant.Outlined">
                <RadzenTextBox @bind-Value="_model.Name" Name="Name" />
                <RadzenRequiredValidator Component="Name" Text="Name is required" />
                <RadzenLengthValidator Component="Name" Min="1" Max="100"
                                       Text="Name must be 1-100 characters" />
            </RadzenFormField>

            <RadzenFormField Text="Goal" Variant="Variant.Outlined">
                <RadzenTextArea @bind-Value="_model.Goal" Name="Goal" Rows="3" />
                <RadzenLengthValidator Component="Goal" Max="500"
                                       Text="Goal must be 500 characters or less" />
            </RadzenFormField>

            <RadzenRow Gap="1rem">
                <RadzenColumn Size="6">
                    <RadzenFormField Text="Start Date" Variant="Variant.Outlined">
                        <RadzenDatePicker @bind-Value="_model.StartDate" Name="StartDate"
                                          DateFormat="yyyy-MM-dd" />
                        <RadzenRequiredValidator Component="StartDate" Text="Start date is required" />
                    </RadzenFormField>
                </RadzenColumn>
                <RadzenColumn Size="6">
                    <RadzenFormField Text="End Date" Variant="Variant.Outlined">
                        <RadzenDatePicker @bind-Value="_model.EndDate" Name="EndDate"
                                          DateFormat="yyyy-MM-dd" />
                        <RadzenRequiredValidator Component="EndDate" Text="End date is required" />
                        <RadzenCompareValidator Component="EndDate"
                                                Value="@_model.StartDate"
                                                Operator="CompareOperator.GreaterThan"
                                                Text="End date must be after start date" />
                    </RadzenFormField>
                </RadzenColumn>
            </RadzenRow>

            @if (IsEdit)
            {
                <RadzenFormField Text="Status" Variant="Variant.Outlined">
                    <RadzenDropDown @bind-Value="_model.Status" Name="Status"
                                    Data="@_availableStatuses"
                                    TextProperty="Text" ValueProperty="Value" />
                </RadzenFormField>
            }

            <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.End" Gap="0.5rem">
                <RadzenButton Text="Cancel" ButtonStyle="ButtonStyle.Light"
                              Click="OnCancel" />
                <RadzenButton Text="@(IsEdit ? "Save" : "Create")"
                              ButtonStyle="ButtonStyle.Primary"
                              ButtonType="ButtonType.Submit" />
            </RadzenStack>
        </RadzenStack>
    </RadzenTemplateForm>
</RadzenDialog>

@code {
    [Parameter]
    public Sprint? Sprint { get; set; }

    [Parameter]
    public Guid ProjectId { get; set; }

    [Parameter]
    public EventCallback<CreateSprintRequest> OnCreate { get; set; }

    [Parameter]
    public EventCallback<UpdateSprintRequest> OnUpdate { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    private SprintFormModel _model = new();
    private bool IsEdit => Sprint != null;

    private List<StatusOption> _availableStatuses = new();

    protected override void OnInitialized()
    {
        if (Sprint != null)
        {
            _model = new SprintFormModel
            {
                Name = Sprint.Name,
                Goal = Sprint.Goal ?? "",
                StartDate = Sprint.StartDate,
                EndDate = Sprint.EndDate,
                Status = Sprint.Status
            };

            // Determine available status transitions
            _availableStatuses = GetAvailableStatuses(Sprint.Status);
        }
        else
        {
            // Default dates for new sprint
            _model.StartDate = DateTime.Today;
            _model.EndDate = DateTime.Today.AddDays(14);
        }
    }

    private List<StatusOption> GetAvailableStatuses(SprintStatus current)
    {
        var options = new List<StatusOption> { new(current.ToString(), current) };

        return current switch
        {
            SprintStatus.Planned => new List<StatusOption>
            {
                new("Planned", SprintStatus.Planned),
                new("Active (Start Sprint)", SprintStatus.Active),
                new("Cancelled", SprintStatus.Cancelled)
            },
            SprintStatus.Active => new List<StatusOption>
            {
                new("Active", SprintStatus.Active),
                new("Completed", SprintStatus.Completed),
                new("Cancelled", SprintStatus.Cancelled)
            },
            _ => options
        };
    }

    private async Task OnSubmit()
    {
        if (IsEdit)
        {
            var request = new UpdateSprintRequest
            {
                SprintId = Sprint!.Id,
                ExpectedVersion = Sprint.Version,
                Name = _model.Name != Sprint.Name ? _model.Name : null,
                Goal = _model.Goal != Sprint.Goal ? _model.Goal : null,
                StartDate = _model.StartDate != Sprint.StartDate ? _model.StartDate : null,
                EndDate = _model.EndDate != Sprint.EndDate ? _model.EndDate : null,
                Status = _model.Status != Sprint.Status ? _model.Status : null
            };
            await OnUpdate.InvokeAsync(request);
        }
        else
        {
            var request = new CreateSprintRequest
            {
                ProjectId = ProjectId,
                Name = _model.Name,
                Goal = string.IsNullOrWhiteSpace(_model.Goal) ? null : _model.Goal,
                StartDate = _model.StartDate!.Value,
                EndDate = _model.EndDate!.Value
            };
            await OnCreate.InvokeAsync(request);
        }
    }

    private class SprintFormModel
    {
        public string Name { get; set; } = "";
        public string Goal { get; set; } = "";
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }
        public SprintStatus Status { get; set; } = SprintStatus.Planned;
    }

    private record StatusOption(string Text, SprintStatus Value);
}
```

**Verification**: `just build-cs-components`

---

### Step 5: Create CommentList Component

**Create**: `frontend/ProjectManagement.Components/Comments/CommentList.razor`

```razor
@using ProjectManagement.Core.Interfaces
@using ProjectManagement.Core.Models
@inject ICommentStore CommentStore

<div class="comment-list">
    @if (IsLoading)
    {
        <RadzenProgressBar Mode="ProgressBarMode.Indeterminate" />
    }
    else if (!Comments.Any())
    {
        <RadzenText TextStyle="TextStyle.Body2" class="no-comments">
            No comments yet. Be the first to comment!
        </RadzenText>
    }
    else
    {
        @foreach (var comment in Comments)
        {
            <div class="comment @(CommentStore.IsPending(comment.Id) ? "pending" : "")">
                <div class="comment-header">
                    <RadzenText TextStyle="TextStyle.Subtitle2">
                        @GetUserName(comment.CreatedBy)
                    </RadzenText>
                    <RadzenText TextStyle="TextStyle.Caption" class="comment-time">
                        @FormatTime(comment.CreatedAt)
                        @if (comment.UpdatedAt > comment.CreatedAt.AddSeconds(1))
                        {
                            <span class="edited">(edited)</span>
                        }
                    </RadzenText>
                </div>

                @if (_editingCommentId == comment.Id)
                {
                    <CommentEditor InitialContent="@comment.Content"
                                   OnSubmit="content => HandleUpdateComment(comment.Id, content)"
                                   OnCancel="() => _editingCommentId = null"
                                   SubmitText="Save" />
                }
                else
                {
                    <RadzenText TextStyle="TextStyle.Body2" class="comment-content">
                        @comment.Content
                    </RadzenText>

                    @if (CanEditComment(comment))
                    {
                        <div class="comment-actions">
                            <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light"
                                          Size="ButtonSize.ExtraSmall"
                                          Click="() => _editingCommentId = comment.Id" />
                            <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger"
                                          Size="ButtonSize.ExtraSmall"
                                          Click="() => HandleDeleteComment(comment.Id)" />
                        </div>
                    }
                }
            </div>
        }
    }

    <div class="new-comment">
        <CommentEditor OnSubmit="HandleCreateComment"
                       Placeholder="Write a comment..." />
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public Guid WorkItemId { get; set; }

    [Parameter]
    public Guid CurrentUserId { get; set; }

    [Parameter]
    public Func<Guid, string>? UserNameResolver { get; set; }

    private IReadOnlyList<Comment> Comments => CommentStore.GetComments(WorkItemId);
    private bool IsLoading { get; set; }
    private Guid? _editingCommentId;

    protected override async Task OnInitializedAsync()
    {
        CommentStore.OnChanged += StateHasChanged;
        await LoadComments();
    }

    private async Task LoadComments()
    {
        IsLoading = true;
        try
        {
            await CommentStore.RefreshAsync(WorkItemId);
        }
        finally
        {
            IsLoading = false;
        }
    }

    private string GetUserName(Guid userId)
    {
        return UserNameResolver?.Invoke(userId) ?? userId.ToString()[..8];
    }

    private string FormatTime(DateTime time)
    {
        var diff = DateTime.UtcNow - time;
        return diff.TotalMinutes < 1 ? "just now" :
               diff.TotalHours < 1 ? $"{(int)diff.TotalMinutes}m ago" :
               diff.TotalDays < 1 ? $"{(int)diff.TotalHours}h ago" :
               diff.TotalDays < 7 ? $"{(int)diff.TotalDays}d ago" :
               time.ToString("MMM d");
    }

    private bool CanEditComment(Comment comment)
    {
        return comment.CreatedBy == CurrentUserId;
    }

    private async Task HandleCreateComment(string content)
    {
        await CommentStore.CreateAsync(new CreateCommentRequest
        {
            WorkItemId = WorkItemId,
            Content = content
        });
    }

    private async Task HandleUpdateComment(Guid commentId, string content)
    {
        await CommentStore.UpdateAsync(new UpdateCommentRequest
        {
            CommentId = commentId,
            Content = content
        });
        _editingCommentId = null;
    }

    private async Task HandleDeleteComment(Guid commentId)
    {
        await CommentStore.DeleteAsync(commentId);
    }

    public void Dispose()
    {
        CommentStore.OnChanged -= StateHasChanged;
    }
}
```

**Create**: `frontend/ProjectManagement.Components/Comments/CommentList.razor.css`

```css
.comment-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.comment {
    padding: 0.75rem;
    border-radius: 8px;
    background: var(--rz-base-200);
}

.comment.pending {
    opacity: 0.7;
}

.comment-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.25rem;
}

.comment-time {
    color: var(--rz-text-secondary-color);
}

.comment-time .edited {
    font-style: italic;
}

.comment-content {
    white-space: pre-wrap;
    word-break: break-word;
}

.comment-actions {
    display: flex;
    gap: 0.25rem;
    margin-top: 0.5rem;
    opacity: 0;
    transition: opacity 0.2s;
}

.comment:hover .comment-actions {
    opacity: 1;
}

.no-comments {
    text-align: center;
    color: var(--rz-text-secondary-color);
    padding: 1rem;
}

.new-comment {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--rz-border-color);
}
```

**Verification**: `just build-cs-components`

---

### Step 6: Create CommentEditor Component

**Create**: `frontend/ProjectManagement.Components/Comments/CommentEditor.razor`

```razor
<div class="comment-editor">
    <RadzenTextArea @bind-Value="_content"
                    Placeholder="@Placeholder"
                    Rows="@Rows"
                    @onkeydown="HandleKeyDown" />

    <div class="editor-actions">
        <RadzenText TextStyle="TextStyle.Caption" class="char-count">
            @_content.Length / 5000
        </RadzenText>

        <RadzenStack Orientation="Orientation.Horizontal" Gap="0.5rem">
            @if (OnCancel.HasDelegate)
            {
                <RadzenButton Text="Cancel" ButtonStyle="ButtonStyle.Light"
                              Size="ButtonSize.Small" Click="HandleCancel" />
            }
            <RadzenButton Text="@SubmitText" ButtonStyle="ButtonStyle.Primary"
                          Size="ButtonSize.Small"
                          Disabled="@(!CanSubmit)"
                          Click="HandleSubmit" />
        </RadzenStack>
    </div>
</div>

@code {
    [Parameter]
    public string InitialContent { get; set; } = "";

    [Parameter]
    public string Placeholder { get; set; } = "Write a comment...";

    [Parameter]
    public string SubmitText { get; set; } = "Comment";

    [Parameter]
    public int Rows { get; set; } = 3;

    [Parameter]
    public EventCallback<string> OnSubmit { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    private string _content = "";

    private bool CanSubmit => !string.IsNullOrWhiteSpace(_content) &&
                              _content.Length <= 5000;

    protected override void OnInitialized()
    {
        _content = InitialContent;
    }

    private async Task HandleSubmit()
    {
        if (!CanSubmit) return;

        await OnSubmit.InvokeAsync(_content.Trim());
        _content = "";
    }

    private async Task HandleCancel()
    {
        await OnCancel.InvokeAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Ctrl+Enter or Cmd+Enter to submit
        if (e.Key == "Enter" && (e.CtrlKey || e.MetaKey))
        {
            await HandleSubmit();
        }
    }
}
```

**Create**: `frontend/ProjectManagement.Components/Comments/CommentEditor.razor.css`

```css
.comment-editor {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.editor-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.char-count {
    color: var(--rz-text-secondary-color);
}
```

**Verification**: `just build-cs-components`

---

### Step 7: Register Services

**File**: `frontend/ProjectManagement.Services/DependencyInjection.cs`

**Add to service registration:**
```csharp
services.AddScoped<ICommentStore, CommentStore>();
```

**Verification**: `just build-frontend`

---

## Session 50.4 Completion Checklist

After completing all steps:

- [ ] `just build-frontend` passes
- [ ] `just test-frontend` passes
- [ ] `just check` passes

### Files Created (7)
- `ProjectManagement.Core/Interfaces/ICommentStore.cs`
- `ProjectManagement.Services/State/CommentStore.cs`
- `ProjectManagement.Components/Sprint/SprintCard.razor`
- `ProjectManagement.Components/Sprint/SprintCard.razor.css`
- `ProjectManagement.Components/Sprint/SprintDialog.razor`
- `ProjectManagement.Components/Comments/CommentList.razor`
- `ProjectManagement.Components/Comments/CommentList.razor.css`
- `ProjectManagement.Components/Comments/CommentEditor.razor`
- `ProjectManagement.Components/Comments/CommentEditor.razor.css`

### Files Modified (1)
- `ProjectManagement.Services/DependencyInjection.cs`

---

## Key Concepts Explained

### Blazor Component Lifecycle

```csharp
protected override async Task OnInitializedAsync()
{
    // Subscribe to store changes
    CommentStore.OnChanged += StateHasChanged;

    // Load initial data
    await LoadComments();
}

public void Dispose()
{
    // Unsubscribe when component is destroyed
    CommentStore.OnChanged -= StateHasChanged;
}
```

### Optimistic UI Pattern in Components

```razor
<div class="comment @(CommentStore.IsPending(comment.Id) ? "pending" : "")">
```

When a comment has a pending update, we apply a visual indicator (opacity) to show the user that the operation is in progress.

### Inline Editing Pattern

```csharp
@if (_editingCommentId == comment.Id)
{
    <CommentEditor ... />
}
else
{
    <div class="comment-content">@comment.Content</div>
}
```

The same space is used for viewing and editing, controlled by a simple state variable.

---

## Next Session

**Session 50.5** will implement:
- Backend handler tests (sprint, comment)
- Frontend converter tests
- Frontend store tests
