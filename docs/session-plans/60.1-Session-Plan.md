# Session 60.1: Protocol Definition & Backend Infrastructure

**Parent Plan**: `60-Session-Plan.md`
**Target**: ~40-50k tokens
**Prerequisites**: Existing codebase compiles (`just check`)

---

## Scope

This session implements the foundational protocol and infrastructure that all other components depend on:

1. **Protocol Definition** - Add WebSocket message types for time entry and dependency commands/events
2. **Validation Constants** - Add configuration limits for time entries and dependencies
3. **Message Validators** - Add timestamp and dependency type validation methods
4. **Response Builders** - Add converters and response builder functions
5. **Repository Extensions** - Add pagination and helper methods to existing repositories

---

## Implementation Order

### Step 1: Add Protocol Messages

**File**: `proto/messages.proto`

Add new message types after existing definitions. Use field numbers 110-139 in the `WebSocketMessage.payload` oneof.

```protobuf
// === Time Entry Commands (110-119) ===

message StartTimerRequest {
  string work_item_id = 1;
  optional string description = 2;
}

message StopTimerRequest {
  string time_entry_id = 1;
}

message CreateTimeEntryRequest {
  string work_item_id = 1;
  int64 started_at = 2;      // UTC Unix seconds
  int64 ended_at = 3;        // UTC Unix seconds
  optional string description = 4;
}

message UpdateTimeEntryRequest {
  string time_entry_id = 1;
  optional int64 started_at = 2;
  optional int64 ended_at = 3;
  optional string description = 4;
}

message DeleteTimeEntryRequest {
  string time_entry_id = 1;
}

message GetTimeEntriesRequest {
  string work_item_id = 1;
  optional int32 limit = 2;   // Default 100, max 500
  optional int32 offset = 3;  // For pagination
}

message GetRunningTimerRequest {}

// === Time Entry Events (120-129) ===

message TimerStarted {
  TimeEntry time_entry = 1;
  string user_id = 2;
  optional TimeEntry stopped_entry = 3;  // Previous timer that was auto-stopped
}

message TimerStopped {
  TimeEntry time_entry = 1;
  string user_id = 2;
}

message TimeEntryCreated {
  TimeEntry time_entry = 1;
  string user_id = 2;
}

message TimeEntryUpdated {
  TimeEntry time_entry = 1;
  string user_id = 2;
}

message TimeEntryDeleted {
  string time_entry_id = 1;
  string work_item_id = 2;  // For UI to know which list to update
  string user_id = 3;
}

message TimeEntriesList {
  repeated TimeEntry time_entries = 1;
  int32 total_count = 2;  // For pagination
}

message RunningTimerResponse {
  optional TimeEntry time_entry = 1;
}

// === Dependency Commands (130-134) ===

message CreateDependencyRequest {
  string blocking_item_id = 1;
  string blocked_item_id = 2;
  DependencyType dependency_type = 3;
}

message DeleteDependencyRequest {
  string dependency_id = 1;
}

message GetDependenciesRequest {
  string work_item_id = 1;
}

// === Dependency Events (135-139) ===

message DependencyCreated {
  Dependency dependency = 1;
  string user_id = 2;
}

message DependencyDeleted {
  string dependency_id = 1;
  string blocking_item_id = 2;  // For UI to know which lists to update
  string blocked_item_id = 3;
  string user_id = 4;
}

message DependenciesList {
  repeated Dependency blocking = 1;  // Items blocking this one
  repeated Dependency blocked = 2;   // Items blocked by this one
}
```

Then add to the `WebSocketMessage.payload` oneof (find existing oneof and add these):

```protobuf
// In the oneof payload section, add:

// Time Entry (110-119)
StartTimerRequest start_timer_request = 110;
StopTimerRequest stop_timer_request = 111;
CreateTimeEntryRequest create_time_entry_request = 112;
UpdateTimeEntryRequest update_time_entry_request = 113;
DeleteTimeEntryRequest delete_time_entry_request = 114;
GetTimeEntriesRequest get_time_entries_request = 115;
GetRunningTimerRequest get_running_timer_request = 116;

// Time Entry Events (120-129)
TimerStarted timer_started = 120;
TimerStopped timer_stopped = 121;
TimeEntryCreated time_entry_created = 122;
TimeEntryUpdated time_entry_updated = 123;
TimeEntryDeleted time_entry_deleted = 124;
TimeEntriesList time_entries_list = 125;
RunningTimerResponse running_timer_response = 126;

// Dependency Commands (130-134)
CreateDependencyRequest create_dependency_request = 130;
DeleteDependencyRequest delete_dependency_request = 131;
GetDependenciesRequest get_dependencies_request = 132;

// Dependency Events (135-139)
DependencyCreated dependency_created = 135;
DependencyDeleted dependency_deleted = 136;
DependenciesList dependencies_list = 137;
```

**Verification**: `just build-rs-proto`

---

### Step 2: Add Validation Constants

**File**: `backend/crates/pm-config/src/validation_config.rs`

Add these constants to the existing file:

```rust
// === Time Entry Limits ===

/// Maximum length for time entry description
pub const MAX_TIME_ENTRY_DESCRIPTION_LENGTH: usize = 1000;

/// Maximum duration for a single time entry (24 hours in seconds)
pub const MAX_TIME_ENTRY_DURATION_SECONDS: i64 = 86400;

/// Tolerance for future timestamps (60 seconds for clock drift)
pub const MAX_FUTURE_TIMESTAMP_TOLERANCE_SECONDS: i64 = 60;

/// Default number of time entries to return per page
pub const DEFAULT_TIME_ENTRIES_LIMIT: i32 = 100;

/// Maximum number of time entries to return per page
pub const MAX_TIME_ENTRIES_LIMIT: i32 = 500;

// === Dependency Limits ===

/// Maximum number of dependencies that can block a single item
pub const MAX_BLOCKING_DEPENDENCIES_PER_ITEM: usize = 50;

/// Maximum number of items that a single item can block
pub const MAX_BLOCKED_DEPENDENCIES_PER_ITEM: usize = 50;
```

**Verification**: `just check-rs-config`

---

### Step 3: Add Message Validators

**File**: `backend/crates/pm-ws/src/handlers/message_validator.rs`

Add these validation methods to the existing `MessageValidator` impl:

```rust
use pm_config::{
    MAX_TIME_ENTRY_DESCRIPTION_LENGTH,
    MAX_TIME_ENTRY_DURATION_SECONDS,
    MAX_FUTURE_TIMESTAMP_TOLERANCE_SECONDS,
};
use pm_core::DependencyType;
use pm_proto::DependencyType as ProtoDependencyType;
use chrono::Utc;

impl MessageValidator {
    /// Validate time entry description (optional, max 1000 chars)
    #[track_caller]
    pub fn validate_time_entry_description(description: Option<&str>) -> WsErrorResult<()> {
        if let Some(desc) = description {
            Self::validate_string(desc, "description", 0, MAX_TIME_ENTRY_DESCRIPTION_LENGTH)?;
        }
        Ok(())
    }

    /// Validate time entry timestamps for manual entry creation.
    /// Ensures:
    /// - Neither timestamp is in the future (with tolerance)
    /// - started_at is before ended_at
    /// - Duration doesn't exceed maximum (24 hours)
    #[track_caller]
    pub fn validate_time_entry_timestamps(started_at: i64, ended_at: i64) -> WsErrorResult<()> {
        let now = Utc::now().timestamp();

        // Cannot be in future (with tolerance for clock drift)
        if started_at > now + MAX_FUTURE_TIMESTAMP_TOLERANCE_SECONDS {
            return Err(WsError::ValidationError {
                message: "started_at cannot be in the future".into(),
                field: Some("started_at".into()),
                location: ErrorLocation::from(Location::caller()),
            });
        }
        if ended_at > now + MAX_FUTURE_TIMESTAMP_TOLERANCE_SECONDS {
            return Err(WsError::ValidationError {
                message: "ended_at cannot be in the future".into(),
                field: Some("ended_at".into()),
                location: ErrorLocation::from(Location::caller()),
            });
        }

        // Start must be before end
        if started_at >= ended_at {
            return Err(WsError::ValidationError {
                message: "started_at must be before ended_at".into(),
                field: Some("started_at".into()),
                location: ErrorLocation::from(Location::caller()),
            });
        }

        // Max duration check
        let duration = ended_at - started_at;
        if duration > MAX_TIME_ENTRY_DURATION_SECONDS {
            return Err(WsError::ValidationError {
                message: format!(
                    "Duration cannot exceed {} hours",
                    MAX_TIME_ENTRY_DURATION_SECONDS / 3600
                ),
                field: Some("ended_at".into()),
                location: ErrorLocation::from(Location::caller()),
            });
        }

        Ok(())
    }

    /// Validate dependency type enum from protobuf i32.
    /// Converts to domain DependencyType on success.
    #[track_caller]
    pub fn validate_dependency_type(value: i32) -> WsErrorResult<DependencyType> {
        match value {
            x if x == ProtoDependencyType::Blocks as i32 => Ok(DependencyType::Blocks),
            x if x == ProtoDependencyType::RelatesTo as i32 => Ok(DependencyType::RelatesTo),
            _ => Err(WsError::ValidationError {
                message: "Invalid dependency_type. Must be BLOCKS or RELATES_TO".into(),
                field: Some("dependency_type".into()),
                location: ErrorLocation::from(Location::caller()),
            }),
        }
    }
}
```

**Verification**: `just check-rs-ws`

---

### Step 4: Add Response Builders

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

Add converters and response builders. Place after existing builders:

```rust
use pm_core::{TimeEntry, Dependency, DependencyType};
use pm_proto::{
    TimeEntry as ProtoTimeEntry,
    Dependency as ProtoDependency,
    DependencyType as ProtoDependencyType,
    TimerStarted, TimerStopped,
    TimeEntryCreated, TimeEntryUpdated, TimeEntryDeleted,
    TimeEntriesList, RunningTimerResponse,
    DependencyCreated, DependencyDeleted, DependenciesList,
    WebSocketMessage, web_socket_message::Payload,
};
use chrono::Utc;
use uuid::Uuid;

// === Time Entry Converters ===

/// Convert domain TimeEntry to protobuf TimeEntry
pub fn time_entry_to_proto(entry: &TimeEntry) -> ProtoTimeEntry {
    ProtoTimeEntry {
        id: entry.id.to_string(),
        work_item_id: entry.work_item_id.to_string(),
        user_id: entry.user_id.to_string(),
        started_at: entry.started_at.timestamp(),
        ended_at: entry.ended_at.map(|dt| dt.timestamp()),
        duration_seconds: entry.duration_seconds,
        description: entry.description.clone(),
        created_at: entry.created_at.timestamp(),
        updated_at: entry.updated_at.timestamp(),
        deleted_at: entry.deleted_at.map(|dt| dt.timestamp()),
    }
}

/// Convert domain Dependency to protobuf Dependency
pub fn dependency_to_proto(dep: &Dependency) -> ProtoDependency {
    ProtoDependency {
        id: dep.id.to_string(),
        blocking_item_id: dep.blocking_item_id.to_string(),
        blocked_item_id: dep.blocked_item_id.to_string(),
        dependency_type: match dep.dependency_type {
            DependencyType::Blocks => ProtoDependencyType::Blocks as i32,
            DependencyType::RelatesTo => ProtoDependencyType::RelatesTo as i32,
        },
        created_at: dep.created_at.timestamp(),
        created_by: dep.created_by.to_string(),
        deleted_at: dep.deleted_at.map(|dt| dt.timestamp()),
    }
}

// === Time Entry Response Builders ===

/// Build TimerStarted response with optional stopped entry
pub fn build_timer_started_response(
    message_id: &str,
    entry: &TimeEntry,
    stopped_entry: Option<&TimeEntry>,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimerStarted(TimerStarted {
            time_entry: Some(time_entry_to_proto(entry)),
            user_id: user_id.to_string(),
            stopped_entry: stopped_entry.map(time_entry_to_proto),
        })),
    }
}

/// Build TimerStopped response
pub fn build_timer_stopped_response(
    message_id: &str,
    entry: &TimeEntry,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimerStopped(TimerStopped {
            time_entry: Some(time_entry_to_proto(entry)),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build TimeEntryCreated response
pub fn build_time_entry_created_response(
    message_id: &str,
    entry: &TimeEntry,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimeEntryCreated(TimeEntryCreated {
            time_entry: Some(time_entry_to_proto(entry)),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build TimeEntryUpdated response
pub fn build_time_entry_updated_response(
    message_id: &str,
    entry: &TimeEntry,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimeEntryUpdated(TimeEntryUpdated {
            time_entry: Some(time_entry_to_proto(entry)),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build TimeEntryDeleted response
pub fn build_time_entry_deleted_response(
    message_id: &str,
    time_entry_id: Uuid,
    work_item_id: Uuid,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimeEntryDeleted(TimeEntryDeleted {
            time_entry_id: time_entry_id.to_string(),
            work_item_id: work_item_id.to_string(),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build TimeEntriesList response with pagination info
pub fn build_time_entries_list_response(
    message_id: &str,
    entries: &[TimeEntry],
    total_count: i32,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::TimeEntriesList(TimeEntriesList {
            time_entries: entries.iter().map(time_entry_to_proto).collect(),
            total_count,
        })),
    }
}

/// Build RunningTimerResponse (may be empty if no running timer)
pub fn build_running_timer_response(
    message_id: &str,
    entry: Option<&TimeEntry>,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::RunningTimerResponse(RunningTimerResponse {
            time_entry: entry.map(time_entry_to_proto),
        })),
    }
}

// === Dependency Response Builders ===

/// Build DependencyCreated response
pub fn build_dependency_created_response(
    message_id: &str,
    dependency: &Dependency,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::DependencyCreated(DependencyCreated {
            dependency: Some(dependency_to_proto(dependency)),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build DependencyDeleted response
pub fn build_dependency_deleted_response(
    message_id: &str,
    dependency_id: Uuid,
    blocking_item_id: Uuid,
    blocked_item_id: Uuid,
    user_id: Uuid,
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::DependencyDeleted(DependencyDeleted {
            dependency_id: dependency_id.to_string(),
            blocking_item_id: blocking_item_id.to_string(),
            blocked_item_id: blocked_item_id.to_string(),
            user_id: user_id.to_string(),
        })),
    }
}

/// Build DependenciesList response with both directions
pub fn build_dependencies_list_response(
    message_id: &str,
    blocking: &[Dependency],
    blocked: &[Dependency],
) -> WebSocketMessage {
    WebSocketMessage {
        message_id: message_id.to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::DependenciesList(DependenciesList {
            blocking: blocking.iter().map(dependency_to_proto).collect(),
            blocked: blocked.iter().map(dependency_to_proto).collect(),
        })),
    }
}
```

**Verification**: `just check-rs-ws`

---

### Step 5: Extend Time Entry Repository

**File**: `backend/crates/pm-db/src/repositories/time_entry_repository.rs`

Add pagination support to the existing repository:

```rust
impl TimeEntryRepository {
    // ... existing methods ...

    /// Find time entries for a work item with pagination.
    /// Returns (entries, total_count) for pagination UI.
    /// Always filters deleted_at IS NULL.
    /// Orders by started_at DESC (most recent first).
    pub async fn find_by_work_item_paginated(
        &self,
        work_item_id: Uuid,
        limit: i32,
        offset: i32,
    ) -> DbErrorResult<(Vec<TimeEntry>, i32)> {
        let work_item_str = work_item_id.to_string();

        // Get total count (for pagination UI)
        let count_row = sqlx::query!(
            r#"SELECT COUNT(*) as "count: i32" FROM pm_time_entries
               WHERE work_item_id = ? AND deleted_at IS NULL"#,
            work_item_str
        )
        .fetch_one(&self.pool)
        .await?;
        let total_count = count_row.count.unwrap_or(0);

        // Get paginated entries
        let rows = sqlx::query!(
            r#"SELECT id, work_item_id, user_id, started_at, ended_at,
                      duration_seconds, description, created_at, updated_at, deleted_at
               FROM pm_time_entries
               WHERE work_item_id = ? AND deleted_at IS NULL
               ORDER BY started_at DESC
               LIMIT ? OFFSET ?"#,
            work_item_str,
            limit,
            offset
        )
        .fetch_all(&self.pool)
        .await?;

        let entries = rows
            .into_iter()
            .map(|row| TimeEntry {
                id: Uuid::parse_str(&row.id).unwrap_or_default(),
                work_item_id: Uuid::parse_str(&row.work_item_id).unwrap_or_default(),
                user_id: Uuid::parse_str(&row.user_id).unwrap_or_default(),
                started_at: DateTime::from_timestamp(row.started_at, 0)
                    .unwrap_or_default(),
                ended_at: row.ended_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
                duration_seconds: row.duration_seconds,
                description: row.description,
                created_at: DateTime::from_timestamp(row.created_at, 0)
                    .unwrap_or_default(),
                updated_at: DateTime::from_timestamp(row.updated_at, 0)
                    .unwrap_or_default(),
                deleted_at: row.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
            })
            .collect();

        Ok((entries, total_count))
    }
}
```

**Verification**: `just check-rs-db`

---

### Step 6: Extend Dependency Repository

**File**: `backend/crates/pm-db/src/repositories/dependency_repository.rs`

Add helper methods to the existing repository:

```rust
impl DependencyRepository {
    // ... existing methods ...

    /// Find existing dependency by pair (for duplicate check).
    /// Always filters deleted_at IS NULL.
    pub async fn find_by_pair(
        &self,
        blocking_item_id: Uuid,
        blocked_item_id: Uuid,
    ) -> DbErrorResult<Option<Dependency>> {
        let blocking_str = blocking_item_id.to_string();
        let blocked_str = blocked_item_id.to_string();

        let row = sqlx::query!(
            r#"SELECT id, blocking_item_id, blocked_item_id, dependency_type,
                      created_at, created_by, deleted_at
               FROM pm_dependencies
               WHERE blocking_item_id = ? AND blocked_item_id = ? AND deleted_at IS NULL"#,
            blocking_str,
            blocked_str
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(row.map(|r| Dependency {
            id: Uuid::parse_str(&r.id).unwrap_or_default(),
            blocking_item_id: Uuid::parse_str(&r.blocking_item_id).unwrap_or_default(),
            blocked_item_id: Uuid::parse_str(&r.blocked_item_id).unwrap_or_default(),
            dependency_type: DependencyType::from_str(&r.dependency_type)
                .unwrap_or(DependencyType::Blocks),
            created_at: DateTime::from_timestamp(r.created_at, 0).unwrap_or_default(),
            created_by: Uuid::parse_str(&r.created_by).unwrap_or_default(),
            deleted_at: r.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
        }))
    }

    /// Count how many items are blocking this item.
    /// Used for limit enforcement (max 50 blocking per item).
    pub async fn count_blocking(&self, blocked_item_id: Uuid) -> DbErrorResult<usize> {
        let id_str = blocked_item_id.to_string();
        let row = sqlx::query!(
            r#"SELECT COUNT(*) as "count: i32" FROM pm_dependencies
               WHERE blocked_item_id = ? AND deleted_at IS NULL"#,
            id_str
        )
        .fetch_one(&self.pool)
        .await?;
        Ok(row.count.unwrap_or(0) as usize)
    }

    /// Count how many items this item blocks.
    /// Used for limit enforcement (max 50 blocked per item).
    pub async fn count_blocked(&self, blocking_item_id: Uuid) -> DbErrorResult<usize> {
        let id_str = blocking_item_id.to_string();
        let row = sqlx::query!(
            r#"SELECT COUNT(*) as "count: i32" FROM pm_dependencies
               WHERE blocking_item_id = ? AND deleted_at IS NULL"#,
            id_str
        )
        .fetch_one(&self.pool)
        .await?;
        Ok(row.count.unwrap_or(0) as usize)
    }

    /// Find all dependencies where this item is blocked by others.
    /// Returns items that are blocking `work_item_id`.
    /// Always filters deleted_at IS NULL.
    pub async fn find_blocking(&self, work_item_id: Uuid) -> DbErrorResult<Vec<Dependency>> {
        let id_str = work_item_id.to_string();
        let rows = sqlx::query!(
            r#"SELECT id, blocking_item_id, blocked_item_id, dependency_type,
                      created_at, created_by, deleted_at
               FROM pm_dependencies
               WHERE blocked_item_id = ? AND deleted_at IS NULL
               ORDER BY created_at DESC"#,
            id_str
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(rows
            .into_iter()
            .map(|r| Dependency {
                id: Uuid::parse_str(&r.id).unwrap_or_default(),
                blocking_item_id: Uuid::parse_str(&r.blocking_item_id).unwrap_or_default(),
                blocked_item_id: Uuid::parse_str(&r.blocked_item_id).unwrap_or_default(),
                dependency_type: DependencyType::from_str(&r.dependency_type)
                    .unwrap_or(DependencyType::Blocks),
                created_at: DateTime::from_timestamp(r.created_at, 0).unwrap_or_default(),
                created_by: Uuid::parse_str(&r.created_by).unwrap_or_default(),
                deleted_at: r.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
            })
            .collect())
    }

    /// Find all dependencies where this item blocks others.
    /// Returns items that are blocked by `work_item_id`.
    /// Always filters deleted_at IS NULL.
    pub async fn find_blocked(&self, work_item_id: Uuid) -> DbErrorResult<Vec<Dependency>> {
        let id_str = work_item_id.to_string();
        let rows = sqlx::query!(
            r#"SELECT id, blocking_item_id, blocked_item_id, dependency_type,
                      created_at, created_by, deleted_at
               FROM pm_dependencies
               WHERE blocking_item_id = ? AND deleted_at IS NULL
               ORDER BY created_at DESC"#,
            id_str
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(rows
            .into_iter()
            .map(|r| Dependency {
                id: Uuid::parse_str(&r.id).unwrap_or_default(),
                blocking_item_id: Uuid::parse_str(&r.blocking_item_id).unwrap_or_default(),
                blocked_item_id: Uuid::parse_str(&r.blocked_item_id).unwrap_or_default(),
                dependency_type: DependencyType::from_str(&r.dependency_type)
                    .unwrap_or(DependencyType::Blocks),
                created_at: DateTime::from_timestamp(r.created_at, 0).unwrap_or_default(),
                created_by: Uuid::parse_str(&r.created_by).unwrap_or_default(),
                deleted_at: r.deleted_at.and_then(|ts| DateTime::from_timestamp(ts, 0)),
            })
            .collect())
    }
}
```

**Verification**: `just check-rs-db`

---

## Session 60.1 Completion Checklist

After completing all steps:

- [ ] `just build-rs-proto` passes (protobuf compiles)
- [ ] `just check-rs-config` passes
- [ ] `just check-rs-db` passes
- [ ] `just check-rs-ws` passes
- [ ] `just check-backend` passes (all backend compiles)
- [ ] `just clippy-backend` passes (no warnings)

### Files Modified (6)

| File | Change |
|------|--------|
| `proto/messages.proto` | Added 20+ message types for time entry and dependency |
| `pm-config/src/validation_config.rs` | Added 7 validation constants |
| `pm-ws/src/handlers/message_validator.rs` | Added 3 validation methods |
| `pm-ws/src/handlers/response_builder.rs` | Added 2 converters + 10 response builders |
| `pm-db/src/repositories/time_entry_repository.rs` | Added `find_by_work_item_paginated` |
| `pm-db/src/repositories/dependency_repository.rs` | Added 5 helper methods |

---

## Key Concepts Introduced

### Time Entry Timestamps
- All timestamps are **UTC Unix seconds** (i64)
- `started_at` marks when timer started
- `ended_at` is NULL for running timers
- `duration_seconds` is calculated on stop: `ended_at - started_at`

### Dependency Types
- `Blocks` - Blocking relationship (cannot start until blocker is done)
- `RelatesTo` - Informational relationship (no restrictions)

### Pagination Pattern
- `limit` controls page size (default 100, max 500)
- `offset` controls starting position
- Response includes `total_count` for pagination UI
- Results ordered by `started_at DESC` (most recent first)

---

## Next Session

**Session 60.2** will implement:
- Time Entry handler with atomic timer operations
- Dependency handler with cycle detection
- Dispatcher wiring for 10 new message types
