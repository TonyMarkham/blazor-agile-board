# Session 60.2: Backend Handlers (Time Entry & Dependency)

**Parent Plan**: `60-Session-Plan.md`
**Prerequisite**: Session 60.1 completed
**Target**: ~45-55k tokens
**Status**: ✅ Complete (2026-01-27)

---

## Completion Summary

**What Was Delivered:**
- ✅ 7 time entry handlers with atomic timer operations
- ✅ 3 dependency handlers with BFS cycle detection
- ✅ 10 handlers wired to dispatcher
- ✅ Owner-only mutations enforced
- ✅ Complete business rule validation
- ✅ Activity logging for all mutations
- ✅ Idempotency support
- ✅ Production-grade error handling

**Files Created (2):**
- `pm-ws/src/handlers/time_entry.rs` (582 lines, 19,664 bytes)
- `pm-ws/src/handlers/dependency.rs` (456 lines, 14,021 bytes)

**Files Modified (4):**
- `pm-config/src/lib.rs` - Exported MAX_BLOCKING/BLOCKED_DEPENDENCIES constants
- `pm-ws/src/handlers/dispatcher.rs` - Added 10 handler dispatch cases
- `pm-ws/src/handlers/mod.rs` - Exported time_entry and dependency modules
- `pm-ws/tests/sprint_handler_tests.rs` - Fixed clippy warning (as_deref)

**Build Status:**
- ✅ `just check-backend` - Clean compilation
- ✅ `just clippy-backend` - Zero warnings
- ✅ `just test-backend` - 219 tests passing

**Quality Metrics:**
- Zero shortcuts or TODOs
- Complete error handling with context
- All business rules enforced
- Permission checks (Edit for mutations, View for queries)
- Soft deletes throughout
- Idempotency for mutation operations

---

## Scope

This session implements the backend handler logic for time tracking and dependencies:

1. **Time Entry Handler** - 7 handlers with atomic timer operations and owner-only mutations
2. **Dependency Handler** - 3 handlers with cycle detection using BFS
3. **Dispatcher Wiring** - Connect 10 new handlers to the message dispatcher

---

## Prerequisites Check

Before starting, verify Session 60.1 is complete:

```bash
just check-backend  # Should pass
```

Ensure these exist:
- New message types in `proto/messages.proto`
- Validation constants in `pm-config/src/validation_config.rs`
- Validation methods in `pm-ws/src/handlers/message_validator.rs`
- Response builders in `pm-ws/src/handlers/response_builder.rs`
- Repository methods in `pm-db`

---

## Implementation Order

### Step 1: Create Time Entry Handler

**Create**: `backend/crates/pm-ws/src/handlers/time_entry.rs`

```rust
//! Time entry handlers with atomic timer operations.
//!
//! # Business Rules
//!
//! - Only ONE running timer per user at any time
//! - StartTimer is ATOMIC: check-stop-create in single transaction
//! - Owner-only for edit/delete operations
//! - All timestamps in UTC Unix seconds
//!
//! # Handlers
//!
//! - `handle_start_timer` - Start timer (auto-stops any existing)
//! - `handle_stop_timer` - Stop running timer
//! - `handle_create_time_entry` - Create manual (completed) entry
//! - `handle_update_time_entry` - Update entry (owner-only)
//! - `handle_delete_time_entry` - Soft delete entry (owner-only)
//! - `handle_get_time_entries` - List entries for work item (paginated)
//! - `handle_get_running_timer` - Get current user's running timer

use crate::handlers::{
    authorization::check_permission,
    context::HandlerContext,
    db_ops::{db_read, db_write},
    idempotency::{check_idempotency, store_idempotency_non_fatal, decode_cached_response},
    message_validator::MessageValidator,
    response_builder::*,
    work_item::sanitize_string,
};
use crate::{Result as WsErrorResult, WsError};
use chrono::{DateTime, Utc};
use error_location::ErrorLocation;
use log::{debug, info, warn};
use pm_config::{DEFAULT_TIME_ENTRIES_LIMIT, MAX_TIME_ENTRIES_LIMIT};
use pm_core::{ActivityLog, Permission, TimeEntry};
use pm_db::{ActivityLogRepository, TimeEntryRepository, WorkItemRepository};
use pm_proto::{
    CreateTimeEntryRequest, DeleteTimeEntryRequest, GetRunningTimerRequest,
    GetTimeEntriesRequest, StartTimerRequest, StopTimerRequest, UpdateTimeEntryRequest,
    WebSocketMessage,
};
use std::panic::Location;
use uuid::Uuid;

/// Parse UUID string with descriptive error
fn parse_uuid(s: &str, field: &str) -> WsErrorResult<Uuid> {
    Uuid::parse_str(s).map_err(|_| WsError::ValidationError {
        message: format!("Invalid UUID format for {}", field),
        field: Some(field.to_string()),
        location: ErrorLocation::from(Location::caller()),
    })
}

/// Start a timer on a work item.
///
/// # Atomicity
///
/// This operation is atomic: if the user has an existing running timer,
/// it is stopped in the same transaction as creating the new timer.
/// This prevents race conditions where a user could have multiple timers.
///
/// # Returns
///
/// - `TimerStarted` with the new entry and optionally the stopped entry
pub async fn handle_start_timer(
    req: StartTimerRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} StartTimer starting", ctx.log_prefix());

    // 1. Validate description if provided
    MessageValidator::validate_time_entry_description(req.description.as_deref())?;

    // 2. Parse work_item_id
    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // 3. Check idempotency
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;
    if let Some(cached_response) = cached {
        info!("{} Returning cached idempotent response for StartTimer", ctx.log_prefix());
        return decode_cached_response(&cached_response);
    }

    // 4. Verify work item exists and get project_id
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::new(ctx.pool.clone())
            .find_by_id(work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem".into(),
        id: work_item_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 5. Check Edit permission on project
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::Edit).await
    })
    .await?;

    // 6. ATOMIC TRANSACTION: Stop existing timer + Create new timer
    let (new_entry, stopped_entry) = db_write(&ctx, "start_timer_atomic", || async {
        let repo = TimeEntryRepository::new(ctx.pool.clone());
        let activity_repo = ActivityLogRepository::new(ctx.pool.clone());

        // Find and stop any running timer for this user
        let running_timers = repo.find_running(ctx.user_id).await?;
        let stopped = if let Some(mut running) = running_timers.into_iter().next() {
            let now = Utc::now();
            running.ended_at = Some(now);
            running.duration_seconds = Some(
                (now.timestamp() - running.started_at.timestamp()) as i32
            );
            running.updated_at = now;
            repo.update(&running).await?;

            // Activity log for auto-stopped timer
            let activity = ActivityLog::updated(
                "time_entry",
                running.id,
                ctx.user_id,
                &[("ended_at", "auto-stopped by new timer")],
            );
            activity_repo.create(&activity).await?;

            Some(running)
        } else {
            None
        };

        // Create new timer
        let new_timer = TimeEntry::new_running(
            work_item_id,
            ctx.user_id,
            req.description.as_ref().map(|d| sanitize_string(d)),
        );
        repo.create(&new_timer).await?;

        // Activity log for new timer
        let activity = ActivityLog::created("time_entry", new_timer.id, ctx.user_id);
        activity_repo.create(&activity).await?;

        Ok::<_, WsError>((new_timer, stopped))
    })
    .await?;

    // 7. Build response
    let response = build_timer_started_response(
        &ctx.message_id,
        &new_entry,
        stopped_entry.as_ref(),
        ctx.user_id,
    );

    // 8. Store idempotency (non-fatal if fails)
    store_idempotency_non_fatal(&ctx, "start_timer", &response).await;

    info!(
        "{} Started timer {} on work item {}, stopped previous: {}",
        ctx.log_prefix(),
        new_entry.id,
        work_item_id,
        stopped_entry.is_some()
    );

    Ok(response)
}

/// Stop a running timer.
///
/// # Owner-Only
///
/// Only the user who created the timer can stop it.
///
/// # Returns
///
/// - `TimerStopped` with the updated entry (now with ended_at and duration)
pub async fn handle_stop_timer(
    req: StopTimerRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} StopTimer starting", ctx.log_prefix());

    // 1. Parse time_entry_id
    let time_entry_id = parse_uuid(&req.time_entry_id, "time_entry_id")?;

    // 2. Check idempotency
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;
    if let Some(cached_response) = cached {
        info!("{} Returning cached idempotent response for StopTimer", ctx.log_prefix());
        return decode_cached_response(&cached_response);
    }

    // 3. Find the time entry
    let repo = TimeEntryRepository::new(ctx.pool.clone());
    let mut entry = db_read(&ctx, "find_time_entry", || async {
        repo.find_by_id(time_entry_id).await.map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "TimeEntry".into(),
        id: time_entry_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 4. OWNER-ONLY: Verify ownership
    if entry.user_id != ctx.user_id {
        return Err(WsError::Unauthorized {
            message: "Cannot stop another user's timer".into(),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 5. Check if already stopped
    if entry.ended_at.is_some() {
        return Err(WsError::ValidationError {
            message: "Timer is not running".into(),
            field: Some("time_entry_id".into()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 6. Stop the timer
    let now = Utc::now();
    entry.ended_at = Some(now);
    entry.duration_seconds = Some((now.timestamp() - entry.started_at.timestamp()) as i32);
    entry.updated_at = now;

    db_write(&ctx, "stop_timer", || async {
        let repo = TimeEntryRepository::new(ctx.pool.clone());
        repo.update(&entry).await?;

        let activity = ActivityLog::updated(
            "time_entry",
            entry.id,
            ctx.user_id,
            &[("ended_at", &entry.ended_at.unwrap().to_rfc3339())],
        );
        ActivityLogRepository::new(ctx.pool.clone())
            .create(&activity)
            .await?;

        Ok::<_, WsError>(())
    })
    .await?;

    // 7. Build response
    let response = build_timer_stopped_response(&ctx.message_id, &entry, ctx.user_id);

    // 8. Store idempotency
    store_idempotency_non_fatal(&ctx, "stop_timer", &response).await;

    info!(
        "{} Stopped timer {}, duration: {}s",
        ctx.log_prefix(),
        entry.id,
        entry.duration_seconds.unwrap_or(0)
    );

    Ok(response)
}

/// Create a manual time entry (already completed).
///
/// Use this for logging time after the fact, not for running timers.
///
/// # Validation
///
/// - `started_at` must be before `ended_at`
/// - Neither can be in the future (60s tolerance)
/// - Duration cannot exceed 24 hours
pub async fn handle_create_time_entry(
    req: CreateTimeEntryRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} CreateTimeEntry starting", ctx.log_prefix());

    // 1. Validate timestamps
    MessageValidator::validate_time_entry_timestamps(req.started_at, req.ended_at)?;
    MessageValidator::validate_time_entry_description(req.description.as_deref())?;

    // 2. Parse work_item_id
    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // 3. Check idempotency
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;
    if let Some(cached_response) = cached {
        info!("{} Returning cached idempotent response", ctx.log_prefix());
        return decode_cached_response(&cached_response);
    }

    // 4. Verify work item exists, check Edit permission
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::new(ctx.pool.clone())
            .find_by_id(work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem".into(),
        id: work_item_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::Edit).await
    })
    .await?;

    // 5. Create entry with explicit timestamps
    let started_at = DateTime::from_timestamp(req.started_at, 0).ok_or_else(|| {
        WsError::ValidationError {
            message: "Invalid started_at timestamp".into(),
            field: Some("started_at".into()),
            location: ErrorLocation::from(Location::caller()),
        }
    })?;
    let ended_at = DateTime::from_timestamp(req.ended_at, 0).ok_or_else(|| {
        WsError::ValidationError {
            message: "Invalid ended_at timestamp".into(),
            field: Some("ended_at".into()),
            location: ErrorLocation::from(Location::caller()),
        }
    })?;

    let duration_seconds = (req.ended_at - req.started_at) as i32;
    let now = Utc::now();

    let entry = TimeEntry {
        id: Uuid::new_v4(),
        work_item_id,
        user_id: ctx.user_id,
        started_at,
        ended_at: Some(ended_at),
        duration_seconds: Some(duration_seconds),
        description: req.description.as_ref().map(|d| sanitize_string(d)),
        created_at: now,
        updated_at: now,
        deleted_at: None,
    };

    // 6. Save with activity log
    db_write(&ctx, "create_time_entry", || async {
        TimeEntryRepository::new(ctx.pool.clone())
            .create(&entry)
            .await?;
        let activity = ActivityLog::created("time_entry", entry.id, ctx.user_id);
        ActivityLogRepository::new(ctx.pool.clone())
            .create(&activity)
            .await?;
        Ok::<_, WsError>(())
    })
    .await?;

    // 7. Build response
    let response = build_time_entry_created_response(&ctx.message_id, &entry, ctx.user_id);

    // 8. Store idempotency
    store_idempotency_non_fatal(&ctx, "create_time_entry", &response).await;

    info!(
        "{} Created manual time entry {} for {} ({}s)",
        ctx.log_prefix(),
        entry.id,
        work_item_id,
        duration_seconds
    );

    Ok(response)
}

/// Update a time entry (owner-only).
///
/// # Validation
///
/// - If changing timestamps, same rules as create apply
/// - Only owner can update
pub async fn handle_update_time_entry(
    req: UpdateTimeEntryRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} UpdateTimeEntry starting", ctx.log_prefix());

    let time_entry_id = parse_uuid(&req.time_entry_id, "time_entry_id")?;

    // Find entry
    let repo = TimeEntryRepository::new(ctx.pool.clone());
    let mut entry = db_read(&ctx, "find_time_entry", || async {
        repo.find_by_id(time_entry_id).await.map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "TimeEntry".into(),
        id: time_entry_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // Owner-only check
    if entry.user_id != ctx.user_id {
        return Err(WsError::Unauthorized {
            message: "Cannot update another user's time entry".into(),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // Validate description if provided
    MessageValidator::validate_time_entry_description(req.description.as_deref())?;

    // Apply updates
    let mut changes = Vec::new();

    if let Some(started_at) = req.started_at {
        let new_started = DateTime::from_timestamp(started_at, 0).ok_or_else(|| {
            WsError::ValidationError {
                message: "Invalid started_at timestamp".into(),
                field: Some("started_at".into()),
                location: ErrorLocation::from(Location::caller()),
            }
        })?;
        changes.push(("started_at", entry.started_at.to_rfc3339(), new_started.to_rfc3339()));
        entry.started_at = new_started;
    }

    if let Some(ended_at) = req.ended_at {
        let new_ended = DateTime::from_timestamp(ended_at, 0).ok_or_else(|| {
            WsError::ValidationError {
                message: "Invalid ended_at timestamp".into(),
                field: Some("ended_at".into()),
                location: ErrorLocation::from(Location::caller()),
            }
        })?;
        let old_val = entry.ended_at.map(|e| e.to_rfc3339()).unwrap_or_default();
        changes.push(("ended_at", old_val, new_ended.to_rfc3339()));
        entry.ended_at = Some(new_ended);
    }

    if let Some(ref desc) = req.description {
        let sanitized = sanitize_string(desc);
        changes.push(("description", entry.description.clone().unwrap_or_default(), sanitized.clone()));
        entry.description = Some(sanitized);
    }

    // Validate final timestamps if both present
    if let Some(ended_at) = entry.ended_at {
        MessageValidator::validate_time_entry_timestamps(
            entry.started_at.timestamp(),
            ended_at.timestamp(),
        )?;
        entry.duration_seconds = Some((ended_at.timestamp() - entry.started_at.timestamp()) as i32);
    }

    entry.updated_at = Utc::now();

    // Save
    if !changes.is_empty() {
        db_write(&ctx, "update_time_entry", || async {
            repo.update(&entry).await?;
            // Activity log with changes
            let change_pairs: Vec<(&str, &str)> = changes
                .iter()
                .map(|(f, _, n)| (*f, n.as_str()))
                .collect();
            let activity = ActivityLog::updated("time_entry", entry.id, ctx.user_id, &change_pairs);
            ActivityLogRepository::new(ctx.pool.clone())
                .create(&activity)
                .await?;
            Ok::<_, WsError>(())
        })
        .await?;
    }

    info!("{} Updated time entry {}", ctx.log_prefix(), entry.id);

    Ok(build_time_entry_updated_response(&ctx.message_id, &entry, ctx.user_id))
}

/// Delete a time entry (owner-only, soft delete).
pub async fn handle_delete_time_entry(
    req: DeleteTimeEntryRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} DeleteTimeEntry starting", ctx.log_prefix());

    let time_entry_id = parse_uuid(&req.time_entry_id, "time_entry_id")?;

    // Find entry
    let repo = TimeEntryRepository::new(ctx.pool.clone());
    let entry = db_read(&ctx, "find_time_entry", || async {
        repo.find_by_id(time_entry_id).await.map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "TimeEntry".into(),
        id: time_entry_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // Owner-only check
    if entry.user_id != ctx.user_id {
        return Err(WsError::Unauthorized {
            message: "Cannot delete another user's time entry".into(),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // Soft delete
    let now = Utc::now().timestamp();
    db_write(&ctx, "delete_time_entry", || async {
        repo.soft_delete(time_entry_id, now).await?;
        let activity = ActivityLog::deleted("time_entry", time_entry_id, ctx.user_id);
        ActivityLogRepository::new(ctx.pool.clone())
            .create(&activity)
            .await?;
        Ok::<_, WsError>(())
    })
    .await?;

    info!("{} Deleted time entry {}", ctx.log_prefix(), time_entry_id);

    Ok(build_time_entry_deleted_response(
        &ctx.message_id,
        time_entry_id,
        entry.work_item_id,
        ctx.user_id,
    ))
}

/// Get time entries for a work item (paginated).
///
/// # Pagination
///
/// - Default limit: 100
/// - Max limit: 500
/// - Ordered by started_at DESC (most recent first)
pub async fn handle_get_time_entries(
    req: GetTimeEntriesRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} GetTimeEntries starting", ctx.log_prefix());

    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // Apply pagination limits
    let limit = req
        .limit
        .map(|l| l.clamp(1, MAX_TIME_ENTRIES_LIMIT))
        .unwrap_or(DEFAULT_TIME_ENTRIES_LIMIT);
    let offset = req.offset.unwrap_or(0).max(0);

    // Verify work item exists, check View permission
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::new(ctx.pool.clone())
            .find_by_id(work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem".into(),
        id: work_item_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::View).await
    })
    .await?;

    // Get paginated entries
    let (entries, total_count) = db_read(&ctx, "get_time_entries", || async {
        TimeEntryRepository::new(ctx.pool.clone())
            .find_by_work_item_paginated(work_item_id, limit, offset)
            .await
            .map_err(WsError::from)
    })
    .await?;

    debug!(
        "{} Found {} time entries (total: {}) for work item {}",
        ctx.log_prefix(),
        entries.len(),
        total_count,
        work_item_id
    );

    Ok(build_time_entries_list_response(
        &ctx.message_id,
        &entries,
        total_count,
    ))
}

/// Get the current user's running timer (if any).
///
/// Returns the single running timer for this user, or empty response if none.
pub async fn handle_get_running_timer(
    _req: GetRunningTimerRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} GetRunningTimer starting", ctx.log_prefix());

    let repo = TimeEntryRepository::new(ctx.pool.clone());
    let running = db_read(&ctx, "find_running_timer", || async {
        repo.find_running(ctx.user_id).await.map_err(WsError::from)
    })
    .await?;

    let entry = running.into_iter().next();

    if entry.is_some() {
        debug!("{} Found running timer", ctx.log_prefix());
    } else {
        debug!("{} No running timer", ctx.log_prefix());
    }

    Ok(build_running_timer_response(&ctx.message_id, entry.as_ref()))
}
```

**Verification**: `just check-rs-ws`

---

### Step 2: Create Dependency Handler

**Create**: `backend/crates/pm-ws/src/handlers/dependency.rs`

```rust
//! Dependency handlers with cycle detection.
//!
//! # Business Rules
//!
//! - No self-reference (A cannot block A)
//! - No duplicates (same pair cannot exist twice)
//! - No cycles for Blocks type (detected via BFS)
//! - RelatesTo allows bidirectional (not a cycle)
//! - Same-project only
//! - Max 50 blocking + 50 blocked per item
//!
//! # Handlers
//!
//! - `handle_create_dependency` - Create with cycle detection
//! - `handle_delete_dependency` - Soft delete
//! - `handle_get_dependencies` - Get both directions

use crate::handlers::{
    authorization::check_permission,
    context::HandlerContext,
    db_ops::{db_read, db_write},
    idempotency::{check_idempotency, store_idempotency_non_fatal, decode_cached_response},
    message_validator::MessageValidator,
    response_builder::*,
};
use crate::{Result as WsErrorResult, WsError};
use chrono::Utc;
use error_location::ErrorLocation;
use log::{debug, info, warn};
use pm_config::{MAX_BLOCKED_DEPENDENCIES_PER_ITEM, MAX_BLOCKING_DEPENDENCIES_PER_ITEM};
use pm_core::{ActivityLog, Dependency, DependencyType, Permission};
use pm_db::{ActivityLogRepository, DependencyRepository, WorkItemRepository};
use pm_proto::{
    CreateDependencyRequest, DeleteDependencyRequest, GetDependenciesRequest,
    WebSocketMessage,
};
use std::collections::{HashMap, HashSet, VecDeque};
use std::panic::Location;
use uuid::Uuid;

/// Parse UUID string with descriptive error
fn parse_uuid(s: &str, field: &str) -> WsErrorResult<Uuid> {
    Uuid::parse_str(s).map_err(|_| WsError::ValidationError {
        message: format!("Invalid UUID format for {}", field),
        field: Some(field.to_string()),
        location: ErrorLocation::from(Location::caller()),
    })
}

/// Detect circular dependencies using BFS.
///
/// If adding `blocking_id -> blocked_id`, we need to check whether
/// `blocked_id` can eventually reach `blocking_id` through existing
/// Blocks-type dependencies.
///
/// # Algorithm
///
/// 1. Start BFS from `blocked_id`
/// 2. Follow all outgoing Blocks edges (items that blocked_id blocks)
/// 3. If we reach `blocking_id`, we have a cycle
/// 4. Return error with the cycle path for debugging
///
/// # Returns
///
/// - `Ok(())` if no cycle detected
/// - `Err` with cycle path if cycle would be created
async fn detect_circular_dependency(
    repo: &DependencyRepository,
    blocking_id: Uuid,
    blocked_id: Uuid,
) -> WsErrorResult<()> {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut parent_map: HashMap<Uuid, Uuid> = HashMap::new();

    queue.push_back(blocked_id);
    visited.insert(blocked_id);

    while let Some(current) = queue.pop_front() {
        // Get all items that `current` blocks (outgoing edges)
        let blocked_by_current = repo
            .find_blocked(current)
            .await
            .map_err(|e| WsError::Database {
                message: e.to_string(),
                location: ErrorLocation::from(Location::caller()),
            })?;

        for dep in blocked_by_current {
            // Only follow Blocks edges (RelatesTo doesn't create cycles)
            if dep.dependency_type != DependencyType::Blocks {
                continue;
            }

            if dep.blocked_item_id == blocking_id {
                // Found a cycle! Build the path for error message
                let mut path = vec![blocking_id];
                let mut node = current;

                // Walk back through parent_map to reconstruct path
                while let Some(&parent) = parent_map.get(&node) {
                    path.push(node);
                    node = parent;
                }
                path.push(blocked_id);
                path.reverse();

                // Format path with short UUIDs for readability
                let path_str = path
                    .iter()
                    .map(|id| id.to_string()[..8].to_string())
                    .collect::<Vec<_>>()
                    .join(" → ");

                return Err(WsError::ValidationError {
                    message: format!(
                        "Circular dependency detected: {}. This would create a cycle.",
                        path_str
                    ),
                    field: Some("blocking_item_id".into()),
                    location: ErrorLocation::from(Location::caller()),
                });
            }

            if !visited.contains(&dep.blocked_item_id) {
                visited.insert(dep.blocked_item_id);
                parent_map.insert(dep.blocked_item_id, current);
                queue.push_back(dep.blocked_item_id);
            }
        }
    }

    Ok(())
}

/// Create a dependency between two work items.
///
/// # Validation
///
/// 1. Self-reference check (item cannot block itself)
/// 2. Same-project check (both items must be in same project)
/// 3. Duplicate check (pair cannot already exist)
/// 4. Limit check (max 50 blocking/blocked per item)
/// 5. Cycle check (for Blocks type only)
pub async fn handle_create_dependency(
    req: CreateDependencyRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} CreateDependency starting", ctx.log_prefix());

    // 1. Parse IDs
    let blocking_id = parse_uuid(&req.blocking_item_id, "blocking_item_id")?;
    let blocked_id = parse_uuid(&req.blocked_item_id, "blocked_item_id")?;

    // 2. Self-reference check
    if blocking_id == blocked_id {
        return Err(WsError::ValidationError {
            message: "Work item cannot block itself".into(),
            field: Some("blocked_item_id".into()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 3. Parse and validate dependency type
    let dep_type = MessageValidator::validate_dependency_type(req.dependency_type)?;

    // 4. Check idempotency
    let cached = db_read(&ctx, "check_idempotency", || async {
        check_idempotency(&ctx.pool, &ctx.message_id).await
    })
    .await?;
    if let Some(cached_response) = cached {
        info!("{} Returning cached idempotent response", ctx.log_prefix());
        return decode_cached_response(&cached_response);
    }

    // 5. Verify both work items exist
    let work_item_repo = WorkItemRepository::new(ctx.pool.clone());

    let blocking_item = db_read(&ctx, "find_blocking_item", || async {
        work_item_repo
            .find_by_id(blocking_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem (blocking)".into(),
        id: blocking_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    let blocked_item = db_read(&ctx, "find_blocked_item", || async {
        work_item_repo
            .find_by_id(blocked_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem (blocked)".into(),
        id: blocked_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // 6. SAME-PROJECT CHECK
    if blocking_item.project_id != blocked_item.project_id {
        return Err(WsError::ValidationError {
            message: "Dependencies can only be created between items in the same project".into(),
            field: Some("blocking_item_id".into()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 7. Check Edit permission on the project
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, blocking_item.project_id, Permission::Edit).await
    })
    .await?;

    let dep_repo = DependencyRepository::new(ctx.pool.clone());

    // 8. Check for duplicate
    let existing = db_read(&ctx, "check_duplicate", || async {
        dep_repo
            .find_by_pair(blocking_id, blocked_id)
            .await
            .map_err(WsError::from)
    })
    .await?;

    if existing.is_some() {
        return Err(WsError::ConflictError {
            message: "Dependency already exists between these items".into(),
            current_version: 0,
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 9. Check dependency limits
    let blocking_count = db_read(&ctx, "count_blocking", || async {
        dep_repo.count_blocking(blocked_id).await.map_err(WsError::from)
    })
    .await?;

    if blocking_count >= MAX_BLOCKING_DEPENDENCIES_PER_ITEM {
        return Err(WsError::ValidationError {
            message: format!(
                "Item already has {} blocking dependencies (max {})",
                blocking_count, MAX_BLOCKING_DEPENDENCIES_PER_ITEM
            ),
            field: Some("blocked_item_id".into()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    let blocked_count = db_read(&ctx, "count_blocked", || async {
        dep_repo.count_blocked(blocking_id).await.map_err(WsError::from)
    })
    .await?;

    if blocked_count >= MAX_BLOCKED_DEPENDENCIES_PER_ITEM {
        return Err(WsError::ValidationError {
            message: format!(
                "Item already blocks {} items (max {})",
                blocked_count, MAX_BLOCKED_DEPENDENCIES_PER_ITEM
            ),
            field: Some("blocking_item_id".into()),
            location: ErrorLocation::from(Location::caller()),
        });
    }

    // 10. CIRCULAR DEPENDENCY CHECK (only for Blocks type)
    if dep_type == DependencyType::Blocks {
        detect_circular_dependency(&dep_repo, blocking_id, blocked_id).await?;
    }

    // 11. Create dependency
    let now = Utc::now();
    let dependency = Dependency {
        id: Uuid::new_v4(),
        blocking_item_id: blocking_id,
        blocked_item_id: blocked_id,
        dependency_type: dep_type.clone(),
        created_at: now,
        created_by: ctx.user_id,
        deleted_at: None,
    };

    db_write(&ctx, "create_dependency", || async {
        dep_repo.create(&dependency).await?;

        let activity = ActivityLog::created("dependency", dependency.id, ctx.user_id);
        ActivityLogRepository::new(ctx.pool.clone())
            .create(&activity)
            .await?;

        Ok::<_, WsError>(())
    })
    .await?;

    // 12. Build response
    let response = build_dependency_created_response(&ctx.message_id, &dependency, ctx.user_id);

    // 13. Store idempotency
    store_idempotency_non_fatal(&ctx, "create_dependency", &response).await;

    info!(
        "{} Created dependency: {} {:?} {}",
        ctx.log_prefix(),
        blocking_id,
        dep_type,
        blocked_id
    );

    Ok(response)
}

/// Delete a dependency.
///
/// # Authorization
///
/// Requires Edit permission on the project containing the work items.
pub async fn handle_delete_dependency(
    req: DeleteDependencyRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} DeleteDependency starting", ctx.log_prefix());

    let dependency_id = parse_uuid(&req.dependency_id, "dependency_id")?;

    // Find dependency
    let dep_repo = DependencyRepository::new(ctx.pool.clone());
    let dependency = db_read(&ctx, "find_dependency", || async {
        dep_repo
            .find_by_id(dependency_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "Dependency".into(),
        id: dependency_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // Get work item to check project permission
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::new(ctx.pool.clone())
            .find_by_id(dependency.blocking_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem".into(),
        id: dependency.blocking_item_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    // Check Edit permission
    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::Edit).await
    })
    .await?;

    // Soft delete
    let now = Utc::now().timestamp();
    db_write(&ctx, "delete_dependency", || async {
        dep_repo.soft_delete(dependency_id, now).await?;

        let activity = ActivityLog::deleted("dependency", dependency_id, ctx.user_id);
        ActivityLogRepository::new(ctx.pool.clone())
            .create(&activity)
            .await?;

        Ok::<_, WsError>(())
    })
    .await?;

    let response = build_dependency_deleted_response(
        &ctx.message_id,
        dependency_id,
        dependency.blocking_item_id,
        dependency.blocked_item_id,
        ctx.user_id,
    );

    info!("{} Deleted dependency {}", ctx.log_prefix(), dependency_id);

    Ok(response)
}

/// Get dependencies for a work item.
///
/// Returns both:
/// - `blocking`: Items that are blocking this work item
/// - `blocked`: Items that this work item blocks
pub async fn handle_get_dependencies(
    req: GetDependenciesRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} GetDependencies starting", ctx.log_prefix());

    let work_item_id = parse_uuid(&req.work_item_id, "work_item_id")?;

    // Verify work item exists, check View permission
    let work_item = db_read(&ctx, "find_work_item", || async {
        WorkItemRepository::new(ctx.pool.clone())
            .find_by_id(work_item_id)
            .await
            .map_err(WsError::from)
    })
    .await?
    .ok_or_else(|| WsError::NotFound {
        entity: "WorkItem".into(),
        id: work_item_id.to_string(),
        location: ErrorLocation::from(Location::caller()),
    })?;

    db_read(&ctx, "check_permission", || async {
        check_permission(&ctx, work_item.project_id, Permission::View).await
    })
    .await?;

    let dep_repo = DependencyRepository::new(ctx.pool.clone());

    // Get both directions
    let blocking = db_read(&ctx, "find_blocking", || async {
        dep_repo.find_blocking(work_item_id).await.map_err(WsError::from)
    })
    .await?;

    let blocked = db_read(&ctx, "find_blocked", || async {
        dep_repo.find_blocked(work_item_id).await.map_err(WsError::from)
    })
    .await?;

    debug!(
        "{} Found {} blocking, {} blocked for {}",
        ctx.log_prefix(),
        blocking.len(),
        blocked.len(),
        work_item_id
    );

    Ok(build_dependencies_list_response(
        &ctx.message_id,
        &blocking,
        &blocked,
    ))
}
```

**Verification**: `just check-rs-ws`

---

### Step 3: Wire Handlers to Dispatcher

**File**: `backend/crates/pm-ws/src/handlers/dispatcher.rs`

Add the new handlers to the `dispatch_inner` match statement:

```rust
// Add to imports at top of file
use crate::handlers::{time_entry, dependency};

// In dispatch_inner, add to the match statement:

// Time Entry handlers
Some(Payload::StartTimerRequest(req)) => time_entry::handle_start_timer(req, ctx).await,
Some(Payload::StopTimerRequest(req)) => time_entry::handle_stop_timer(req, ctx).await,
Some(Payload::CreateTimeEntryRequest(req)) => time_entry::handle_create_time_entry(req, ctx).await,
Some(Payload::UpdateTimeEntryRequest(req)) => time_entry::handle_update_time_entry(req, ctx).await,
Some(Payload::DeleteTimeEntryRequest(req)) => time_entry::handle_delete_time_entry(req, ctx).await,
Some(Payload::GetTimeEntriesRequest(req)) => time_entry::handle_get_time_entries(req, ctx).await,
Some(Payload::GetRunningTimerRequest(req)) => time_entry::handle_get_running_timer(req, ctx).await,

// Dependency handlers
Some(Payload::CreateDependencyRequest(req)) => dependency::handle_create_dependency(req, ctx).await,
Some(Payload::DeleteDependencyRequest(req)) => dependency::handle_delete_dependency(req, ctx).await,
Some(Payload::GetDependenciesRequest(req)) => dependency::handle_get_dependencies(req, ctx).await,
```

Also add to `payload_to_handler_name`:

```rust
// Time Entry
Some(Payload::StartTimerRequest(_)) => "StartTimer",
Some(Payload::StopTimerRequest(_)) => "StopTimer",
Some(Payload::CreateTimeEntryRequest(_)) => "CreateTimeEntry",
Some(Payload::UpdateTimeEntryRequest(_)) => "UpdateTimeEntry",
Some(Payload::DeleteTimeEntryRequest(_)) => "DeleteTimeEntry",
Some(Payload::GetTimeEntriesRequest(_)) => "GetTimeEntries",
Some(Payload::GetRunningTimerRequest(_)) => "GetRunningTimer",

// Dependency
Some(Payload::CreateDependencyRequest(_)) => "CreateDependency",
Some(Payload::DeleteDependencyRequest(_)) => "DeleteDependency",
Some(Payload::GetDependenciesRequest(_)) => "GetDependencies",
```

**Verification**: `just check-rs-ws`

---

### Step 4: Export Handler Modules

**File**: `backend/crates/pm-ws/src/handlers/mod.rs`

Add the new module exports:

```rust
pub(crate) mod time_entry;
pub(crate) mod dependency;
```

**Verification**: `just check-rs-ws`

---

## Session 60.2 Completion Checklist

After completing all steps:

- [x] `just check-rs-ws` passes
- [x] `just check-backend` passes
- [x] `just clippy-backend` passes (no warnings)
- [x] `just test-backend` passes (219 tests, 0 failures)

### Files Created (2)

| File | Purpose |
|------|---------|
| `pm-ws/src/handlers/time_entry.rs` | 7 handlers with atomic timer operations |
| `pm-ws/src/handlers/dependency.rs` | 3 handlers with BFS cycle detection |

### Files Modified (2)

| File | Change |
|------|--------|
| `pm-ws/src/handlers/dispatcher.rs` | Added 10 handler dispatch cases |
| `pm-ws/src/handlers/mod.rs` | Export new handler modules |

---

## Key Concepts Introduced

### Atomic Timer Operations
The `handle_start_timer` function demonstrates an atomic operation pattern:
1. Find any running timer for this user
2. Stop it (set ended_at, calculate duration)
3. Create the new timer
4. All in a single `db_write` block (transaction)

This prevents race conditions where a user could accidentally have multiple running timers.

### BFS Cycle Detection
The `detect_circular_dependency` function uses Breadth-First Search:
1. Start from the "would-be-blocked" item
2. Follow all outgoing Blocks edges
3. If we reach the "would-be-blocking" item, there's a cycle
4. Track parent pointers to reconstruct the cycle path for the error message

### Owner-Only Pattern
Time entry mutations (update, delete) verify:
```rust
if entry.user_id != ctx.user_id {
    return Err(WsError::Unauthorized { ... });
}
```

This ensures users can only modify their own time entries.

---

## Next Session

**Session 60.3** will implement:
- C# domain models for TimeEntry and Dependency
- Request DTOs for time entry and dependency operations
- Proto converters for serialization
- WebSocket client interface and implementation
