# Session 60.3: Frontend Models & WebSocket Integration

**Parent Plan**: `60-Session-Plan.md`
**Prerequisite**: Sessions 60.1 and 60.2 completed
**Target**: ~35-45k tokens

---

## Scope

This session implements the frontend data layer for time tracking and dependencies:

1. **Domain Models** - C# record types for TimeEntry and Dependency
2. **Request DTOs** - Request objects for API operations
3. **Proto Converters** - Serialization between domain and protobuf
4. **WebSocket Interface** - Define events and operations
5. **WebSocket Implementation** - Implement the operations

---

## Prerequisites Check

Before starting, verify backend sessions are complete:

```bash
just check-backend  # Should pass
just build-rs-proto # Proto should compile with new messages
```

Ensure these proto messages exist:
- `StartTimerRequest`, `StopTimerRequest`, `CreateTimeEntryRequest`, etc.
- `TimerStarted`, `TimerStopped`, `TimeEntryCreated`, etc.
- `CreateDependencyRequest`, `DeleteDependencyRequest`, `GetDependenciesRequest`
- `DependencyCreated`, `DependencyDeleted`, `DependenciesList`

---

## Implementation Order

### Step 1: Create TimeEntry Model

**Create**: `frontend/ProjectManagement.Core/Models/TimeEntry.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// A time tracking entry on a work item.
/// Can be a running timer (EndedAt = null) or a completed entry.
/// </summary>
public sealed record TimeEntry
{
    /// <summary>Unique identifier for this time entry.</summary>
    public Guid Id { get; init; }

    /// <summary>The work item this time was logged against.</summary>
    public Guid WorkItemId { get; init; }

    /// <summary>The user who logged this time.</summary>
    public Guid UserId { get; init; }

    /// <summary>When the timer started (UTC).</summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When the timer stopped (UTC).
    /// Null if timer is still running.
    /// </summary>
    public DateTime? EndedAt { get; init; }

    /// <summary>
    /// Pre-calculated duration in seconds.
    /// Null if timer is still running.
    /// </summary>
    public int? DurationSeconds { get; init; }

    /// <summary>Optional description of what was worked on.</summary>
    public string? Description { get; init; }

    /// <summary>When this entry was created (UTC).</summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>When this entry was last updated (UTC).</summary>
    public DateTime UpdatedAt { get; init; }

    /// <summary>
    /// When this entry was deleted (UTC).
    /// Null if not deleted (soft delete pattern).
    /// </summary>
    public DateTime? DeletedAt { get; init; }

    /// <summary>
    /// True if this timer is currently running.
    /// A timer is running if EndedAt is null and it's not deleted.
    /// </summary>
    public bool IsRunning => EndedAt == null && DeletedAt == null;

    /// <summary>
    /// Get the elapsed time for this entry.
    /// If running, calculates from StartedAt to now.
    /// If stopped, uses DurationSeconds or calculates from EndedAt.
    /// </summary>
    public TimeSpan Elapsed
    {
        get
        {
            if (DurationSeconds.HasValue)
            {
                return TimeSpan.FromSeconds(DurationSeconds.Value);
            }

            if (EndedAt.HasValue)
            {
                return EndedAt.Value - StartedAt;
            }

            // Running timer - calculate from now
            return DateTime.UtcNow - StartedAt;
        }
    }

    /// <summary>
    /// Format the elapsed time as a human-readable string.
    /// Examples: "1:23:45" (hours), "23:45" (minutes), "00:45" (seconds only)
    /// </summary>
    public string ElapsedFormatted
    {
        get
        {
            var elapsed = Elapsed;
            return elapsed.TotalHours >= 1
                ? $"{(int)elapsed.TotalHours}:{elapsed.Minutes:D2}:{elapsed.Seconds:D2}"
                : $"{elapsed.Minutes:D2}:{elapsed.Seconds:D2}";
        }
    }
}
```

**Verification**: `just build-cs-core`

---

### Step 2: Create Dependency Model

**Create**: `frontend/ProjectManagement.Core/Models/Dependency.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// A dependency relationship between two work items.
/// </summary>
public sealed record Dependency
{
    /// <summary>Unique identifier for this dependency.</summary>
    public Guid Id { get; init; }

    /// <summary>
    /// The work item that is doing the blocking.
    /// This item must be completed before the blocked item can start.
    /// </summary>
    public Guid BlockingItemId { get; init; }

    /// <summary>
    /// The work item that is being blocked.
    /// This item cannot start until the blocking item is complete.
    /// </summary>
    public Guid BlockedItemId { get; init; }

    /// <summary>The type of dependency relationship.</summary>
    public DependencyType Type { get; init; }

    /// <summary>When this dependency was created (UTC).</summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>The user who created this dependency.</summary>
    public Guid CreatedBy { get; init; }

    /// <summary>
    /// When this dependency was deleted (UTC).
    /// Null if not deleted (soft delete pattern).
    /// </summary>
    public DateTime? DeletedAt { get; init; }
}

/// <summary>
/// Types of dependency relationships.
/// </summary>
public enum DependencyType
{
    /// <summary>
    /// Blocking relationship. The blocking item must be completed
    /// before the blocked item can start. Cycles are not allowed.
    /// </summary>
    Blocks = 1,

    /// <summary>
    /// Informational relationship. Indicates items are related
    /// but does not impose any ordering constraints.
    /// Bidirectional relationships are allowed.
    /// </summary>
    RelatesTo = 2
}
```

**Verification**: `just build-cs-core`

---

### Step 3: Create Request DTOs

**Create**: `frontend/ProjectManagement.Core/Models/TimeEntryRequests.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to start a timer on a work item.
/// If the user already has a running timer, it will be automatically stopped.
/// </summary>
public sealed record StartTimerRequest
{
    /// <summary>The work item to track time against.</summary>
    public Guid WorkItemId { get; init; }

    /// <summary>Optional description of what is being worked on.</summary>
    public string? Description { get; init; }
}

/// <summary>
/// Request to create a manual (already completed) time entry.
/// Use this for logging time after the fact.
/// </summary>
public sealed record CreateTimeEntryRequest
{
    /// <summary>The work item to log time against.</summary>
    public Guid WorkItemId { get; init; }

    /// <summary>When the work started (UTC).</summary>
    public DateTime StartedAt { get; init; }

    /// <summary>When the work ended (UTC).</summary>
    public DateTime EndedAt { get; init; }

    /// <summary>Optional description of what was done.</summary>
    public string? Description { get; init; }
}

/// <summary>
/// Request to update an existing time entry.
/// Only the owner can update their time entries.
/// </summary>
public sealed record UpdateTimeEntryRequest
{
    /// <summary>The ID of the time entry to update.</summary>
    public Guid TimeEntryId { get; init; }

    /// <summary>New start time (if changing).</summary>
    public DateTime? StartedAt { get; init; }

    /// <summary>New end time (if changing).</summary>
    public DateTime? EndedAt { get; init; }

    /// <summary>New description (if changing).</summary>
    public string? Description { get; init; }
}
```

**Create**: `frontend/ProjectManagement.Core/Models/DependencyRequests.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to create a dependency between two work items.
/// </summary>
public sealed record CreateDependencyRequest
{
    /// <summary>
    /// The work item that will be blocking.
    /// Must be in the same project as the blocked item.
    /// </summary>
    public Guid BlockingItemId { get; init; }

    /// <summary>
    /// The work item that will be blocked.
    /// Must be in the same project as the blocking item.
    /// </summary>
    public Guid BlockedItemId { get; init; }

    /// <summary>
    /// The type of dependency to create.
    /// Blocks = requires blocking item to complete first.
    /// RelatesTo = informational only.
    /// </summary>
    public DependencyType Type { get; init; }
}
```

**Verification**: `just build-cs-core`

---

### Step 4: Add Proto Converters

**File**: `frontend/ProjectManagement.Core/Converters/ProtoConverter.cs`

Add these methods to the existing `ProtoConverter` class:

```csharp
// Add these using statements if not present
using ProjectManagement.Core.Models;
using Proto = ProjectManagement.Proto;

public static partial class ProtoConverter
{
    // ==========================================================================
    // Time Entry Conversions
    // ==========================================================================

    /// <summary>
    /// Convert protobuf TimeEntry to domain TimeEntry.
    /// </summary>
    public static TimeEntry ToDomain(Proto.TimeEntry proto)
    {
        ArgumentNullException.ThrowIfNull(proto);

        return new TimeEntry
        {
            Id = Guid.Parse(proto.Id),
            WorkItemId = Guid.Parse(proto.WorkItemId),
            UserId = Guid.Parse(proto.UserId),
            StartedAt = DateTimeOffset.FromUnixTimeSeconds(proto.StartedAt).UtcDateTime,
            EndedAt = proto.HasEndedAt
                ? DateTimeOffset.FromUnixTimeSeconds(proto.EndedAt).UtcDateTime
                : null,
            DurationSeconds = proto.HasDurationSeconds ? proto.DurationSeconds : null,
            Description = proto.HasDescription ? proto.Description : null,
            CreatedAt = DateTimeOffset.FromUnixTimeSeconds(proto.CreatedAt).UtcDateTime,
            UpdatedAt = DateTimeOffset.FromUnixTimeSeconds(proto.UpdatedAt).UtcDateTime,
            DeletedAt = proto.HasDeletedAt
                ? DateTimeOffset.FromUnixTimeSeconds(proto.DeletedAt).UtcDateTime
                : null,
        };
    }

    /// <summary>
    /// Convert domain TimeEntry to protobuf TimeEntry.
    /// </summary>
    public static Proto.TimeEntry ToProto(TimeEntry entry)
    {
        ArgumentNullException.ThrowIfNull(entry);

        var proto = new Proto.TimeEntry
        {
            Id = entry.Id.ToString(),
            WorkItemId = entry.WorkItemId.ToString(),
            UserId = entry.UserId.ToString(),
            StartedAt = new DateTimeOffset(entry.StartedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
            CreatedAt = new DateTimeOffset(entry.CreatedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
            UpdatedAt = new DateTimeOffset(entry.UpdatedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
        };

        if (entry.EndedAt.HasValue)
        {
            proto.EndedAt = new DateTimeOffset(entry.EndedAt.Value, TimeSpan.Zero).ToUnixTimeSeconds();
        }

        if (entry.DurationSeconds.HasValue)
        {
            proto.DurationSeconds = entry.DurationSeconds.Value;
        }

        if (entry.Description != null)
        {
            proto.Description = entry.Description;
        }

        if (entry.DeletedAt.HasValue)
        {
            proto.DeletedAt = new DateTimeOffset(entry.DeletedAt.Value, TimeSpan.Zero).ToUnixTimeSeconds();
        }

        return proto;
    }

    // ==========================================================================
    // Dependency Conversions
    // ==========================================================================

    /// <summary>
    /// Convert protobuf Dependency to domain Dependency.
    /// </summary>
    public static Dependency ToDomain(Proto.Dependency proto)
    {
        ArgumentNullException.ThrowIfNull(proto);

        return new Dependency
        {
            Id = Guid.Parse(proto.Id),
            BlockingItemId = Guid.Parse(proto.BlockingItemId),
            BlockedItemId = Guid.Parse(proto.BlockedItemId),
            Type = ToDomain(proto.DependencyType),
            CreatedAt = DateTimeOffset.FromUnixTimeSeconds(proto.CreatedAt).UtcDateTime,
            CreatedBy = Guid.Parse(proto.CreatedBy),
            DeletedAt = proto.HasDeletedAt
                ? DateTimeOffset.FromUnixTimeSeconds(proto.DeletedAt).UtcDateTime
                : null,
        };
    }

    /// <summary>
    /// Convert domain Dependency to protobuf Dependency.
    /// </summary>
    public static Proto.Dependency ToProto(Dependency dep)
    {
        ArgumentNullException.ThrowIfNull(dep);

        var proto = new Proto.Dependency
        {
            Id = dep.Id.ToString(),
            BlockingItemId = dep.BlockingItemId.ToString(),
            BlockedItemId = dep.BlockedItemId.ToString(),
            DependencyType = ToProto(dep.Type),
            CreatedAt = new DateTimeOffset(dep.CreatedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
            CreatedBy = dep.CreatedBy.ToString(),
        };

        if (dep.DeletedAt.HasValue)
        {
            proto.DeletedAt = new DateTimeOffset(dep.DeletedAt.Value, TimeSpan.Zero).ToUnixTimeSeconds();
        }

        return proto;
    }

    /// <summary>
    /// Convert protobuf DependencyType to domain DependencyType.
    /// </summary>
    public static DependencyType ToDomain(Proto.DependencyType proto)
    {
        return proto switch
        {
            Proto.DependencyType.Blocks => DependencyType.Blocks,
            Proto.DependencyType.RelatesTo => DependencyType.RelatesTo,
            _ => throw new ArgumentOutOfRangeException(nameof(proto), proto, "Unknown dependency type")
        };
    }

    /// <summary>
    /// Convert domain DependencyType to protobuf DependencyType.
    /// </summary>
    public static Proto.DependencyType ToProto(DependencyType type)
    {
        return type switch
        {
            DependencyType.Blocks => Proto.DependencyType.Blocks,
            DependencyType.RelatesTo => Proto.DependencyType.RelatesTo,
            _ => throw new ArgumentOutOfRangeException(nameof(type), type, "Unknown dependency type")
        };
    }
}
```

**Verification**: `just build-cs-core`

---

### Step 5: Extend WebSocket Interface

**File**: `frontend/ProjectManagement.Services/WebSocket/IWebSocketClient.cs`

Add these events and operations to the existing interface:

```csharp
public partial interface IWebSocketClient
{
    // ==========================================================================
    // Time Entry Events
    // ==========================================================================

    /// <summary>
    /// Fired when a timer is started.
    /// Parameters: (started entry, optionally the entry that was auto-stopped)
    /// </summary>
    event Action<TimeEntry, TimeEntry?>? OnTimerStarted;

    /// <summary>Fired when a timer is stopped.</summary>
    event Action<TimeEntry>? OnTimerStopped;

    /// <summary>Fired when a manual time entry is created.</summary>
    event Action<TimeEntry>? OnTimeEntryCreated;

    /// <summary>Fired when a time entry is updated.</summary>
    event Action<TimeEntry>? OnTimeEntryUpdated;

    /// <summary>
    /// Fired when a time entry is deleted.
    /// Parameters: (timeEntryId, workItemId)
    /// </summary>
    event Action<Guid, Guid>? OnTimeEntryDeleted;

    // ==========================================================================
    // Time Entry Operations
    // ==========================================================================

    /// <summary>
    /// Start a timer on a work item.
    /// If the user already has a running timer, it will be automatically stopped.
    /// </summary>
    /// <returns>
    /// Tuple of (started entry, stopped entry if any was auto-stopped)
    /// </returns>
    Task<(TimeEntry Started, TimeEntry? Stopped)> StartTimerAsync(
        StartTimerRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Stop a running timer.
    /// Only the owner can stop their timer.
    /// </summary>
    /// <returns>The stopped entry with duration calculated.</returns>
    Task<TimeEntry> StopTimerAsync(
        Guid timeEntryId,
        CancellationToken ct = default);

    /// <summary>
    /// Create a manual (already completed) time entry.
    /// Use this for logging time after the fact.
    /// </summary>
    Task<TimeEntry> CreateTimeEntryAsync(
        CreateTimeEntryRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Update an existing time entry.
    /// Only the owner can update their entries.
    /// </summary>
    Task<TimeEntry> UpdateTimeEntryAsync(
        UpdateTimeEntryRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Delete a time entry (soft delete).
    /// Only the owner can delete their entries.
    /// </summary>
    Task DeleteTimeEntryAsync(
        Guid timeEntryId,
        CancellationToken ct = default);

    /// <summary>
    /// Get time entries for a work item with pagination.
    /// </summary>
    /// <param name="workItemId">The work item to get entries for.</param>
    /// <param name="limit">Max entries to return (default 100, max 500).</param>
    /// <param name="offset">Number of entries to skip for pagination.</param>
    /// <returns>Tuple of (entries, total count for pagination).</returns>
    Task<(IReadOnlyList<TimeEntry> Entries, int TotalCount)> GetTimeEntriesAsync(
        Guid workItemId,
        int? limit = null,
        int? offset = null,
        CancellationToken ct = default);

    /// <summary>
    /// Get the current user's running timer, if any.
    /// </summary>
    /// <returns>The running timer, or null if none.</returns>
    Task<TimeEntry?> GetRunningTimerAsync(CancellationToken ct = default);

    // ==========================================================================
    // Dependency Events
    // ==========================================================================

    /// <summary>Fired when a dependency is created.</summary>
    event Action<Dependency>? OnDependencyCreated;

    /// <summary>
    /// Fired when a dependency is deleted.
    /// Parameters: (dependencyId, blockingItemId, blockedItemId)
    /// </summary>
    event Action<Guid, Guid, Guid>? OnDependencyDeleted;

    // ==========================================================================
    // Dependency Operations
    // ==========================================================================

    /// <summary>
    /// Create a dependency between two work items.
    /// Both items must be in the same project.
    /// Circular dependencies are rejected for Blocks type.
    /// </summary>
    Task<Dependency> CreateDependencyAsync(
        CreateDependencyRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Delete a dependency.
    /// Requires Edit permission on the project.
    /// </summary>
    Task DeleteDependencyAsync(
        Guid dependencyId,
        CancellationToken ct = default);

    /// <summary>
    /// Get dependencies for a work item.
    /// Returns both items blocking this one and items blocked by this one.
    /// </summary>
    /// <returns>
    /// Tuple of (items blocking this work item, items blocked by this work item)
    /// </returns>
    Task<(IReadOnlyList<Dependency> Blocking, IReadOnlyList<Dependency> Blocked)> GetDependenciesAsync(
        Guid workItemId,
        CancellationToken ct = default);
}
```

**Verification**: `just build-cs-services`

---

### Step 6: Implement WebSocket Operations

**File**: `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

Add event declarations and implementations. Follow the existing patterns in the file.

```csharp
public partial class WebSocketClient
{
    // ==========================================================================
    // Time Entry Events
    // ==========================================================================

    public event Action<TimeEntry, TimeEntry?>? OnTimerStarted;
    public event Action<TimeEntry>? OnTimerStopped;
    public event Action<TimeEntry>? OnTimeEntryCreated;
    public event Action<TimeEntry>? OnTimeEntryUpdated;
    public event Action<Guid, Guid>? OnTimeEntryDeleted;

    // ==========================================================================
    // Dependency Events
    // ==========================================================================

    public event Action<Dependency>? OnDependencyCreated;
    public event Action<Guid, Guid, Guid>? OnDependencyDeleted;

    // ==========================================================================
    // Time Entry Operations
    // ==========================================================================

    public async Task<(TimeEntry Started, TimeEntry? Stopped)> StartTimerAsync(
        StartTimerRequest request,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.StartTimerRequest
        {
            WorkItemId = request.WorkItemId.ToString(),
        };

        if (request.Description != null)
        {
            protoRequest.Description = request.Description;
        }

        var response = await SendRequestAsync(
            msg => msg.StartTimerRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimerStarted)
        {
            var started = ProtoConverter.ToDomain(response.TimerStarted.TimeEntry);
            var stopped = response.TimerStarted.HasStoppedEntry
                ? ProtoConverter.ToDomain(response.TimerStarted.StoppedEntry)
                : null;
            return (started, stopped);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<TimeEntry> StopTimerAsync(Guid timeEntryId, CancellationToken ct = default)
    {
        var protoRequest = new Proto.StopTimerRequest
        {
            TimeEntryId = timeEntryId.ToString(),
        };

        var response = await SendRequestAsync(
            msg => msg.StopTimerRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimerStopped)
        {
            return ProtoConverter.ToDomain(response.TimerStopped.TimeEntry);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<TimeEntry> CreateTimeEntryAsync(
        CreateTimeEntryRequest request,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.CreateTimeEntryRequest
        {
            WorkItemId = request.WorkItemId.ToString(),
            StartedAt = new DateTimeOffset(request.StartedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
            EndedAt = new DateTimeOffset(request.EndedAt, TimeSpan.Zero).ToUnixTimeSeconds(),
        };

        if (request.Description != null)
        {
            protoRequest.Description = request.Description;
        }

        var response = await SendRequestAsync(
            msg => msg.CreateTimeEntryRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimeEntryCreated)
        {
            return ProtoConverter.ToDomain(response.TimeEntryCreated.TimeEntry);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<TimeEntry> UpdateTimeEntryAsync(
        UpdateTimeEntryRequest request,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.UpdateTimeEntryRequest
        {
            TimeEntryId = request.TimeEntryId.ToString(),
        };

        if (request.StartedAt.HasValue)
        {
            protoRequest.StartedAt = new DateTimeOffset(request.StartedAt.Value, TimeSpan.Zero).ToUnixTimeSeconds();
        }

        if (request.EndedAt.HasValue)
        {
            protoRequest.EndedAt = new DateTimeOffset(request.EndedAt.Value, TimeSpan.Zero).ToUnixTimeSeconds();
        }

        if (request.Description != null)
        {
            protoRequest.Description = request.Description;
        }

        var response = await SendRequestAsync(
            msg => msg.UpdateTimeEntryRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimeEntryUpdated)
        {
            return ProtoConverter.ToDomain(response.TimeEntryUpdated.TimeEntry);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task DeleteTimeEntryAsync(Guid timeEntryId, CancellationToken ct = default)
    {
        var protoRequest = new Proto.DeleteTimeEntryRequest
        {
            TimeEntryId = timeEntryId.ToString(),
        };

        var response = await SendRequestAsync(
            msg => msg.DeleteTimeEntryRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimeEntryDeleted)
        {
            return; // Success
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<(IReadOnlyList<TimeEntry> Entries, int TotalCount)> GetTimeEntriesAsync(
        Guid workItemId,
        int? limit = null,
        int? offset = null,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.GetTimeEntriesRequest
        {
            WorkItemId = workItemId.ToString(),
        };

        if (limit.HasValue)
        {
            protoRequest.Limit = limit.Value;
        }

        if (offset.HasValue)
        {
            protoRequest.Offset = offset.Value;
        }

        var response = await SendRequestAsync(
            msg => msg.GetTimeEntriesRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.TimeEntriesList)
        {
            var entries = response.TimeEntriesList.TimeEntries
                .Select(ProtoConverter.ToDomain)
                .ToList();
            return (entries, response.TimeEntriesList.TotalCount);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<TimeEntry?> GetRunningTimerAsync(CancellationToken ct = default)
    {
        var protoRequest = new Proto.GetRunningTimerRequest();

        var response = await SendRequestAsync(
            msg => msg.GetRunningTimerRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.RunningTimerResponse)
        {
            return response.RunningTimerResponse.HasTimeEntry
                ? ProtoConverter.ToDomain(response.RunningTimerResponse.TimeEntry)
                : null;
        }

        throw CreateUnexpectedResponseException(response);
    }

    // ==========================================================================
    // Dependency Operations
    // ==========================================================================

    public async Task<Dependency> CreateDependencyAsync(
        CreateDependencyRequest request,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.CreateDependencyRequest
        {
            BlockingItemId = request.BlockingItemId.ToString(),
            BlockedItemId = request.BlockedItemId.ToString(),
            DependencyType = ProtoConverter.ToProto(request.Type),
        };

        var response = await SendRequestAsync(
            msg => msg.CreateDependencyRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.DependencyCreated)
        {
            return ProtoConverter.ToDomain(response.DependencyCreated.Dependency);
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task DeleteDependencyAsync(Guid dependencyId, CancellationToken ct = default)
    {
        var protoRequest = new Proto.DeleteDependencyRequest
        {
            DependencyId = dependencyId.ToString(),
        };

        var response = await SendRequestAsync(
            msg => msg.DeleteDependencyRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.DependencyDeleted)
        {
            return; // Success
        }

        throw CreateUnexpectedResponseException(response);
    }

    public async Task<(IReadOnlyList<Dependency> Blocking, IReadOnlyList<Dependency> Blocked)> GetDependenciesAsync(
        Guid workItemId,
        CancellationToken ct = default)
    {
        var protoRequest = new Proto.GetDependenciesRequest
        {
            WorkItemId = workItemId.ToString(),
        };

        var response = await SendRequestAsync(
            msg => msg.GetDependenciesRequest = protoRequest,
            ct);

        if (response.PayloadCase == Proto.WebSocketMessage.PayloadOneofCase.DependenciesList)
        {
            var blocking = response.DependenciesList.Blocking
                .Select(ProtoConverter.ToDomain)
                .ToList();
            var blocked = response.DependenciesList.Blocked
                .Select(ProtoConverter.ToDomain)
                .ToList();
            return (blocking, blocked);
        }

        throw CreateUnexpectedResponseException(response);
    }

    // ==========================================================================
    // Message Handling (add to existing HandleMessage method)
    // ==========================================================================

    // Add these cases to the existing message handling switch:
    private void HandleTimeEntryAndDependencyMessages(Proto.WebSocketMessage message)
    {
        switch (message.PayloadCase)
        {
            case Proto.WebSocketMessage.PayloadOneofCase.TimerStarted:
                var started = ProtoConverter.ToDomain(message.TimerStarted.TimeEntry);
                var stopped = message.TimerStarted.HasStoppedEntry
                    ? ProtoConverter.ToDomain(message.TimerStarted.StoppedEntry)
                    : null;
                OnTimerStarted?.Invoke(started, stopped);
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.TimerStopped:
                OnTimerStopped?.Invoke(ProtoConverter.ToDomain(message.TimerStopped.TimeEntry));
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.TimeEntryCreated:
                OnTimeEntryCreated?.Invoke(ProtoConverter.ToDomain(message.TimeEntryCreated.TimeEntry));
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.TimeEntryUpdated:
                OnTimeEntryUpdated?.Invoke(ProtoConverter.ToDomain(message.TimeEntryUpdated.TimeEntry));
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.TimeEntryDeleted:
                OnTimeEntryDeleted?.Invoke(
                    Guid.Parse(message.TimeEntryDeleted.TimeEntryId),
                    Guid.Parse(message.TimeEntryDeleted.WorkItemId));
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.DependencyCreated:
                OnDependencyCreated?.Invoke(ProtoConverter.ToDomain(message.DependencyCreated.Dependency));
                break;

            case Proto.WebSocketMessage.PayloadOneofCase.DependencyDeleted:
                OnDependencyDeleted?.Invoke(
                    Guid.Parse(message.DependencyDeleted.DependencyId),
                    Guid.Parse(message.DependencyDeleted.BlockingItemId),
                    Guid.Parse(message.DependencyDeleted.BlockedItemId));
                break;
        }
    }
}
```

**Note**: Integrate `HandleTimeEntryAndDependencyMessages` into the existing message handling logic.

**Verification**: `just build-cs-services`

---

## Session 60.3 Completion Checklist

After completing all steps:

- [ ] `just build-cs-core` passes
- [ ] `just build-cs-services` passes
- [ ] `just build-frontend` passes
- [ ] `just test-frontend` passes (existing tests)

### Files Created (4)

| File | Purpose |
|------|---------|
| `Models/TimeEntry.cs` | Domain model with IsRunning and Elapsed helpers |
| `Models/Dependency.cs` | Domain model with DependencyType enum |
| `Models/TimeEntryRequests.cs` | Request DTOs for time operations |
| `Models/DependencyRequests.cs` | Request DTOs for dependency operations |

### Files Modified (3)

| File | Change |
|------|--------|
| `Converters/ProtoConverter.cs` | Added 6 conversion methods |
| `WebSocket/IWebSocketClient.cs` | Added 10 operations + 7 events |
| `WebSocket/WebSocketClient.cs` | Implemented operations and event handling |

---

## Key Concepts Introduced

### Computed Properties
The `TimeEntry` model includes computed properties that don't come from the server:
- `IsRunning` - Derived from `EndedAt == null && DeletedAt == null`
- `Elapsed` - Calculates duration, including for running timers
- `ElapsedFormatted` - Human-readable format like "1:23:45"

### Optional Proto Fields
Proto uses `HasXxx` pattern to check if optional fields are present:
```csharp
EndedAt = proto.HasEndedAt
    ? DateTimeOffset.FromUnixTimeSeconds(proto.EndedAt).UtcDateTime
    : null,
```

### Tuple Returns
Operations like `StartTimerAsync` return tuples for multiple related values:
```csharp
Task<(TimeEntry Started, TimeEntry? Stopped)> StartTimerAsync(...)
```

---

## Next Session

**Session 60.4** will implement:
- `ITimeEntryStore` and `TimeEntryStore` with optimistic updates
- `IDependencyStore` and `DependencyStore` with blocking/blocked tracking
- UI components: TimerWidget, TimeEntryList, DependencyManager, BlockedIndicator
- CSS styling for all new components
