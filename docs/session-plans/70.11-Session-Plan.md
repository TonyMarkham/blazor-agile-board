# Session 70.11: Dependency Closure Before 70.2

**Parent Plan**: `70-Session-Plan.md`
**Prerequisite**: Session 60 complete
**Target**: ~20-30k tokens
**Status**: ✅ Complete

---

## Goal

Close the real-time subscription/broadcast gap so Session 70.2 can build the Activity Feed UI with live updates.

---

## Current Branch Audit (Reconciles Prior Audit)

Each item from the prior audit is explicitly marked as **Resolved** or **Still Missing** on this branch.

**Resolved on this branch:**
- Proto messages and payload wiring for Activity Log + LLM Context exist in `proto/messages.proto`
- Activity log handler exists: `backend/crates/pm-ws/src/handlers/activity_log.rs`
- LLM context handler exists: `backend/crates/pm-ws/src/handlers/llm_context.rs`
- Activity log pagination exists in `backend/crates/pm-db/src/repositories/activity_log_repository.rs`
- LLM context repository exists: `backend/crates/pm-db/src/repositories/llm_context_repository.rs`
- LLM context seed migration exists: `backend/crates/pm-db/migrations/20260127000001_seed_llm_context.sql`
- Response builders for activity log list + LLM context list exist in `backend/crates/pm-ws/src/handlers/response_builder.rs`
- Dispatcher wiring for `GetActivityLogRequest` + `GetLlmContextRequest` exists in `backend/crates/pm-ws/src/handlers/dispatcher.rs`
- Handler tests exist for activity log + LLM context in `backend/crates/pm-ws/tests/`

**Still missing (blockers for 70.2):**
- None

**Still missing (non-blocking for 70.11 but must be addressed in 70.2/70.3):**
- `Radzen.Blazor` reference missing in `frontend/ProjectManagement.Services/ProjectManagement.Services.csproj`
- `IToastService` not registered in `frontend/ProjectManagement.Wasm/Program.cs`
- `ActivityLog : IEntity` mismatch (model missing `CreatedAt`) in `docs/session-plans/70.2-Session-Plan.md`
- Session plan test paths mismatch (`backend/crates/pm-db/src/repositories/tests` vs `backend/crates/pm-db/tests`)
- Session status claims inconsistent with actual state (`docs/session-plans/70-Session-Plan.md`, `docs/implementation-plan-revised.md`)

---

## Missing Dependencies (Blockers for 70.2)

None. All blockers resolved in this session.

---

## Implementation Order

### Part 1: Subscribe/Unsubscribe Handlers

#### Step 1.1: Implement Handler Module

**Create**: `backend/crates/pm-ws/src/handlers/subscription.rs`

Add signatures and expected behavior:

```rust
pub async fn handle_subscribe(
    req: pm_proto::Subscribe,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage>

pub async fn handle_unsubscribe(
    req: pm_proto::Unsubscribe,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage>
```

Behavior:
- Resolve the active connection using `ctx.request_ctx.connection_id`.
- Update `ClientSubscriptions` for that connection.
- Return a generic success `WebSocketMessage` with `payload: None` (no existing success payload for Subscribe/Unsubscribe in proto).
- Log success using `ctx.log_prefix()` for traceability.
- Errors are returned via dispatcher’s standard `WsError` handling (response `Error` payload + code).

**Detailed implementation sketch:**

```rust
use chrono::Utc;
use log::info;
use pm_proto::{Subscribe, Unsubscribe, WebSocketMessage};
use crate::{HandlerContext, Result as WsErrorResult};

pub async fn handle_subscribe(
    req: Subscribe,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    let connection_id = ctx.request_ctx.connection_id.clone();

    ctx.registry
        .subscribe(&connection_id, &req.project_ids, &req.sprint_ids)
        .await?;

    info!("{} Subscribe: projects={} sprints={}",
        ctx.log_prefix(), req.project_ids.len(), req.sprint_ids.len());

    Ok(WebSocketMessage {
        message_id: ctx.message_id,
        timestamp: chrono::Utc::now().timestamp(),
        payload: None,
    })
}

pub async fn handle_unsubscribe(
    req: Unsubscribe,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    let connection_id = ctx.request_ctx.connection_id.clone();

    ctx.registry
        .unsubscribe(&connection_id, &req.project_ids, &req.sprint_ids)
        .await?;

    info!("{} Unsubscribe: projects={} sprints={}",
        ctx.log_prefix(), req.project_ids.len(), req.sprint_ids.len());

    Ok(WebSocketMessage {
        message_id: ctx.message_id,
        timestamp: chrono::Utc::now().timestamp(),
        payload: None,
    })
}
```

#### Step 1.2: Add Registry Update Methods

**File**: `backend/crates/pm-ws/src/connection_registry.rs`

Add mutation helpers (required by handlers):

```rust
use std::panic::Location;
use error_location::ErrorLocation;
use crate::{ConnectionId, Result as WsErrorResult, WsError};
pub async fn subscribe(
    &self,
    connection_id: &str,
    projects: &[String],
    sprints: &[String],
) -> WsErrorResult<()>

pub async fn unsubscribe(
    &self,
    connection_id: &str,
    projects: &[String],
    sprints: &[String],
) -> WsErrorResult<()>
```

Implementation notes:
- Use `RwLock::write()` and mutate `ConnectionInfo.subscriptions`.
- If connection is missing, return `WsError::NotFound` with context.
- `RequestContext.connection_id` is created from the server-side `ConnectionId` in `web_socket_connection.rs`. It must be serialized with `ConnectionId::to_string()` and parsed with `ConnectionId::parse()` to match registry keys.

**Detailed implementation sketch:**

```rust
pub async fn subscribe(
    &self,
    connection_id: &str,
    projects: &[String],
    sprints: &[String],
) -> WsErrorResult<()> {
    let mut inner = self.inner.write().await;
    let connection_id = ConnectionId::parse(connection_id)?;
    let info = inner
        .connections
        .get_mut(&connection_id)
        .ok_or_else(|| WsError::NotFound {
            message: format!("Connection {} not found", connection_id),
            location: ErrorLocation::from(Location::caller()),
        })?;

    for project_id in projects {
        info.subscriptions.subscribe_project(project_id.clone());
    }
    for sprint_id in sprints {
        info.subscriptions.subscribe_sprint(sprint_id.clone());
    }

    Ok(())
}

pub async fn unsubscribe(
    &self,
    connection_id: &str,
    projects: &[String],
    sprints: &[String],
) -> WsErrorResult<()> {
    let mut inner = self.inner.write().await;
    let connection_id = ConnectionId::parse(connection_id)?;
    let info = inner
        .connections
        .get_mut(&connection_id)
        .ok_or_else(|| WsError::NotFound {
            message: format!("Connection {} not found", connection_id),
            location: ErrorLocation::from(Location::caller()),
        })?;

    for project_id in projects {
        info.subscriptions.unsubscribe_project(project_id);
    }
    for sprint_id in sprints {
        info.subscriptions.unsubscribe_sprint(sprint_id);
    }

    Ok(())
}
```

**ConnectionId parse helper (required):**

**File**: `backend/crates/pm-ws/src/connection_id.rs`

Add a parse helper so the registry can look up by string id from `RequestContext`.
This returns `WsError::ValidationError` which maps to error code `VALIDATION_ERROR` in `backend/crates/pm-ws/src/error.rs`.

```rust
use std::panic::Location;
use error_location::ErrorLocation;
use uuid::Uuid;
use crate::WsError;

impl ConnectionId {
    pub fn parse(value: &str) -> Result<Self, WsError> {
        let uuid = Uuid::parse_str(value).map_err(|_| WsError::ValidationError {
            message: format!("Invalid connection_id: {}", value),
            field: Some("connection_id".to_string()),
            location: ErrorLocation::from(Location::caller()),
        })?;
        Ok(Self(uuid))
    }
}
```

**Required follow-up in connection setup:**

Ensure `RequestContext::new` is called with `connection_id.to_string()` where the connection is created so the registry lookup key matches.
Source-of-truth: `backend/crates/pm-ws/src/web_socket_connection.rs` uses `self.connection_id.to_string()` when building `HandlerContext`.

#### Step 1.3: Wire Dispatcher + Module Exports

**Files**:
- `backend/crates/pm-ws/src/handlers/mod.rs` (export `subscription`)
- `backend/crates/pm-ws/src/handlers/dispatcher.rs`

Replace the NOT_IMPLEMENTED branch with calls to new handlers.

**Exact replacement snippet:**

```rust
use crate::{handle_subscribe, handle_unsubscribe};
// Subscription handlers
Some(Payload::Subscribe(req)) => handle_subscribe(req, ctx).await,
Some(Payload::Unsubscribe(req)) => handle_unsubscribe(req, ctx).await,
```

And add exports:

```rust
pub mod subscription;
pub use subscription::{handle_subscribe, handle_unsubscribe};
```

Test export requirement:
- Add `handle_subscribe` and `handle_unsubscribe` to `backend/crates/pm-ws/src/lib.rs` re-exports so tests can `use pm_ws::handle_subscribe`.

**Verification**:
```bash
just check-rs-ws
```

---

### Part 2: ActivityLogCreated Broadcast Path

#### Step 2.1: Broadcast Helper in ConnectionRegistry

**File**: `backend/crates/pm-ws/src/connection_registry.rs`

Add a helper that broadcasts to subscribers only:

Encoding rule:
- Use the same encoding as normal responses in `web_socket_connection.rs`: `WebSocketMessage::encode_to_vec()` wrapped in `Message::Binary` with no additional envelope.

Metrics decision:
- Skip metrics in 70.11 because `Metrics` is not available in `HandlerContext` or `ConnectionRegistry`.
- Optional follow-up: thread `Metrics` into the registry and call `metrics.broadcast_published("ActivityLogCreated", delivered)`.

```rust
use axum::extract::ws::Message;
use log::debug;
use crate::{ClientSubscriptions, Result as WsErrorResult, SubscriptionFilter};
pub async fn broadcast_activity_log_created(
    &self,
    project_id: &str,
    work_item_id: Option<&str>,
    sprint_id: Option<&str>,
    message: axum::extract::ws::Message,
) -> WsErrorResult<usize>
```

Filtering rules:
- Use `SubscriptionFilter::should_receive_work_item_event` when `work_item_id` is present.
- Use `SubscriptionFilter::should_receive_sprint_event` when `sprint_id` is present.
- For comments/time entries/dependencies, treat as work-item events (pass `work_item_id`).

**Detailed implementation sketch:**

```rust
pub async fn broadcast_activity_log_created(
    &self,
    project_id: &str,
    work_item_id: Option<&str>,
    sprint_id: Option<&str>,
    message: Message,
) -> WsErrorResult<usize> {
    // Clone senders first to avoid holding lock across .await
    let inner = self.inner.read().await;
    let connections: Vec<(ClientSubscriptions, tokio::sync::mpsc::Sender<Message>)> =
        inner
            .connections
            .values()
            .map(|info| (info.subscriptions.clone(), info.sender.clone()))
            .collect();
    drop(inner);

    let mut delivered = 0;
    for (subscriptions, sender) in connections {
        let should_receive = if let Some(work_item_id) = work_item_id {
            SubscriptionFilter::should_receive_work_item_event(
                &subscriptions,
                project_id,
                work_item_id,
            )
        } else if let Some(sprint_id) = sprint_id {
            SubscriptionFilter::should_receive_sprint_event(
                &subscriptions,
                project_id,
                sprint_id,
            )
        } else {
            subscriptions.is_subscribed_to_project(project_id)
        };

        if should_receive {
            if sender.send(message.clone()).await.is_ok() {
                delivered += 1;
            } else {
                // Do not fail broadcast; stale connections are cleaned up on disconnect.
                debug!("Broadcast send failed; skipping connection");
            }
        }
    }

    Ok(delivered)
}
```

**Decision:** do not unregister on send failure in broadcast path (cleanup occurs in connection lifecycle). If you want aggressive cleanup, add a follow-up task to mark the connection for removal.

#### Step 2.2: Build ActivityLogCreated Message

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

Add a builder for event payload:

```rust
pub fn build_activity_log_created_event(entry: &ActivityLog) -> WebSocketMessage
```

Use `activity_log_to_proto(entry)` and wrap in `Payload::ActivityLogCreated`.

Export requirement for tests:
- Add `build_activity_log_created_event` to `backend/crates/pm-ws/src/lib.rs` re-exports so tests can `use pm_ws::build_activity_log_created_event`.

Encoding reminder:
- Always send via `Message::Binary(event.encode_to_vec().into())`.

**Detailed implementation sketch:**

```rust
use chrono::Utc;
use uuid::Uuid;
use pm_proto::{ActivityLogCreated, web_socket_message::Payload, WebSocketMessage};
pub fn build_activity_log_created_event(entry: &ActivityLog) -> WebSocketMessage {
    WebSocketMessage {
        message_id: Uuid::new_v4().to_string(),
        timestamp: Utc::now().timestamp(),
        payload: Some(Payload::ActivityLogCreated(ActivityLogCreated {
            entry: Some(activity_log_to_proto(entry)),
        })),
    }
}
```

#### Step 2.3: Emit Broadcast After Mutations

**Files**:
- `backend/crates/pm-ws/src/handlers/work_item.rs`
- `backend/crates/pm-ws/src/handlers/sprint.rs`
- `backend/crates/pm-ws/src/handlers/comment.rs`
- `backend/crates/pm-ws/src/handlers/time_entry.rs`
- `backend/crates/pm-ws/src/handlers/dependency.rs`

Pattern to follow (after successful transaction commit):

```rust
use axum::extract::ws::Message;
use prost::Message as ProstMessage;
use pm_core::ActivityLog;

let activity = ActivityLog::created("work_item", work_item.id, ctx.user_id);
// For updates: ActivityLog::updated("work_item", work_item.id, ctx.user_id, &changes)
// For deletes: ActivityLog::deleted("work_item", work_item.id, ctx.user_id)

ActivityLogRepository::create(&mut *tx, &activity).await?;
tx.commit().await?;

let event = build_activity_log_created_event(&activity);
let bytes = event.encode_to_vec();
let message = Message::Binary(bytes.into());
ctx.registry
    .broadcast_activity_log_created(
        project_id.to_string().as_str(),
        Some(work_item_id.to_string().as_str()),
        None,
        message,
    )
    .await?;
```

Note:
- `Message` is `Clone`, so `message.clone()` in broadcast is safe. If the type changes in the future, pre-encode bytes and clone the byte buffer instead.

**Detailed mapping guidance (per handler):**

- Work item handlers: use `work_item.project_id` + `work_item.id`
- Sprint handlers: use `sprint.project_id` + `sprint.id` (pass `sprint_id`)
- Comment handlers: use `comment.work_item_id` to resolve work item, then use that work item’s project_id
- Time entry handlers: use `time_entry.work_item_id` to resolve work item, then use that work item’s project_id
- Dependency handlers: use `dependency.blocked_item_id` to resolve work item, then use that work item’s project_id

Project/sprint/work-item id mapping:
- Work item: project_id + work_item_id
- Sprint: project_id + sprint_id
- Comment/time entry/dependency: resolve work_item_id, then use project_id + work_item_id

**Verification**:
```bash
just check-rs-ws
```

---

### Part 3: Tests (Broadcast + Subscription)

#### Step 3.1: Subscription Handler Tests

**Create**: `backend/crates/pm-ws/tests/subscription_handler_tests.rs`

Test cases:
- Subscribe adds project/sprint ids to `ClientSubscriptions`
- Unsubscribe removes ids
- Missing connection returns NotFound

**Detailed test sketch (subscription handler):**

```rust
use axum::extract::ws::Message;
use pm_proto::Subscribe;
use sqlx::SqlitePool;
use std::sync::Arc;
use tokio::sync::mpsc;
use uuid::Uuid;
use pm_ws::{CircuitBreaker, CircuitBreakerConfig, ConnectionLimits, ConnectionRegistry, HandlerContext, handle_subscribe};

#[tokio::test]
async fn subscribe_adds_project_and_sprint_ids() {
    let registry = ConnectionRegistry::new(ConnectionLimits::default());
    let (tx, _rx) = mpsc::channel::<Message>(8);
    let connection_id = registry.register("user-1".to_string(), tx).await.unwrap();

    let pool = SqlitePool::connect(":memory:").await.unwrap();
    let circuit_breaker = Arc::new(CircuitBreaker::new(CircuitBreakerConfig::default()));
    let ctx = HandlerContext::new(
        "msg-1".to_string(),
        Uuid::new_v4(),
        pool,
        circuit_breaker,
        connection_id.to_string(),
        registry.clone(),
    );

    handle_subscribe(Subscribe { project_ids: vec!["p1".into()], sprint_ids: vec!["s1".into()] }, ctx)
        .await
        .unwrap();

    let info = registry.get(connection_id).await.unwrap();
    assert!(info.subscriptions.is_subscribed_to_project("p1"));
    assert!(info.subscriptions.is_subscribed_to_sprint("s1"));
}
```

#### Step 3.2: Broadcast Delivery Tests

**Create**: `backend/crates/pm-ws/tests/activity_log_broadcast_tests.rs`

Test cases:
- Subscribed client receives `ActivityLogCreated`
- Unsubscribed client does not receive
- Sprint subscription receives sprint-related event

Use `tokio::sync::mpsc` sender + receiver to assert `Message::Binary` contents decode.

**Detailed test sketch (broadcast):**

```rust
use axum::extract::ws::Message;
use pm_proto::{WebSocketMessage, web_socket_message::Payload};
use prost::Message as ProstMessage;
use tokio::sync::mpsc;
use uuid::Uuid;
use pm_core::ActivityLog;
use pm_ws::{ConnectionLimits, ConnectionRegistry, build_activity_log_created_event};

#[tokio::test]
async fn broadcast_only_reaches_subscribed_clients() {
    let registry = ConnectionRegistry::new(ConnectionLimits::default());
    let (tx_a, mut rx_a) = mpsc::channel::<Message>(8);
    let (tx_b, mut rx_b) = mpsc::channel::<Message>(8);
    let conn_a = registry.register("user-a".to_string(), tx_a).await.unwrap();
    let _conn_b = registry.register("user-b".to_string(), tx_b).await.unwrap();

    registry.subscribe(&conn_a.to_string(), &["p1".into()], &[]).await.unwrap();

    let activity = ActivityLog::created("work_item", Uuid::new_v4(), Uuid::new_v4());
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.clone());

    let delivered = registry
        .broadcast_activity_log_created("p1", Some("wi-1"), None, message)
        .await
        .unwrap();
    assert_eq!(delivered, 1);

    let received = rx_a.recv().await.expect("expected message");
    if let Message::Binary(payload) = received {
        let decoded = WebSocketMessage::decode(&payload[..]).unwrap();
        assert!(matches!(decoded.payload, Some(Payload::ActivityLogCreated(_))));
    } else {
        panic!("Expected binary message");
    }

    assert!(rx_b.try_recv().is_err());
}
```

**Verification**:
```bash
just test-rs-ws
```

---

## Optional (Not Blocking 70.2)

If you want repository coverage parity:

- Add pagination test for `find_by_entity_paginated`
- Add LLM context list + filtered tests

Suggested location: `backend/crates/pm-db/tests/`

---

## Success Criteria

- [x] Subscribe/Unsubscribe no longer returns NOT_IMPLEMENTED
- [x] `ActivityLogCreated` broadcasts reach subscribed clients
- [x] Broadcasts are filtered by subscription
- [x] `just test-rs-ws` passes
- [x] Session 70.2 can start with real-time activity updates available

---

## Files Summary (Expected)

### Create
- `backend/crates/pm-ws/src/handlers/subscription.rs`
- `backend/crates/pm-ws/tests/subscription_handler_tests.rs`
- `backend/crates/pm-ws/tests/activity_log_broadcast_tests.rs`

### Modify
- `backend/crates/pm-ws/src/handlers/dispatcher.rs`
- `backend/crates/pm-ws/src/handlers/mod.rs`
- `backend/crates/pm-ws/src/connection_registry.rs`
- `backend/crates/pm-ws/src/handlers/response_builder.rs`
- Mutation handlers: work_item/sprint/comment/time_entry/dependency

---

## Verification

`just test-rs-ws`

## Next Session

Proceed to `docs/session-plans/70.2-Session-Plan.md`.
