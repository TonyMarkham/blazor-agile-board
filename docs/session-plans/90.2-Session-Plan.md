# Session 90.2: Rust Backend (Models, Repos, Handlers)

**Parent Plan**: `90-Session-Plan.md`
**Target**: ~40k tokens
**Prerequisites**: Session 90.1 complete (migration run, proto updated with `update_parent` field)

**CRITICAL FIXES APPLIED** (from Gordon Ramsay review):
- ✅ Enforced Transaction type in `get_and_increment_work_item_number` signature
- ✅ Added context to ALL error messages (work item ID, project ID, etc.)
- ✅ Documented counter gap behavior (expected with failed transactions)
- ✅ Handle new `update_parent` proto field properly
- ✅ Fixed circular reference error messages with full context

---

## Scope

This session implements all Rust backend changes for the three features:

1. **Domain Models** (Steps 4-5) - Add new fields to Project and WorkItem
2. **Repositories** (Steps 6-7) - Update queries, add atomic counter method (type-safe!)
3. **Response Builder** (Step 8) - Proto serialization for new fields
4. **Work Item Handler** (Step 9) - Atomic number assignment on create
5. **Change Tracker** (Step 10) - Track parent_id changes (using `update_parent` flag)
6. **Update Handler** (Steps 11-12) - Parent validation with contextual errors
7. **Documentation** (Step 13) - Clarify optional hierarchy and counter gaps

---

## Implementation Order

### Step 4: Update Rust Domain Model - Project

**File**: `backend/crates/pm-core/src/models/project.rs`

Add `next_work_item_number` field to `Project` struct.

```rust
// Add new field to Project struct (after deleted_at):
pub next_work_item_number: i32,

// Update Project::new() to initialize next_work_item_number:
impl Project {
    pub fn new(title: String, key: String, created_by: Uuid) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            title,
            description: None,
            key,
            status: ProjectStatus::Active,
            version: 1,
            created_at: now,
            updated_at: now,
            created_by,
            updated_by: created_by,
            deleted_at: None,
            next_work_item_number: 1,  // NEW
        }
    }
    // ... existing methods unchanged
}
```

**Verification**: `cargo check -p pm-core`

---

### Step 5: Update Rust Domain Model - WorkItem

**File**: `backend/crates/pm-core/src/models/work_item.rs`

Add `item_number` field and display key helper method.

```rust
// Add new field to WorkItem struct (before version field):
pub item_number: i32,

// Update WorkItem::new() - item_number will be assigned during DB insert
impl WorkItem {
    pub fn new(
        item_type: WorkItemType,
        title: String,
        description: Option<String>,
        parent_id: Option<Uuid>,
        project_id: Uuid,
        created_by: Uuid,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            item_type,
            parent_id,
            project_id,
            position: 0,
            title,
            description,
            status: "backlog".to_string(),
            priority: "medium".to_string(),
            assignee_id: None,
            story_points: None,
            sprint_id: None,
            item_number: 0,  // NEW: Will be set during DB insert
            version: 0,
            created_at: now,
            updated_at: now,
            created_by,
            updated_by: created_by,
            deleted_at: None,
        }
    }

    /// Generate JIRA-style display key (e.g., "PROJ-123")
    pub fn display_key(&self, project_key: &str) -> String {
        format!("{}-{}", project_key, self.item_number)
    }
}
```

**Verification**: `cargo check -p pm-core`

---

### Step 6: Update Project Repository

**File**: `backend/crates/pm-db/src/repositories/project_repository.rs`

Add `next_work_item_number` to all queries and add atomic increment method.

#### 6.1 Update `create()` method

Add `next_work_item_number` to INSERT:

```rust
pub async fn create(&self, project: &Project) -> DbErrorResult<()> {
    let id = project.id.to_string();
    let status = project.status.as_str();
    let created_at = project.created_at.timestamp();
    let updated_at = project.updated_at.timestamp();
    let created_by = project.created_by.to_string();
    let updated_by = project.updated_by.to_string();
    let deleted_at = project.deleted_at.map(|dt| dt.timestamp());

    sqlx::query!(
        r#"
            INSERT INTO pm_projects (
                id, title, description, key, status, version,
                created_at, updated_at, created_by, updated_by, deleted_at,
                next_work_item_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
        id,
        project.title,
        project.description,
        project.key,
        status,
        project.version,
        created_at,
        updated_at,
        created_by,
        updated_by,
        deleted_at,
        project.next_work_item_number,  // NEW
    )
    .execute(&self.pool)
    .await?;

    Ok(())
}
```

#### 6.2 Update all `find_*()` methods

For each SELECT query, add `next_work_item_number` to the column list:

```rust
// In find_by_id, find_by_key, find_all, find_active:
let row = sqlx::query!(
    r#"
        SELECT id, title, description, key, status, version,
               created_at, updated_at, created_by, updated_by, deleted_at,
               next_work_item_number
        FROM pm_projects
        WHERE id = ? AND deleted_at IS NULL
        "#,
    id_str
)
// ...

// And in the mapping closure, add:
next_work_item_number: r.next_work_item_number as i32,
```

#### 6.3 Add atomic increment method (TYPE-SAFE - FIXED)

```rust
/// Atomically get and increment the work item number for a project.
/// Returns the number to assign to the new work item.
///
/// CRITICAL: This method REQUIRES a Transaction. The type system enforces this.
/// Accepting a generic Executor allowed non-transactional calls, leading to race conditions.
///
/// **Counter Gap Behavior:**
/// If the transaction rolls back after incrementing, the counter will have a gap.
/// This is EXPECTED and CORRECT behavior. Work item numbers are NOT guaranteed to be
/// sequential without gaps - they are only guaranteed to be unique within a project.
///
/// Example: Create work item #5 fails → counter is at 6 → next work item is #6 (gap at #5).
pub async fn get_and_increment_work_item_number(
    tx: &mut sqlx::Transaction<'_, sqlx::Sqlite>,  // FIXED: Enforce transaction type!
    project_id: Uuid,
) -> DbErrorResult<i32>
{
    let project_id_str = project_id.to_string();

    // SQLite doesn't support RETURNING, so we need two queries
    // The transaction isolation ensures atomicity

    // First, get the current value
    let current = sqlx::query_scalar!(
        r#"
            SELECT next_work_item_number as "next_work_item_number!"
            FROM pm_projects
            WHERE id = ? AND deleted_at IS NULL
            "#,
        project_id_str
    )
    .fetch_one(&mut **tx)  // Use transaction
    .await
    .map_err(|e| match e {
        sqlx::Error::RowNotFound => DbError::NotFound {
            message: format!(
                "Project {} not found when incrementing work item counter",
                project_id
            ),
            location: ErrorLocation::from(Location::caller()),
        },
        _ => DbError::from(e),
    })?;

    let item_number = current as i32;
    let next_number = item_number + 1;

    // Then increment
    sqlx::query!(
        r#"
            UPDATE pm_projects
            SET next_work_item_number = ?
            WHERE id = ? AND deleted_at IS NULL
            "#,
        next_number,
        project_id_str
    )
    .execute(&mut **tx)  // Use transaction
    .await?;

    Ok(item_number)
}
```

**CRITICAL CHANGE:**
- Old signature: `pub async fn get_and_increment_work_item_number<'e, E>(executor: E, ...)`
- New signature: `pub async fn get_and_increment_work_item_number(tx: &mut sqlx::Transaction<'_, sqlx::Sqlite>, ...)`

**Why this matters:**
- Generic `Executor` allowed calling outside transactions → race conditions
- Explicit `Transaction` type enforces correctness at compile time
- Impossible to misuse - if you don't have a transaction, code won't compile

**Verification**: `cargo check -p pm-db`

---

### Step 7: Update WorkItem Repository

**File**: `backend/crates/pm-db/src/repositories/work_item_repository.rs`

#### 7.1 Update `create()` to include `item_number`

```rust
pub async fn create<'e, E>(executor: E, work_item: &WorkItem) -> DbErrorResult<()>
where
    E: sqlx::Executor<'e, Database = sqlx::Sqlite>,
{
    // ... existing variable bindings ...

    sqlx::query!(
        r#"
          INSERT INTO pm_work_items (
              id, item_type, parent_id, project_id, position,
              title, description, status, priority, assignee_id,
              story_points, sprint_id, item_number, version,
              created_at, updated_at, created_by, updated_by, deleted_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          "#,
        id,
        item_type,
        parent_id,
        project_id,
        work_item.position,
        work_item.title,
        work_item.description,
        work_item.status,
        work_item.priority,
        assignee_id,
        work_item.story_points,
        sprint_id,
        work_item.item_number,  // NEW
        work_item.version,
        created_at,
        updated_at,
        created_by,
        updated_by,
        deleted_at,
    )
    .execute(executor)
    .await?;

    Ok(())
}
```

#### 7.2 Update all `find_*()` SELECT queries

Add `item_number` to SELECT columns and mapping:

```rust
// Add to SELECT columns:
SELECT
    id, item_type, parent_id, project_id, position,
    title, description, status, priority, assignee_id,
    story_points, sprint_id, item_number, version,
    created_at, updated_at, created_by, updated_by, deleted_at
FROM pm_work_items
// ...

// Add to mapping:
item_number: r.item_number as i32,
```

Apply to: `find_by_id()`, `find_by_project()`, `find_children()`, `find_by_project_since()`

#### 7.3 Add lookup by project + item number

```rust
/// Find a work item by project ID and item number (e.g., for "PROJ-123" lookup)
pub async fn find_by_project_and_number<'e, E>(
    executor: E,
    project_id: Uuid,
    item_number: i32,
) -> DbErrorResult<Option<WorkItem>>
where
    E: sqlx::Executor<'e, Database = sqlx::Sqlite>,
{
    let project_id_str = project_id.to_string();

    let row = sqlx::query!(
        r#"
          SELECT
              id, item_type, parent_id, project_id, position,
              title, description, status, priority, assignee_id,
              story_points, sprint_id, item_number, version,
              created_at, updated_at, created_by, updated_by, deleted_at
          FROM pm_work_items
          WHERE project_id = ? AND item_number = ? AND deleted_at IS NULL
          "#,
        project_id_str,
        item_number
    )
    .fetch_optional(executor)
    .await?;

    row.map(|r| -> DbErrorResult<WorkItem> {
        Ok(WorkItem {
            // ... same mapping as find_by_id
            item_number: r.item_number as i32,
            // ... rest of fields
        })
    })
    .transpose()
}
```

**Verification**: `cargo check -p pm-db`

---

### Step 8: Update Response Builder

**File**: `backend/crates/pm-ws/src/handlers/response_builder.rs`

#### 8.1 Update `work_item_to_proto()`

```rust
fn work_item_to_proto(item: &WorkItem) -> PmProtoWorkItem {
    PmProtoWorkItem {
        id: item.id.to_string(),
        item_type: item.item_type.clone() as i32,
        title: item.title.clone(),
        description: item.description.clone(),
        status: item.status.clone(),
        priority: item.priority.clone(),
        parent_id: item.parent_id.map(|id| id.to_string()),
        project_id: item.project_id.to_string(),
        assignee_id: item.assignee_id.map(|id| id.to_string()),
        story_points: item.story_points,
        position: item.position,
        sprint_id: item.sprint_id.map(|id| id.to_string()),
        item_number: item.item_number,  // NEW
        version: item.version,
        created_at: item.created_at.timestamp(),
        updated_at: item.updated_at.timestamp(),
        created_by: item.created_by.to_string(),
        updated_by: item.updated_by.to_string(),
        deleted_at: item.deleted_at.map(|dt| dt.timestamp()),
    }
}
```

#### 8.2 Update `project_to_proto()`

```rust
fn project_to_proto(project: &Project) -> ProtoProject {
    ProtoProject {
        id: project.id.to_string(),
        title: project.title.clone(),
        description: project.description.clone(),
        key: project.key.clone(),
        status: match project.status {
            ProjectStatus::Active => ProtoProjectStatus::Active.into(),
            ProjectStatus::Archived => ProtoProjectStatus::Archived.into(),
        },
        version: project.version,
        created_at: project.created_at.timestamp(),
        updated_at: project.updated_at.timestamp(),
        created_by: project.created_by.to_string(),
        updated_by: project.updated_by.to_string(),
        deleted_at: project.deleted_at.map(|dt| dt.timestamp()),
        next_work_item_number: project.next_work_item_number,  // NEW
    }
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 9: Update WorkItem Create Handler

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

Modify `handle_create()` to atomically assign item numbers within a transaction.

```rust
pub async fn handle_create(
    req: CreateWorkItemRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    debug!("{} CreateWorkItem starting", ctx.log_prefix());

    // ... existing validation code (steps 1-6) ...

    // 7. Get next position
    let max_position = db_read(&ctx, "find_max_position", || async {
        WorkItemRepository::find_max_position(&ctx.pool, project_id, parent_id)
            .await
            .map_err(WsError::from)
    })
    .await?;

    // 8. Build work item (item_number will be set in transaction)
    let now = Utc::now();
    let mut work_item = WorkItem {
        id: Uuid::new_v4(),
        item_type: item_type.clone(),
        parent_id,
        project_id,
        position: max_position + 1,
        title: sanitize_string(&req.title),
        description: req.description.as_ref().map(|d| sanitize_string(d)),
        status: req.status.clone().unwrap_or_else(|| "backlog".to_string()),
        priority: req.priority.clone().unwrap_or_else(|| "medium".to_string()),
        assignee_id: None,
        story_points: None,
        sprint_id: None,
        item_number: 0,  // Will be set in transaction
        version: 1,
        created_at: now,
        updated_at: now,
        created_by: ctx.user_id,
        updated_by: ctx.user_id,
        deleted_at: None,
    };

    // 9. Execute transaction with atomic item_number assignment
    let activity = ActivityLog::created("work_item", work_item.id, ctx.user_id);
    let activity_clone = activity.clone();

    let work_item_for_tx = work_item.clone();

    let item_number = db_write(&ctx, "create_work_item_tx", || async {
        let mut tx = ctx.pool.begin().await?;

        // Atomically get and increment the work item number
        // NOTE: Type signature now ENFORCES transaction - cannot be called outside tx
        let item_num = ProjectRepository::get_and_increment_work_item_number(&mut tx, project_id)
            .await
            .map_err(WsError::from)?;

        // Create work item with assigned number
        let mut wi = work_item_for_tx.clone();
        wi.item_number = item_num;
        WorkItemRepository::create(&mut tx, &wi).await?;

        // Create activity log
        ActivityLogRepository::create(&mut tx, &activity_clone).await?;

        tx.commit().await?;
        Ok::<_, WsError>(item_num)
    })
    .await?;

    // Update our local copy with the assigned number
    work_item.item_number = item_number;

    // ... rest of the function (broadcast, response building) unchanged ...

    info!(
        "{} Created work item {} ({:?}) #{} in project {}",
        ctx.log_prefix(),
        work_item.id,
        item_type,
        item_number,
        project_id
    );

    Ok(response)
}
```

**Verification**: `cargo check -p pm-ws`

---

### Step 10: Update Change Tracker (Feature C - FIXED)

**File**: `backend/crates/pm-ws/src/handlers/change_tracker.rs`

Add parent_id change tracking with `update_parent` flag support:

```rust
// Add after existing field tracking in track_changes():

// FIXED: Check update_parent flag (from proto field 12)
if request.update_parent {
    let current_parent = current.parent_id.map(|id| id.to_string()).unwrap_or_default();
    let new_parent = request.parent_id.as_ref().map(|s| s.as_str()).unwrap_or("");

    if current_parent != new_parent {
        changes.push(FieldChange {
            field_name: "parent_id".to_string(),
            old_value: if current_parent.is_empty() {
                None
            } else {
                Some(current_parent)
            },
            new_value: if new_parent.is_empty() {
                None
            } else {
                Some(new_parent.to_string())
            },
        });
    }
}
```

**CRITICAL FIX:**
- Original: `if let Some(ref new_parent_id) = request.parent_id`
- Fixed: `if request.update_parent` (uses new proto field)

**Why this matters:**
- Proto field `update_parent` (field 12) explicitly signals intent
- Prevents ambiguity between "don't change" and "clear parent"
- Matches the C# UpdateWorkItemRequest.UpdateParent semantics

**Verification**: `cargo check -p pm-ws`

---

### Step 11: Update handle_update for Parent Validation (Feature C)

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

Add hierarchy validation BEFORE `apply_updates` (async validation needed):

```rust
pub async fn handle_update(
    req: UpdateWorkItemRequest,
    ctx: HandlerContext,
) -> WsErrorResult<WebSocketMessage> {
    // ... existing steps 1-4 ...

    // 4b. Validate new parent if changing (FIXED: use update_parent flag)
    if req.update_parent {
        if let Some(ref new_parent_id) = req.parent_id {
            if !new_parent_id.is_empty() {
                let parent_uuid = parse_uuid(new_parent_id, "parent_id")?;

                // Can't be your own parent
                if parent_uuid == work_item.id {
                    return Err(WsError::ValidationError {
                        message: format!(
                            "Work item {} cannot be its own parent",
                            work_item.id
                        ),
                        field: Some("parent_id".to_string()),
                        location: ErrorLocation::from(Location::caller()),
                    });
                }

                // Validate hierarchy rules
                db_read(&ctx, "validate_hierarchy", || async {
                    validate_hierarchy(&ctx.pool, work_item.item_type.clone(), parent_uuid).await
                })
                .await?;

                // Prevent circular references (parent can't be a descendant)
                db_read(&ctx, "check_circular", || async {
                    check_circular_reference(&ctx.pool, work_item.id, parent_uuid).await
                })
                .await?;
            }
        }
    }

    // 5. Track changes
    let changes = track_changes(&work_item, &req);
    // ... rest unchanged ...
}
```

Add the circular reference check function with CONTEXTUAL ERROR MESSAGES:

```rust
/// Check that new_parent is not a descendant of work_item (prevent cycles)
///
/// Walks up the parent chain from new_parent_id to ensure work_item_id is not
/// in the ancestry. This prevents circular references like:
/// - A -> B -> C -> A (would create a cycle)
///
/// Also prevents excessively deep hierarchies (max 100 levels).
async fn check_circular_reference(
    pool: &SqlitePool,
    work_item_id: Uuid,
    new_parent_id: Uuid,
) -> WsErrorResult<()> {
    // Walk up the tree from new_parent to ensure we don't hit work_item_id
    let mut current = Some(new_parent_id);
    let mut depth = 0;
    const MAX_DEPTH: i32 = 100; // Prevent infinite loops

    while let Some(id) = current {
        if depth > MAX_DEPTH {
            return Err(WsError::ValidationError {
                message: format!(
                    "Hierarchy too deep: work item {} has parent chain exceeding {} levels. \
                     Max depth is {}. This may indicate corrupted data or a cycle.",
                    new_parent_id, depth, MAX_DEPTH
                ),
                field: Some("parent_id".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }

        if id == work_item_id {
            return Err(WsError::ValidationError {
                message: format!(
                    "Cannot set parent {} for work item {}: would create circular reference. \
                     Work item {} is a descendant of work item {}, so {} cannot be its parent.",
                    new_parent_id, work_item_id, new_parent_id, work_item_id, new_parent_id
                ),
                field: Some("parent_id".to_string()),
                location: ErrorLocation::from(Location::caller()),
            });
        }

        let item = WorkItemRepository::find_by_id(pool, id).await?;
        current = item.and_then(|i| i.parent_id);
        depth += 1;
    }

    Ok(())
}
```

**CRITICAL FIXES:**
- **Depth error** now includes: which work item, current depth, max depth
- **Circular error** now includes: both work item IDs, clear explanation of the cycle
- Helps debugging in production logs at 3 AM
- No more "Cannot create circular reference" with zero context

**Verification**: `cargo check -p pm-ws`

---

### Step 12: Update apply_updates for Parent Changes (Feature C - FIXED)

**File**: `backend/crates/pm-ws/src/handlers/work_item.rs`

Add parent_id to `apply_updates` function with `update_parent` flag check:

```rust
fn apply_updates(work_item: &mut WorkItem, req: &UpdateWorkItemRequest) -> Result<(), WsError> {
    // ... existing field updates ...

    // Handle parent_id change (FIXED: check update_parent flag)
    if req.update_parent {
        work_item.parent_id = match req.parent_id.as_ref() {
            None | Some(s) if s.is_empty() => {
                // Clear parent (make orphan)
                None
            }
            Some(parent_id) => {
                // Set parent
                Some(parse_uuid(parent_id, "parent_id")?)
            }
        };
    }

    Ok(())
}
```

**CRITICAL FIX:**
- Original: `if let Some(ref parent_id) = req.parent_id`
- Fixed: `if req.update_parent` (uses proto field 12)

**Why this matters:**
- Without `update_parent` check, cannot distinguish "no change" from "clear parent"
- Proto's `optional` alone is insufficient for three-state logic
- Must check both flags: `update_parent` AND `parent_id` value

**Verification**: `cargo check -p pm-ws`

---

### Step 13: Update Documentation (Feature B + Counter Gaps)

**File**: `backend/crates/pm-ws/src/handlers/hierarchy_validator.rs`

Clarify in code comments that orphan items are intentional:

```rust
/// Valid parent-child relationships when a parent IS specified:
/// - Epic: no parent (parent_id should be NULL)
/// - Story: parent must be Epic
/// - Task: parent must be Story
///
/// **Important:** Stories and Tasks CAN be orphans (parent_id = NULL).
/// This function is only called when parent_id is provided.
/// Orphan items belong directly to the project via project_id.
///
/// **Feature B (Session 90):** Orphan stories/tasks are explicitly supported.
/// Work items do NOT require a parent in the hierarchy - parent is optional.
pub async fn validate_hierarchy(
    pool: &SqlitePool,
    child_type: WorkItemType,
    parent_id: Uuid,
) -> WsErrorResult<()> {
    // ... existing implementation unchanged ...
}
```

**File**: `backend/crates/pm-db/src/repositories/project_repository.rs`

Add module-level documentation about counter gaps:

```rust
//! Project repository for CRUD operations on projects.
//!
//! ## Work Item Number Counter
//!
//! The `next_work_item_number` field is an atomic counter for assigning
//! sequential numbers to work items within a project. Numbers are assigned
//! when work items are created via `get_and_increment_work_item_number()`.
//!
//! **IMPORTANT: Counter gaps are EXPECTED and CORRECT behavior.**
//!
//! Gaps occur when:
//! - Transaction rolls back after incrementing counter (e.g., validation fails)
//! - Work item is soft-deleted (item_number is preserved, gap in active items)
//!
//! Example timeline:
//! 1. Create work item → assigned #5, counter becomes 6
//! 2. Transaction fails (e.g., circular reference detected)
//! 3. Counter is still at 6 (gap at #5)
//! 4. Next work item → assigned #6 (gap at #5 remains)
//!
//! This is INTENTIONAL. Work item numbers are unique identifiers, not a
//! sequential count. Users see "TEST-1, TEST-2, TEST-6" and this is correct.
```

**Verification**: `cargo check -p pm-ws`, `cargo check -p pm-db`

---

## Session 90.2 Completion Checklist

After completing all steps:

- [ ] **Step 4**: Project model updated with `next_work_item_number`
- [ ] **Step 5**: WorkItem model updated with `item_number`
- [ ] **Step 6**: ProjectRepository updated (queries + **type-safe** atomic increment)
- [ ] **Step 7**: WorkItemRepository updated (queries + lookup by number)
- [ ] **Step 8**: Response builder updated (proto serialization)
- [ ] **Step 9**: Create handler updated (atomic number assignment)
- [ ] **Step 10**: Change tracker updated (using `update_parent` flag)
- [ ] **Step 11**: Update handler validation (using `update_parent`, contextual errors)
- [ ] **Step 12**: Apply updates function (using `update_parent` flag)
- [ ] **Step 13**: Documentation updated (orphan items + counter gaps)
- [ ] `cargo check -p pm-core` passes
- [ ] `cargo check -p pm-db` passes
- [ ] `cargo check -p pm-ws` passes
- [ ] `cargo check --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] `cargo test --workspace` passes

### Critical Fixes Applied
- ✅ **Type safety**: `get_and_increment_work_item_number` enforces Transaction type
- ✅ **Error context**: All error messages include work item/project IDs
- ✅ **Proto semantics**: Properly handle `update_parent` field (field 12)
- ✅ **Documentation**: Counter gap behavior explained

### Files Modified (8)
- `pm-core/src/models/project.rs` - Add `next_work_item_number` field
- `pm-core/src/models/work_item.rs` - Add `item_number` field + `display_key()`
- `pm-db/src/repositories/project_repository.rs` - Add field + **type-safe** atomic increment + **counter gap docs**
- `pm-db/src/repositories/work_item_repository.rs` - Add field to queries + lookup method
- `pm-ws/src/handlers/response_builder.rs` - Add new fields to proto conversion
- `pm-ws/src/handlers/work_item.rs` - Atomic create + parent validation + **contextual errors**
- `pm-ws/src/handlers/change_tracker.rs` - Track parent_id changes (using `update_parent`)
- `pm-ws/src/handlers/hierarchy_validator.rs` - Documentation update (orphan items)

---

## Next Session

**Session 90.3** will implement the C# frontend:
- Domain models with new properties
- UpdateWorkItemRequest with ParentId
- ProtoConverter updates
- WorkItemViewModel
