# Session 90.3: C# Frontend (Models, Converter, ViewModel)

**Parent Plan**: `90-Session-Plan.md`
**Target**: ~25k tokens
**Prerequisites**: Session 90.1 complete (proto updated with `update_parent` field), proto code generation run

**CRITICAL FIXES APPLIED** (from Gordon Ramsay review):
- ✅ Added null validation to `GetDisplayKey()` (prevents "null-123")
- ✅ Properly map proto's `update_parent` field in converter
- ✅ Kept `UpdateParent` flag in C# model (maps to proto field)
- ✅ Added unit test suggestions for edge cases

---

## Scope

This session implements all C# frontend changes except Blazor UI:

1. **WorkItem Model** (Step 14) - Add `ItemNumber` and `GetDisplayKey()` with null safety
2. **Project Model** (Step 15) - Add `NextWorkItemNumber`
3. **UpdateWorkItemRequest** (Step 16) - Add `ParentId` and `UpdateParent` (maps to proto)
4. **ProtoConverter** (Step 17) - Map new fields including `update_parent`
5. **WorkItemViewModel** (Step 18) - Expose new properties
6. **Unit Tests** (Step 19 - NEW) - Test edge cases and proto conversion

---

## Implementation Order

### Step 14: Update C# Domain Model - WorkItem

**File**: `frontend/ProjectManagement.Core/Models/WorkItem.cs`

Add `ItemNumber` property and `GetDisplayKey()` method.

```csharp
public sealed record WorkItem :
    IAuditable,
    IProjectScoped,
    IVersioned,
    IPositioned,
    IHierarchical<WorkItem>,
    ISprintAssignable,
    IUserAssignable,
    IStatusTracked
{
    public WorkItemType ItemType { get; init; }
    public string Title { get; init; } = string.Empty;
    public string? Description { get; init; }
    public string Priority { get; init; } = "medium";
    public int? StoryPoints { get; init; }
    public Guid Id { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public Guid CreatedBy { get; init; }
    public Guid UpdatedBy { get; init; }
    public DateTime? DeletedAt { get; init; }
    public Guid? ParentId { get; init; }
    public int Position { get; init; }
    public Guid ProjectId { get; init; }
    public Guid? SprintId { get; init; }
    public string Status { get; init; } = "backlog";
    public Guid? AssigneeId { get; init; }
    public int Version { get; init; }

    /// <summary>
    /// Project-scoped sequential number (1, 2, 3...).
    /// Combined with project key forms the display ID (e.g., "PROJ-123").
    /// </summary>
    public int ItemNumber { get; init; }  // NEW

    /// <summary>
    /// Generate the JIRA-style display key (e.g., "PROJ-123").
    /// </summary>
    /// <param name="projectKey">The project key (must not be null or empty)</param>
    /// <returns>Display key in format "KEY-123"</returns>
    /// <exception cref="ArgumentException">Thrown if projectKey is null or empty</exception>
    public string GetDisplayKey(string projectKey)
    {
        ArgumentException.ThrowIfNullOrEmpty(projectKey, nameof(projectKey));
        return $"{projectKey}-{ItemNumber}";
    }
}
```

**CRITICAL FIX:**
- Original: `=> $"{projectKey}-{ItemNumber}";` (no null check)
- Fixed: Validates `projectKey` is not null/empty
- Prevents: Displaying "null-123" or "-123" in UI

**Why this matters:**
- If project hasn't loaded yet, could pass null
- User sees "null-123" instead of proper error or loading state
- ArgumentException provides clear diagnostic instead of silent corruption

**Verification**: `just build-cs-core`

---

### Step 15: Update C# Domain Model - Project

**File**: `frontend/ProjectManagement.Core/Models/Project.cs`

Add `NextWorkItemNumber` property.

```csharp
public sealed record Project
{
    public Guid Id { get; init; }
    public string Title { get; init; } = string.Empty;
    public string? Description { get; init; }
    public string Key { get; init; } = string.Empty;
    public ProjectStatus Status { get; init; } = ProjectStatus.Active;
    public int Version { get; init; } = 1;
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public Guid CreatedBy { get; init; }
    public Guid UpdatedBy { get; init; }

    /// <summary>
    /// When the project was soft-deleted (null if not deleted).
    /// </summary>
    public DateTime? DeletedAt { get; init; }

    /// <summary>
    /// Next sequential number to assign to work items.
    /// Atomically incremented when creating work items.
    /// </summary>
    public int NextWorkItemNumber { get; init; } = 1;  // NEW

    /// <summary>
    /// Check if the project is deleted.
    /// </summary>
    public bool IsDeleted => DeletedAt.HasValue;

    /// <summary>
    /// Check if the project is archived.
    /// </summary>
    public bool IsArchived => Status == ProjectStatus.Archived;
}
```

**Verification**: `just build-cs-core`

---

### Step 16: Update UpdateWorkItemRequest (Feature C)

**File**: `frontend/ProjectManagement.Core/Models/UpdateWorkItemRequest.cs`

Add `ParentId` and `UpdateParent` properties for parent editing.

```csharp
namespace ProjectManagement.Core.Models;

public sealed record UpdateWorkItemRequest
{
    public required Guid WorkItemId { get; init; }
    public required int ExpectedVersion { get; init; }
    public string? Title { get; init; }
    public string? Description { get; init; }
    public string? Status { get; init; }
    public string? Priority { get; init; }
    public Guid? AssigneeId { get; init; }
    public int? StoryPoints { get; init; }
    public Guid? SprintId { get; init; }
    public int? Position { get; init; }

    /// <summary>
    /// Parent work item ID. Set to Guid.Empty to clear the parent.
    /// Leave null to keep the current parent unchanged.
    /// </summary>
    public Guid? ParentId { get; init; }  // NEW

    /// <summary>
    /// Indicates whether ParentId should be updated (including clearing).
    /// Required because null ParentId could mean "no change" or "clear parent".
    /// </summary>
    public bool UpdateParent { get; init; }  // NEW
}
```

**Why `UpdateParent` flag?**
- `ParentId = null` is ambiguous: could mean "don't change" or "clear parent"
- `UpdateParent = true` with `ParentId = Guid.Empty` means "clear parent"
- `UpdateParent = true` with `ParentId = someGuid` means "set parent"
- `UpdateParent = false` means "don't change parent" regardless of ParentId value

**Verification**: `just build-cs-core`

---

### Step 17: Update C# ProtoConverter

**File**: `frontend/ProjectManagement.Core/Converters/ProtoConverter.cs`

Update all conversion methods to handle new fields.

#### 17.1 Update `ToDomain(ProtoWorkItem)`

```csharp
public static DomainWorkItem ToDomain(ProtoWorkItem proto)
{
    ArgumentNullException.ThrowIfNull(proto);

    return new DomainWorkItem
    {
        Id = ParseGuid(proto.Id, "WorkItem.Id"),
        ItemType = ToDomain(proto.ItemType),
        ParentId = string.IsNullOrEmpty(proto.ParentId) ? null : ParseGuid(proto.ParentId, "WorkItem.ParentId"),
        ProjectId = ParseGuid(proto.ProjectId, "WorkItem.ProjectId"),
        Position = proto.Position,
        Title = proto.Title ?? string.Empty,
        Description = string.IsNullOrEmpty(proto.Description) ? null : proto.Description,
        Status = proto.Status ?? "backlog",
        Priority = proto.Priority ?? "medium",
        AssigneeId = string.IsNullOrEmpty(proto.AssigneeId)
            ? null
            : ParseGuid(proto.AssigneeId, "WorkItem.AssigneeId"),
        StoryPoints = proto.StoryPoints == 0 ? null : proto.StoryPoints,
        SprintId = string.IsNullOrEmpty(proto.SprintId) ? null : ParseGuid(proto.SprintId, "WorkItem.SprintId"),
        ItemNumber = proto.ItemNumber,  // NEW
        Version = proto.Version,
        CreatedAt = FromUnixTimestamp(proto.CreatedAt),
        UpdatedAt = FromUnixTimestamp(proto.UpdatedAt),
        CreatedBy = ParseGuid(proto.CreatedBy, "WorkItem.CreatedBy"),
        UpdatedBy = ParseGuid(proto.UpdatedBy, "WorkItem.UpdatedBy"),
        DeletedAt = proto.DeletedAt == 0 ? null : FromUnixTimestamp(proto.DeletedAt)
    };
}
```

#### 17.2 Update `ToProto(DomainWorkItem)`

```csharp
public static ProtoWorkItem ToProto(DomainWorkItem domain)
{
    ArgumentNullException.ThrowIfNull(domain);

    var proto = new ProtoWorkItem
    {
        Id = domain.Id.ToString(),
        ItemType = ToProto(domain.ItemType),
        ProjectId = domain.ProjectId.ToString(),
        Position = domain.Position,
        Title = domain.Title,
        Status = domain.Status,
        Priority = domain.Priority,
        ItemNumber = domain.ItemNumber,  // NEW
        Version = domain.Version,
        CreatedAt = ToUnixTimestamp(domain.CreatedAt),
        UpdatedAt = ToUnixTimestamp(domain.UpdatedAt),
        CreatedBy = domain.CreatedBy.ToString(),
        UpdatedBy = domain.UpdatedBy.ToString()
    };

    if (!string.IsNullOrEmpty(domain.Description))
        proto.Description = domain.Description;

    if (domain.ParentId.HasValue)
        proto.ParentId = domain.ParentId.Value.ToString();

    if (domain.AssigneeId.HasValue)
        proto.AssigneeId = domain.AssigneeId.Value.ToString();

    if (domain.SprintId.HasValue)
        proto.SprintId = domain.SprintId.Value.ToString();

    if (domain.StoryPoints.HasValue)
        proto.StoryPoints = domain.StoryPoints.Value;

    if (domain.DeletedAt.HasValue)
        proto.DeletedAt = ToUnixTimestamp(domain.DeletedAt.Value);

    return proto;
}
```

#### 17.3 Update `ToDomain(Proto.Project)`

```csharp
public static Project ToDomain(Proto.Project proto)
{
    ArgumentNullException.ThrowIfNull(proto);

    return new Project
    {
        Id = ParseGuid(proto.Id, "Project.Id"),
        Title = proto.Title ?? string.Empty,
        Description = string.IsNullOrEmpty(proto.Description) ? null : proto.Description,
        Key = proto.Key ?? string.Empty,
        Status = proto.Status switch
        {
            Proto.ProjectStatus.Active => ProjectStatus.Active,
            Proto.ProjectStatus.Archived => ProjectStatus.Archived,
            _ => ProjectStatus.Active
        },
        Version = proto.Version,
        CreatedAt = FromUnixTimestamp(proto.CreatedAt),
        UpdatedAt = FromUnixTimestamp(proto.UpdatedAt),
        CreatedBy = ParseGuid(proto.CreatedBy, "Project.CreatedBy"),
        UpdatedBy = ParseGuid(proto.UpdatedBy, "Project.UpdatedBy"),
        DeletedAt = proto.DeletedAt == 0 ? null : FromUnixTimestamp(proto.DeletedAt),
        NextWorkItemNumber = proto.NextWorkItemNumber,  // NEW
    };
}
```

#### 17.4 Update `ToProto(UpdateWorkItemRequest)` (FIXED)

If there's a conversion method for UpdateWorkItemRequest to proto, update it:

```csharp
public static Proto.UpdateWorkItemRequest ToProto(UpdateWorkItemRequest request)
{
    var proto = new Proto.UpdateWorkItemRequest
    {
        WorkItemId = request.WorkItemId.ToString(),
        ExpectedVersion = request.ExpectedVersion,
        UpdateParent = request.UpdateParent,  // NEW: Map to proto field 12
    };

    // ... existing field mappings ...

    // NEW: Handle parent_id (only set if UpdateParent is true)
    if (request.UpdateParent)
    {
        // Set parent_id in proto:
        // - Empty string (or null/Guid.Empty) to clear parent
        // - UUID string to set parent
        proto.ParentId = request.ParentId == Guid.Empty || request.ParentId == null
            ? ""
            : request.ParentId.Value.ToString();
    }
    // If UpdateParent is false, don't set ParentId field at all (leave it unset)

    return proto;
}
```

**CRITICAL FIX:**
- Added: `UpdateParent = request.UpdateParent` to proto mapping
- This sets proto field 12 (`update_parent`) which Rust backend checks

**Why this matters:**
- Original plan didn't map UpdateParent → proto
- Rust backend would never see the "update parent" signal
- Backend couldn't distinguish "no change" from "clear parent"

**Verification**: `just build-cs-core`

---

### Step 18: Update WorkItemViewModel

**File**: `frontend/ProjectManagement.Core/ViewModels/WorkItemViewModel.cs`

Expose `ItemNumber` from the underlying model.

```csharp
// Find the Identity section (near other properties like Version, Id)
// Add these:

/// <summary>
/// Project-scoped sequential number (1, 2, 3...).
/// </summary>
public int ItemNumber => Model.ItemNumber;

/// <summary>
/// Generate the JIRA-style display key (e.g., "PROJ-123").
/// </summary>
public string GetDisplayKey(string projectKey) => Model.GetDisplayKey(projectKey);
```

The ViewModel delegates to the underlying Model, keeping the pattern consistent with other properties.

**Verification**: `just build-cs-core`

---

### Step 19: Add Unit Tests (NEW - CRITICAL)

**File**: `frontend/ProjectManagement.Core.Tests/Models/WorkItemTests.cs`

Add tests for the new `GetDisplayKey()` method:

```csharp
using FluentAssertions;
using ProjectManagement.Core.Models;
using Xunit;

namespace ProjectManagement.Core.Tests.Models;

public class WorkItemTests
{
    [Fact]
    public void GetDisplayKey_WithValidProjectKey_ReturnsFormattedKey()
    {
        // Arrange
        var workItem = new WorkItem { ItemNumber = 123 };

        // Act
        var displayKey = workItem.GetDisplayKey("PROJ");

        // Assert
        displayKey.Should().Be("PROJ-123");
    }

    [Fact]
    public void GetDisplayKey_WithNullProjectKey_ThrowsArgumentException()
    {
        // Arrange
        var workItem = new WorkItem { ItemNumber = 123 };

        // Act
        var act = () => workItem.GetDisplayKey(null!);

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithParameterName("projectKey");
    }

    [Fact]
    public void GetDisplayKey_WithEmptyProjectKey_ThrowsArgumentException()
    {
        // Arrange
        var workItem = new WorkItem { ItemNumber = 123 };

        // Act
        var act = () => workItem.GetDisplayKey("");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithParameterName("projectKey");
    }

    [Fact]
    public void GetDisplayKey_WithWhitespaceProjectKey_ThrowsArgumentException()
    {
        // Arrange
        var workItem = new WorkItem { ItemNumber = 123 };

        // Act
        var act = () => workItem.GetDisplayKey("   ");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithParameterName("projectKey");
    }
}
```

**File**: `frontend/ProjectManagement.Core.Tests/Converters/ProtoConverterTests.cs`

Add tests for proto conversion with `update_parent`:

```csharp
[Fact]
public void ToProto_UpdateWorkItemRequest_WithUpdateParentTrue_SetsProtoField()
{
    // Arrange
    var parentId = Guid.NewGuid();
    var request = new UpdateWorkItemRequest
    {
        WorkItemId = Guid.NewGuid(),
        ExpectedVersion = 1,
        UpdateParent = true,
        ParentId = parentId
    };

    // Act
    var proto = ProtoConverter.ToProto(request);

    // Assert
    proto.UpdateParent.Should().BeTrue();
    proto.ParentId.Should().Be(parentId.ToString());
}

[Fact]
public void ToProto_UpdateWorkItemRequest_WithUpdateParentFalse_DoesNotSetParentId()
{
    // Arrange
    var request = new UpdateWorkItemRequest
    {
        WorkItemId = Guid.NewGuid(),
        ExpectedVersion = 1,
        UpdateParent = false,
        ParentId = Guid.NewGuid()  // Should be ignored
    };

    // Act
    var proto = ProtoConverter.ToProto(request);

    // Assert
    proto.UpdateParent.Should().BeFalse();
    proto.HasParentId.Should().BeFalse();  // Proto field should not be set
}

[Fact]
public void ToProto_UpdateWorkItemRequest_WithUpdateParentTrueAndNullParentId_SetsEmptyString()
{
    // Arrange
    var request = new UpdateWorkItemRequest
    {
        WorkItemId = Guid.NewGuid(),
        ExpectedVersion = 1,
        UpdateParent = true,
        ParentId = null  // Clear parent
    };

    // Act
    var proto = ProtoConverter.ToProto(request);

    // Assert
    proto.UpdateParent.Should().BeTrue();
    proto.ParentId.Should().Be("");  // Empty string means "clear parent"
}
```

**Why these tests matter:**
- Catch null safety issues before runtime
- Verify proto conversion logic (easy to get wrong)
- Document expected behavior for future maintainers
- Run in CI to catch regressions

**Verification**: `just test-cs-core`

---

## Session 90.3 Completion Checklist

After completing all steps:

- [ ] **Step 14**: WorkItem model updated with `ItemNumber` and **null-safe** `GetDisplayKey()`
- [ ] **Step 15**: Project model updated with `NextWorkItemNumber`
- [ ] **Step 16**: UpdateWorkItemRequest updated with `ParentId` and `UpdateParent`
- [ ] **Step 17**: ProtoConverter updated (including **`update_parent` mapping**)
- [ ] **Step 18**: WorkItemViewModel updated
- [ ] **Step 19**: Unit tests added for null safety and proto conversion
- [ ] `just build-cs-core` passes
- [ ] `just test-cs-core` passes (including new tests)
- [ ] `just build-frontend` passes
- [ ] `just test-frontend` passes

### Critical Fixes Applied
- ✅ **Null safety**: `GetDisplayKey()` validates projectKey (prevents "null-123")
- ✅ **Proto mapping**: `UpdateParent` flag properly mapped to proto field 12
- ✅ **Unit tests**: Coverage for edge cases and proto conversion

### Files Modified (5)
- `ProjectManagement.Core/Models/WorkItem.cs` - Add `ItemNumber`, **null-safe** `GetDisplayKey()`
- `ProjectManagement.Core/Models/Project.cs` - Add `NextWorkItemNumber`
- `ProjectManagement.Core/Models/UpdateWorkItemRequest.cs` - Add `ParentId`, `UpdateParent`
- `ProjectManagement.Core/Converters/ProtoConverter.cs` - Map new fields including **`update_parent`**
- `ProjectManagement.Core/ViewModels/WorkItemViewModel.cs` - Expose `ItemNumber`, `GetDisplayKey()`

### Files Created (2 - NEW)
- `ProjectManagement.Core.Tests/Models/WorkItemTests.cs` - Test null safety
- `ProjectManagement.Core.Tests/Converters/ProtoConverterTests.cs` - Test proto conversion

---

## Next Session

**Session 90.4** will implement the Blazor UI:
- KanbanCard with JIRA-style ID
- KanbanBoard passing ProjectKey
- WorkItemRow with ID column
- WorkItemDetail with ID display
- WorkItemDialog with optional parent and edit mode
