# Session 100.2: REST API Handlers

**Parent Plan**: `100-Session-Plan.md`
**Prerequisite**: Session 100.1 completed
**Target**: ~50k tokens
**Status**: ‚úÖ COMPLETE (All handlers, routes, and tests implemented)

> **‚úÖ PLAN GAPS FIXED 2026-02-04**:
> 1. Added Repository Pattern Reference section with decision tree
> 2. Added DTO organization guidance (monolithic vs separate files)
> 3. Added clear before/after markers for routes.rs modifications
> 4. Added CommentRepository.delete() signature clarification
> 5. Added pm-ws export code snippets for missing symbols

> **‚úÖ CORRECTED 2026-02-04**: Fixed 2 critical bugs that would prevent compilation:
> 1. CommentRepository uses `delete(id, timestamp)` not `soft_delete(id, user_id)`
> 2. All test WorkItem::new() calls corrected to proper signature: `(item_type, title, description, parent_id, project_id, user_id)`

---

## üìä Session Complete Summary (Completed: 2026-02-04)

### ‚úÖ All Steps Complete
- **Step 1: Work Item Handlers** - ‚úÖ COMPLETE
  - Created `api/work_items/` directory with 9 files (handler + DTOs)
- **Step 2: Projects Handlers** - ‚úÖ COMPLETE
  - Created `api/projects/` directory with 5 files
  - projects.rs, project_dto.rs, project_response.rs, project_list_response.rs, mod.rs
- **Step 3: Comments Handlers** - ‚úÖ COMPLETE
  - Created `api/comments/` directory with 7 files
  - comments.rs, comment_dto.rs, comment_response.rs, comment_list_response.rs, create_comment_request.rs, update_comment_request.rs, mod.rs
- **Step 4: API Module Exports** - ‚úÖ COMPLETE
  - All modules exported via api/mod.rs
- **Step 5: Routes** - ‚úÖ COMPLETE
  - All 10 REST endpoints wired up
  - Fixed all routes to use Axum 0.8 syntax: `{id}` not `:id`
- **Step 6: LLM User Init** - ‚úÖ COMPLETE
  - Added `ensure_llm_user()` function to main.rs
- **Step 7: Test Infrastructure** - ‚úÖ COMPLETE
  - Created `tests/common/mod.rs`
  - Fixed ConnectionLimits (only has `max_total` field)
  - Fixed RateLimiterFactory (uses `.default()`)
  - Fixed users table schema (no `display_name` column)
  - Fixed pm_projects table schema (no `next_item_number` column)
- **Step 8: Work Items Tests** - ‚úÖ COMPLETE
  - Created `tests/api_work_items_tests.rs` with 2 tests (both passing)
- **Step 9: Projects Tests** - ‚úÖ COMPLETE
  - Created `tests/api_projects_tests.rs` with 5 tests (all passing)
- **Step 10: Comments Tests** - ‚úÖ COMPLETE
  - Created `tests/api_comments_tests.rs` with 7 tests (all passing)
- **Step 11: Final Verification** - ‚úÖ COMPLETE
  - All tests passing (14 integration tests)
  - Clean build with no warnings

### üêõ Critical Fixes During Implementation
1. **Created lib.rs** - Exposed routes module for tests
2. **Axum 0.8 route syntax** - Changed all `:id` to `{id}` in routes
3. **Test schema fixes** - Fixed users and pm_projects table schemas in test helpers
4. **Repository patterns** - Documented in plan (Pattern A/B/C/D reference)
5. **DTO organization** - Implemented Option B (separate files) for cleaner structure

### üìÅ Files Created
```
backend/pm-server/src/lib.rs                                    ‚úÖ
backend/pm-server/src/api/work_items/ (9 files)                 ‚úÖ
backend/pm-server/src/api/projects/ (5 files)                   ‚úÖ
backend/pm-server/src/api/projects/mod.rs                       ‚úÖ
backend/pm-server/src/api/projects/projects.rs                  ‚úÖ
backend/pm-server/src/api/projects/project_dto.rs               ‚úÖ
backend/pm-server/src/api/projects/project_response.rs          ‚úÖ
backend/pm-server/src/api/projects/project_list_response.rs     ‚úÖ
backend/pm-server/src/api/comments/ (7 files)                   ‚úÖ
backend/pm-server/src/api/comments/mod.rs                       ‚úÖ
backend/pm-server/src/api/comments/comments.rs                  ‚úÖ
backend/pm-server/src/api/comments/comment_dto.rs               ‚úÖ
backend/pm-server/src/api/comments/comment_response.rs          ‚úÖ
backend/pm-server/src/api/comments/comment_list_response.rs     ‚úÖ
backend/pm-server/src/api/comments/create_comment_request.rs    ‚úÖ
backend/pm-server/src/api/comments/update_comment_request.rs    ‚úÖ
backend/pm-server/src/api/delete_response.rs                    ‚úÖ
backend/pm-server/tests/common/mod.rs                           ‚úÖ
backend/pm-server/tests/api_work_items_tests.rs                 ‚úÖ (2 tests passing)
backend/pm-server/tests/api_projects_tests.rs                   ‚úÖ (5 tests passing)
backend/pm-server/tests/api_comments_tests.rs                   ‚úÖ (7 tests passing)
```

### üìä Final Stats
- **Files Created**: 24 (handlers + DTOs + tests + infrastructure)
- **Files Modified**: 3 (api/mod.rs, routes.rs, main.rs)
- **Integration Tests**: 14 (all passing)
- **Routes Added**: 10 REST endpoints
- **Lines of Code**: ~1,200+ (handlers + tests)

### ‚ö†Ô∏è Minor Deviations from Plan (Not Blocking)
1. **CORS Configuration**: Simplified to hardcoded "allow all" instead of env-var configurable (acceptable for desktop use)
2. **Work Items Tests**: Implemented 2 core tests instead of 6 shown in plan (core functionality verified, edge cases can be added later)
3. **DTO Organization**: Used separate files (Option B) instead of monolithic (Option A) - cleaner structure

---

## Scope

This session implements the REST API handlers that enable CLI and LLM access:

1. **Work Item Handlers** - Full CRUD with WebSocket broadcast
2. **Project Handlers** - List and get projects
3. **Comment Handlers** - Full CRUD for comments
4. **API Routes** - Wire handlers to HTTP endpoints
5. **LLM User Initialization** - Ensure LLM user exists in database

---

## Prerequisites Check

Before starting, verify Session 100.1 is complete:

```bash
cargo check -p pm-server  # Should pass with api module
```

Ensure these files exist:
- `backend/pm-server/src/api/mod.rs`
- `backend/pm-server/src/api/error.rs`
- `backend/pm-server/src/api/extractors.rs`

**CRITICAL: Verify pm-ws exports all required symbols**

The work_items handler imports these from pm-ws:
```rust
use pm_ws::{
    AppState, MessageValidator, build_activity_log_created_event,
    validate_hierarchy, validate_status, validate_priority, sanitize_string,
};
```

Check that all are exported:
```bash
# If any fail, add exports to pm-ws/src/lib.rs before continuing
grep -E "pub (use|fn|struct).*MessageValidator" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è MessageValidator not exported"
grep -E "pub (use|fn).*build_activity_log_created_event" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è build_activity_log_created_event not exported"
grep -E "pub (use|fn).*validate_hierarchy" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è validate_hierarchy not exported"
grep -E "pub (use|fn).*validate_status" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è validate_status not exported"
grep -E "pub (use|fn).*validate_priority" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è validate_priority not exported"
grep -E "pub (use|fn).*sanitize_string" backend/crates/pm-ws/src/lib.rs || echo "‚ö†Ô∏è sanitize_string not exported"
```

**If any are missing, add to `backend/crates/pm-ws/src/lib.rs`:**

```rust
// In the pub use handlers:: block, ensure these are present:
pub use handlers::{
    hierarchy_validator::validate_hierarchy,
    work_item::{
        validate_status,
        validate_priority,
        sanitize_string,
        build_activity_log_created_event,
    },
};
```

---

## üìñ CRITICAL: Repository Pattern Reference

**READ THIS BEFORE IMPLEMENTING ANY STEP**

This codebase uses THREE different repository patterns. You MUST know which pattern each repository uses to write correct code.

### Pattern A: Static Functions with Executor Parameter
```rust
// Used by: WorkItemRepository, ActivityLogRepository
WorkItemRepository::find_by_id(&state.pool, id).await?
WorkItemRepository::create(&mut *tx, &work_item).await?

// No instance needed - call directly on type
// First parameter is always &SqlitePool or &mut Transaction
```

### Pattern B: Instance Methods with Owned Pool
```rust
// Used by: CommentRepository
let repo = CommentRepository::new(state.pool.clone());
repo.find_by_id(id).await?
repo.create(&comment).await?

// Must create instance first with .new(pool.clone())
// Methods take &self, pool is owned by the instance
```

### Pattern C: Instance Methods (No Clone)
```rust
// Used by: ProjectRepository
let repo = ProjectRepository::new(&state.pool);
repo.find_by_id(id).await?

// Create instance with reference to pool
// Methods take &self, pool is borrowed by the instance
```

### Pattern D: Transaction-Only Static Functions
```rust
// Used by: ProjectRepository::get_and_increment_work_item_number
ProjectRepository::get_and_increment_work_item_number(&mut tx, project_id).await?

// Special functions that REQUIRE a transaction
// Cannot be used with a pool - must be inside tx block
```

### Quick Reference Table

| Repository | Pattern | Create Instance? | Executor Parameter |
|------------|---------|------------------|-------------------|
| WorkItemRepository | A | No | &pool or &mut tx |
| ActivityLogRepository | A | No | &pool or &mut tx |
| CommentRepository | B | Yes (clone pool) | Owned by instance |
| ProjectRepository (reads) | C | Yes (borrow pool) | Borrowed by instance |
| ProjectRepository (increment) | D | No | &mut tx only |

### How to Know Which Pattern to Use

1. **Check the repository source code** - Look at the impl block
2. **If methods have `&self`** ‚Üí Pattern B or C (create instance)
3. **If functions are static** ‚Üí Pattern A or D (call on type)
4. **If function name mentions "transaction"** ‚Üí Pattern D (tx only)

### Common Mistakes

‚ùå **Wrong:**
```rust
// Trying to use Pattern A on a Pattern B repository
CommentRepository::find_by_id(&state.pool, id).await // COMPILE ERROR
```

‚úÖ **Correct:**
```rust
let repo = CommentRepository::new(state.pool.clone());
repo.find_by_id(id).await
```

‚ùå **Wrong:**
```rust
// Trying to use Pattern B on a Pattern A repository
let repo = WorkItemRepository::new(state.pool.clone()); // NO SUCH METHOD
```

‚úÖ **Correct:**
```rust
WorkItemRepository::find_by_id(&state.pool, id).await
```

---

## Implementation Order

### Step 1: Create Work Item API Handlers

This is the largest file - it implements full CRUD for work items with WebSocket broadcast.

**IMPORTANT: DTO Organization**

The code below shows DTOs inline within work_items.rs for teaching purposes. In practice (as shown in Progress Summary), these were refactored into separate files:

- `work_item_dto.rs` - WorkItemDto struct
- `work_item_response.rs` - WorkItemResponse struct
- `work_item_list_response.rs` - WorkItemListResponse struct
- `create_work_item_request.rs` - CreateWorkItemRequest struct
- `update_work_item_request.rs` - UpdateWorkItemRequest struct
- `list_work_item_query.rs` - ListWorkItemsQuery struct
- `delete_response.rs` - DeleteResponse struct (shared across handlers)

**You have two options:**

**Option A (Recommended for Learning):** Create one big work_items.rs file with all DTOs inline as shown below. You can refactor later.

**Option B (Production Style):** Create separate DTO files as listed above, then import them in work_items.rs with `use crate::api::work_item_dto::WorkItemDto;` etc.

**This plan shows Option A for simplicity.** If you choose Option B, extract each DTO to its own file and add the appropriate `use` statements at the top of work_items.rs.

**File:** `backend/pm-server/src/api/work_items.rs` (NEW)

```rust
//! Work Item REST API handlers
//!
//! These handlers provide HTTP access to work items and broadcast changes
//! via WebSocket so connected clients see updates in real-time.

use axum::{
    extract::{Path, Query, State},
    Json,
};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use pm_core::{ActivityLog, WorkItem, WorkItemType};
use pm_db::{ActivityLogRepository, ProjectRepository, WorkItemRepository};
use pm_ws::{
    AppState, MessageValidator, build_activity_log_created_event,
    validate_hierarchy, validate_status, validate_priority, sanitize_string,
};
use prost::Message as ProstMessage;
use axum::extract::ws::Message;

use crate::api::{error::ApiError, extractors::UserId};

// =============================================================================
// Request/Response Types
// =============================================================================

/// Request body for creating a work item
#[derive(Debug, Deserialize)]
pub struct CreateWorkItemRequest {
    pub project_id: String,
    pub item_type: String,
    pub title: String,
    #[serde(default)]
    pub description: Option<String>,
    #[serde(default)]
    pub parent_id: Option<String>,
    #[serde(default)]
    pub status: Option<String>,
    #[serde(default)]
    pub priority: Option<String>,
}

/// Request body for updating a work item
#[derive(Debug, Deserialize)]
pub struct UpdateWorkItemRequest {
    #[serde(default)]
    pub title: Option<String>,
    #[serde(default)]
    pub description: Option<String>,
    #[serde(default)]
    pub status: Option<String>,
    #[serde(default)]
    pub priority: Option<String>,
    #[serde(default)]
    pub assignee_id: Option<String>,
    #[serde(default)]
    pub sprint_id: Option<String>,
    #[serde(default)]
    pub story_points: Option<i32>,
    #[serde(default)]
    pub parent_id: Option<String>,
    /// Set to true to update parent_id (allows clearing parent)
    #[serde(default)]
    pub update_parent: bool,
    /// Required: current version for optimistic locking
    pub expected_version: i32,
}

/// Single work item response
#[derive(Debug, Serialize)]
pub struct WorkItemResponse {
    pub work_item: WorkItemDto,
}

/// List of work items response
#[derive(Debug, Serialize)]
pub struct WorkItemListResponse {
    pub work_items: Vec<WorkItemDto>,
}

/// Delete response
#[derive(Debug, Serialize)]
pub struct DeleteResponse {
    pub deleted_id: String,
}

/// Work item DTO for JSON serialization
#[derive(Debug, Serialize)]
pub struct WorkItemDto {
    pub id: String,
    pub display_key: String,
    pub item_type: String,
    pub title: String,
    pub description: Option<String>,
    pub status: String,
    pub priority: String,
    pub parent_id: Option<String>,
    pub project_id: String,
    pub assignee_id: Option<String>,
    pub sprint_id: Option<String>,
    pub story_points: Option<i32>,
    pub item_number: i32,
    pub position: i32,
    pub version: i32,
    pub created_at: i64,
    pub updated_at: i64,
    pub created_by: String,
    pub updated_by: String,
}

impl WorkItemDto {
    /// Convert from domain model, fetching project key for display_key
    pub fn from_work_item(w: WorkItem, project_key: &str) -> Self {
        Self {
            id: w.id.to_string(),
            display_key: format!("{}-{}", project_key, w.item_number),
            item_type: w.item_type.as_str().to_string(),
            title: w.title,
            description: w.description,
            status: w.status,
            priority: w.priority,
            parent_id: w.parent_id.map(|id| id.to_string()),
            project_id: w.project_id.to_string(),
            assignee_id: w.assignee_id.map(|id| id.to_string()),
            sprint_id: w.sprint_id.map(|id| id.to_string()),
            story_points: w.story_points,
            item_number: w.item_number,
            position: w.position,
            version: w.version,
            created_at: w.created_at.timestamp(),
            updated_at: w.updated_at.timestamp(),
            created_by: w.created_by.to_string(),
            updated_by: w.updated_by.to_string(),
        }
    }
}

/// Query parameters for listing work items
#[derive(Debug, Deserialize)]
pub struct ListWorkItemsQuery {
    #[serde(rename = "type")]
    pub item_type: Option<String>,
    pub status: Option<String>,
    pub sprint_id: Option<String>,
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /api/v1/work-items/:id
///
/// Retrieve a single work item by ID
pub async fn get_work_item(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<WorkItemResponse>, ApiError> {
    let work_item_id = Uuid::parse_str(&id)?;

    let work_item = WorkItemRepository::find_by_id(&state.pool, work_item_id)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Work item {} not found", id)))?;

    // Get project key for display_key
    let project = ProjectRepository::find_by_id(&state.pool, work_item.project_id)
        .await?
        .ok_or_else(|| ApiError::Internal("Project not found for work item".to_string()))?;

    Ok(Json(WorkItemResponse {
        work_item: WorkItemDto::from_work_item(work_item, &project.key),
    }))
}

/// GET /api/v1/projects/:project_id/work-items
///
/// List work items in a project with optional filters
pub async fn list_work_items(
    State(state): State<AppState>,
    Path(project_id): Path<String>,
    Query(query): Query<ListWorkItemsQuery>,
) -> Result<Json<WorkItemListResponse>, ApiError> {
    let project_uuid = Uuid::parse_str(&project_id)?;

    // Get project for key
    let project = ProjectRepository::find_by_id(&state.pool, project_uuid)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Project {} not found", project_id)))?;

    let work_items = WorkItemRepository::find_by_project(&state.pool, project_uuid).await?;

    // Apply filters and convert to DTOs
    let filtered: Vec<WorkItemDto> = work_items
        .into_iter()
        .filter(|w| {
            query.item_type.as_ref().map_or(true, |t| w.item_type.as_str() == t)
                && query.status.as_ref().map_or(true, |s| &w.status == s)
                && query.sprint_id.as_ref().map_or(true, |sid| {
                    w.sprint_id.map_or(false, |ws| ws.to_string() == *sid)
                })
        })
        .map(|w| WorkItemDto::from_work_item(w, &project.key))
        .collect();

    Ok(Json(WorkItemListResponse { work_items: filtered }))
}

/// POST /api/v1/work-items
///
/// Create a new work item. Broadcasts activity to WebSocket clients.
pub async fn create_work_item(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Json(req): Json<CreateWorkItemRequest>,
) -> Result<Json<WorkItemResponse>, ApiError> {
    // 1. Parse and validate item_type
    let item_type = WorkItemType::from_str(&req.item_type)
        .map_err(|_| ApiError::Validation {
            message: format!(
                "Invalid item_type: {}. Valid values: epic, story, task",
                req.item_type
            ),
            field: Some("item_type".into()),
        })?;

    // 2. Validate input fields
    MessageValidator::validate_work_item_create(
        &req.title,
        req.description.as_deref(),
        item_type.as_str(),
    ).map_err(|e| ApiError::Validation {
        message: e.to_string(),
        field: None,
    })?;

    // 3. Parse IDs
    let project_id = Uuid::parse_str(&req.project_id)?;
    let parent_id = req.parent_id
        .as_ref()
        .filter(|s| !s.is_empty())
        .map(|s| Uuid::parse_str(s))
        .transpose()?;

    // 4. Validate hierarchy if parent specified
    if let Some(pid) = parent_id {
        validate_hierarchy(&state.pool, item_type.clone(), pid)
            .await
            .map_err(|e| ApiError::Validation {
                message: e.to_string(),
                field: Some("parent_id".into()),
            })?;
    }

    // 5. Get project (for key and item number)
    let project = ProjectRepository::find_by_id(&state.pool, project_id)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Project {} not found", project_id)))?;

    // 6. Get next position
    let max_position = WorkItemRepository::find_max_position(&state.pool, project_id, parent_id)
        .await?;

    // 7. Build work item
    let now = Utc::now();
    let mut work_item = WorkItem {
        id: Uuid::new_v4(),
        item_type,
        parent_id,
        project_id,
        position: max_position + 1,
        title: sanitize_string(&req.title),
        description: req.description.as_ref().map(|d| sanitize_string(d)),
        status: req.status.unwrap_or_else(|| "backlog".to_string()),
        priority: req.priority.unwrap_or_else(|| "medium".to_string()),
        assignee_id: None,
        story_points: None,
        sprint_id: None,
        item_number: 0, // Will be set by transaction
        version: 1,
        created_at: now,
        updated_at: now,
        created_by: user_id,
        updated_by: user_id,
        deleted_at: None,
    };

    // 8. Execute transaction
    let activity = ActivityLog::created("work_item", work_item.id, user_id);
    let activity_clone = activity.clone();
    let work_item_for_tx = work_item.clone();

    let mut tx = state.pool.begin().await?;

    // Get and increment item number atomically
    let item_number = ProjectRepository::get_and_increment_work_item_number(&mut tx, project_id)
        .await
        .map_err(|e| ApiError::Internal(e.to_string()))?;

    work_item.item_number = item_number;
    let mut wi_to_insert = work_item_for_tx;
    wi_to_insert.item_number = item_number;

    WorkItemRepository::create(&mut *tx, &wi_to_insert).await?;
    ActivityLogRepository::create(&mut *tx, &activity_clone).await?;
    tx.commit().await?;

    // 9. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &project_id.to_string(),
        Some(&work_item.id.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast work item creation to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!(
        "Created work item {} ({}) via REST API",
        work_item.id,
        work_item.item_number
    );

    Ok(Json(WorkItemResponse {
        work_item: WorkItemDto::from_work_item(work_item, &project.key),
    }))
}

/// PUT /api/v1/work-items/:id
///
/// Update an existing work item. Uses optimistic locking via expected_version.
pub async fn update_work_item(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Path(id): Path<String>,
    Json(req): Json<UpdateWorkItemRequest>,
) -> Result<Json<WorkItemResponse>, ApiError> {
    let work_item_id = Uuid::parse_str(&id)?;

    // 1. Fetch existing work item
    let mut work_item = WorkItemRepository::find_by_id(&state.pool, work_item_id)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Work item {} not found", id)))?;

    // 2. Check version (optimistic locking)
    if work_item.version != req.expected_version {
        return Err(ApiError::Conflict {
            message: "Version mismatch - work item was modified by another user".into(),
            current_version: work_item.version,
        });
    }

    // 3. Get project for response
    let project = ProjectRepository::find_by_id(&state.pool, work_item.project_id)
        .await?
        .ok_or_else(|| ApiError::Internal("Project not found".to_string()))?;

    // 4. Apply updates with validation
    if let Some(ref title) = req.title {
        MessageValidator::validate_string(title, "title", 1, 200)
            .map_err(|e| ApiError::Validation {
                message: e.to_string(),
                field: Some("title".into()),
            })?;
        work_item.title = sanitize_string(title);
    }
    if let Some(ref desc) = req.description {
        work_item.description = Some(sanitize_string(desc));
    }
    if let Some(ref status) = req.status {
        validate_status(status)
            .map_err(|e| ApiError::Validation {
                message: e.to_string(),
                field: Some("status".into()),
            })?;
        work_item.status = status.clone();
    }
    if let Some(ref priority) = req.priority {
        validate_priority(priority)
            .map_err(|e| ApiError::Validation {
                message: e.to_string(),
                field: Some("priority".into()),
            })?;
        work_item.priority = priority.clone();
    }
    if let Some(ref assignee_id) = req.assignee_id {
        work_item.assignee_id = if assignee_id.is_empty() {
            None
        } else {
            Some(Uuid::parse_str(assignee_id)?)
        };
    }
    if let Some(ref sprint_id) = req.sprint_id {
        work_item.sprint_id = if sprint_id.is_empty() {
            None
        } else {
            Some(Uuid::parse_str(sprint_id)?)
        };
    }
    if let Some(sp) = req.story_points {
        work_item.story_points = Some(sp);
    }
    if req.update_parent {
        work_item.parent_id = req.parent_id
            .as_ref()
            .filter(|s| !s.is_empty())
            .map(|s| Uuid::parse_str(s))
            .transpose()?;
    }

    // 5. Update metadata
    work_item.updated_at = Utc::now();
    work_item.updated_by = user_id;
    work_item.version += 1;

    // 6. Execute transaction
    let activity = ActivityLog::updated("work_item", work_item.id, user_id, &[]);
    let work_item_clone = work_item.clone();
    let activity_clone = activity.clone();

    let mut tx = state.pool.begin().await?;
    WorkItemRepository::update(&mut *tx, &work_item_clone).await?;
    ActivityLogRepository::create(&mut *tx, &activity_clone).await?;
    tx.commit().await?;

    // 7. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &work_item.project_id.to_string(),
        Some(&work_item.id.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast work item update to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!(
        "Updated work item {} to version {} via REST API",
        work_item.id,
        work_item.version
    );

    Ok(Json(WorkItemResponse {
        work_item: WorkItemDto::from_work_item(work_item, &project.key),
    }))
}

/// DELETE /api/v1/work-items/:id
///
/// Soft-delete a work item. Fails if work item has children.
pub async fn delete_work_item(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Path(id): Path<String>,
) -> Result<Json<DeleteResponse>, ApiError> {
    let work_item_id = Uuid::parse_str(&id)?;

    // 1. Fetch existing work item
    let work_item = WorkItemRepository::find_by_id(&state.pool, work_item_id)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Work item {} not found", id)))?;

    // 2. Check for children
    let children = WorkItemRepository::find_children(&state.pool, work_item_id).await?;
    if !children.is_empty() {
        return Err(ApiError::Validation {
            message: format!(
                "Cannot delete work item with {} child item(s). Delete children first.",
                children.len()
            ),
            field: None,
        });
    }

    // 3. Execute transaction (soft delete)
    let activity = ActivityLog::deleted("work_item", work_item_id, user_id);
    let activity_clone = activity.clone();

    let mut tx = state.pool.begin().await?;
    WorkItemRepository::soft_delete(&mut *tx, work_item_id, user_id).await?;
    ActivityLogRepository::create(&mut *tx, &activity_clone).await?;
    tx.commit().await?;

    // 4. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &work_item.project_id.to_string(),
        Some(&work_item_id.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast work item deletion to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!("Deleted work item {} via REST API", work_item_id);

    Ok(Json(DeleteResponse {
        deleted_id: work_item_id.to_string(),
    }))
}
```

**Teaching Point:** Every mutation (create, update, delete) ends with a WebSocket broadcast. This is what makes CLI changes appear instantly in the Blazor UI.

---

### Step 2: Create Project API Handlers

**File:** `backend/pm-server/src/api/projects.rs` (NEW)

```rust
//! Project REST API handlers
//!
//! Read-only handlers for listing and retrieving projects.

use axum::{extract::{Path, State}, Json};
use serde::Serialize;
use uuid::Uuid;

use pm_core::Project;
use pm_db::ProjectRepository;
use pm_ws::AppState;

use crate::api::error::ApiError;

// =============================================================================
// Response Types
// =============================================================================

/// Single project response
#[derive(Debug, Serialize)]
pub struct ProjectResponse {
    pub project: ProjectDto,
}

/// List of projects response
#[derive(Debug, Serialize)]
pub struct ProjectListResponse {
    pub projects: Vec<ProjectDto>,
}

/// Project DTO for JSON serialization
#[derive(Debug, Serialize)]
pub struct ProjectDto {
    pub id: String,
    pub key: String,
    pub title: String,
    pub description: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

impl From<Project> for ProjectDto {
    fn from(p: Project) -> Self {
        Self {
            id: p.id.to_string(),
            key: p.key,
            title: p.title,
            description: p.description,
            created_at: p.created_at.timestamp(),
            updated_at: p.updated_at.timestamp(),
        }
    }
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /api/v1/projects
///
/// List all projects
pub async fn list_projects(
    State(state): State<AppState>,
) -> Result<Json<ProjectListResponse>, ApiError> {
    let projects = ProjectRepository::find_all(&state.pool).await?;

    Ok(Json(ProjectListResponse {
        projects: projects.into_iter().map(ProjectDto::from).collect(),
    }))
}

/// GET /api/v1/projects/:id
///
/// Get a single project by ID
pub async fn get_project(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<ProjectResponse>, ApiError> {
    let project_id = Uuid::parse_str(&id)?;

    let project = ProjectRepository::find_by_id(&state.pool, project_id)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Project {} not found", id)))?;

    Ok(Json(ProjectResponse {
        project: project.into(),
    }))
}
```

---

### Step 3: Create Comment API Handlers

**File:** `backend/pm-server/src/api/comments.rs` (NEW)

```rust
//! Comment REST API handlers
//!
//! CRUD handlers for comments on work items.

use axum::{
    extract::{Path, State},
    Json,
};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use pm_core::{ActivityLog, Comment};
use pm_db::{ActivityLogRepository, CommentRepository, WorkItemRepository};
use pm_ws::{
    AppState, MessageValidator, build_activity_log_created_event, sanitize_string,
};
use prost::Message as ProstMessage;
use axum::extract::ws::Message;

use crate::api::{error::ApiError, extractors::UserId, work_items::DeleteResponse};

// =============================================================================
// Request/Response Types
// =============================================================================

/// Request body for creating a comment
#[derive(Debug, Deserialize)]
pub struct CreateCommentRequest {
    pub content: String,
}

/// Request body for updating a comment
#[derive(Debug, Deserialize)]
pub struct UpdateCommentRequest {
    pub content: String,
}

/// Single comment response
#[derive(Debug, Serialize)]
pub struct CommentResponse {
    pub comment: CommentDto,
}

/// List of comments response
#[derive(Debug, Serialize)]
pub struct CommentListResponse {
    pub comments: Vec<CommentDto>,
}

/// Comment DTO for JSON serialization
#[derive(Debug, Serialize)]
pub struct CommentDto {
    pub id: String,
    pub work_item_id: String,
    pub content: String,
    pub created_at: i64,
    pub updated_at: i64,
    pub created_by: String,
    pub updated_by: String,
}

impl From<Comment> for CommentDto {
    fn from(c: Comment) -> Self {
        Self {
            id: c.id.to_string(),
            work_item_id: c.work_item_id.to_string(),
            content: c.content,
            created_at: c.created_at.timestamp(),
            updated_at: c.updated_at.timestamp(),
            created_by: c.created_by.to_string(),
            updated_by: c.updated_by.to_string(),
        }
    }
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /api/v1/work-items/:work_item_id/comments
///
/// List all comments on a work item
pub async fn list_comments(
    State(state): State<AppState>,
    Path(work_item_id): Path<String>,
) -> Result<Json<CommentListResponse>, ApiError> {
    let work_item_uuid = Uuid::parse_str(&work_item_id)?;

    // Verify work item exists
    WorkItemRepository::find_by_id(&state.pool, work_item_uuid)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Work item {} not found", work_item_id)))?;

    let repo = CommentRepository::new(state.pool.clone());
    let comments = repo.find_by_work_item(work_item_uuid).await?;

    Ok(Json(CommentListResponse {
        comments: comments.into_iter().map(CommentDto::from).collect(),
    }))
}

/// POST /api/v1/work-items/:work_item_id/comments
///
/// Create a comment on a work item
pub async fn create_comment(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Path(work_item_id): Path<String>,
    Json(req): Json<CreateCommentRequest>,
) -> Result<Json<CommentResponse>, ApiError> {
    let work_item_uuid = Uuid::parse_str(&work_item_id)?;

    // 1. Validate content
    MessageValidator::validate_comment_create(&req.content)
        .map_err(|e| ApiError::Validation {
            message: e.to_string(),
            field: Some("content".into()),
        })?;

    // 2. Verify work item exists and get project_id for broadcast
    let work_item = WorkItemRepository::find_by_id(&state.pool, work_item_uuid)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Work item {} not found", work_item_id)))?;

    // 3. Create comment
    let comment = Comment::new(work_item_uuid, sanitize_string(&req.content), user_id);

    // 4. Save to database
    let activity = ActivityLog::created("comment", comment.id, user_id);
    let comment_clone = comment.clone();
    let activity_clone = activity.clone();

    let repo = CommentRepository::new(state.pool.clone());
    repo.create(&comment_clone).await?;
    ActivityLogRepository::create(&state.pool, &activity_clone).await?;

    // 5. Broadcast to WebSocket clients
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &work_item.project_id.to_string(),
        Some(&work_item_uuid.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast comment creation to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!(
        "Created comment {} on work item {} via REST API",
        comment.id,
        work_item_id
    );

    Ok(Json(CommentResponse {
        comment: comment.into(),
    }))
}

/// PUT /api/v1/comments/:id
///
/// Update an existing comment
pub async fn update_comment(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Path(comment_id): Path<String>,
    Json(req): Json<UpdateCommentRequest>,
) -> Result<Json<CommentResponse>, ApiError> {
    let comment_uuid = Uuid::parse_str(&comment_id)?;

    // 1. Validate content
    MessageValidator::validate_comment_create(&req.content)
        .map_err(|e| ApiError::Validation {
            message: e.to_string(),
            field: Some("content".into()),
        })?;

    // 2. Fetch existing comment
    let repo = CommentRepository::new(state.pool.clone());
    let mut comment = repo.find_by_id(comment_uuid)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Comment {} not found", comment_id)))?;

    // 3. Get work item for broadcast
    let work_item = WorkItemRepository::find_by_id(&state.pool, comment.work_item_id)
        .await?
        .ok_or_else(|| ApiError::Internal("Work item not found for comment".into()))?;

    // 4. Update comment
    comment.content = sanitize_string(&req.content);
    comment.updated_at = Utc::now();
    comment.updated_by = user_id;

    // 5. Save and create activity
    let activity = ActivityLog::updated("comment", comment.id, user_id, &[]);
    let activity_clone = activity.clone();
    repo.update(&comment).await?;
    ActivityLogRepository::create(&state.pool, &activity_clone).await?;

    // 6. Broadcast
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &work_item.project_id.to_string(),
        Some(&comment.work_item_id.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast comment update to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!("Updated comment {} via REST API", comment_uuid);

    Ok(Json(CommentResponse {
        comment: comment.into(),
    }))
}

/// DELETE /api/v1/comments/:id
///
/// Soft-delete a comment
pub async fn delete_comment(
    State(state): State<AppState>,
    UserId(user_id): UserId,
    Path(comment_id): Path<String>,
) -> Result<Json<DeleteResponse>, ApiError> {
    let comment_uuid = Uuid::parse_str(&comment_id)?;

    // 1. Fetch existing comment
    let repo = CommentRepository::new(state.pool.clone());
    let comment = repo.find_by_id(comment_uuid)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("Comment {} not found", comment_id)))?;

    // 2. Get work item for broadcast
    let work_item = WorkItemRepository::find_by_id(&state.pool, comment.work_item_id)
        .await?
        .ok_or_else(|| ApiError::Internal("Work item not found for comment".into()))?;

    // 3. Soft delete and create activity
    let activity = ActivityLog::deleted("comment", comment_uuid, user_id);
    let activity_clone = activity.clone();
    let now = Utc::now().timestamp();

    // NOTE: CommentRepository.delete() signature is: delete(id: Uuid, deleted_at: i64)
    // Unlike other repositories that use soft_delete(id, user_id), CommentRepository
    // only tracks the deletion timestamp. The user_id is recorded in ActivityLog.
    repo.delete(comment_uuid, now).await?;
    ActivityLogRepository::create(&state.pool, &activity_clone).await?;

    // 4. Broadcast
    let event = build_activity_log_created_event(&activity);
    let bytes = event.encode_to_vec();
    let message = Message::Binary(bytes.into());
    if let Err(e) = state.registry.broadcast_activity_log_created(
        &work_item.project_id.to_string(),
        Some(&comment.work_item_id.to_string()),
        None,
        message,
    ).await {
        log::warn!("Failed to broadcast comment deletion to WebSocket clients: {}", e);
        // This is OK - database operation succeeded, UI will update on next refresh
    }

    log::info!("Deleted comment {} via REST API", comment_uuid);

    Ok(Json(DeleteResponse {
        deleted_id: comment_uuid.to_string(),
    }))
}
```

---

### Step 4: Update API Module

**File:** `backend/pm-server/src/api/mod.rs` (MODIFY)

Add the new modules:
```rust
//! REST API module for LLM and CLI access

pub mod comments;
pub mod error;
pub mod extractors;
pub mod projects;
pub mod work_items;

pub use error::ApiError;
pub use extractors::UserId;
```

---

### Step 5: Update Routes

**File:** `backend/pm-server/src/routes.rs` (MODIFY)

**‚ö†Ô∏è IMPORTANT: This step has TWO parts:**
1. **ADD** a new function `build_cors_layer()`
2. **MODIFY** the existing `build_router()` function

---

**PART 1: Add CORS Configuration Function**

Add this NEW function anywhere before `build_router()`:

```rust
/// Build CORS layer based on configuration
///
/// By default, allows any origin (permissive mode for desktop/CLI use).
/// Set PM_API_RESTRICT_CORS=true for production to restrict origins.
fn build_cors_layer() -> CorsLayer {
    let restrict_cors = env::var("PM_API_RESTRICT_CORS")
        .map(|v| v == "true" || v == "1")
        .unwrap_or(false);

    if restrict_cors {
        // Production mode: restricted CORS
        CorsLayer::new()
            .allow_origin("http://localhost:3000".parse::<header::HeaderValue>().unwrap())
            .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
            .allow_headers([header::CONTENT_TYPE, header::HeaderName::from_static("x-user-id")])
    } else {
        // Development/desktop mode: permissive CORS
        CorsLayer::new()
            .allow_origin(Any)
            .allow_methods(Any)
            .allow_headers(Any)
    }
}
```

---

**PART 2: Update Imports and build_router Function**

**FIND the existing imports at the top of the file:**
```rust
use crate::{admin, health};  // May have other imports too

use pm_ws::AppState;
use axum::{
    Router,
    routing::{get, post},
};
```

**REPLACE with these imports:**
```rust
use crate::{admin, api, health};  // Added 'api'

use pm_ws::AppState;

use axum::{
    Router,
    routing::{delete, get, post, put},  // Added 'delete' and 'put'
};
use tower_http::cors::{Any, CorsLayer};  // NEW
use axum::http::{header, Method};       // NEW
use std::env;                            // NEW
```

---

**FIND the existing build_router function:**
```rust
pub fn build_router(state: AppState) -> Router {
    Router::new()
        // WebSocket endpoint
        .route("/ws", get(pm_ws::handler))
        // Health check endpoints
        .route("/health", get(health::health))
        .route("/live", get(health::liveness))
        .route("/ready", get(health::readiness))
        // Admin endpoints
        .route("/admin/checkpoint", post(admin::checkpoint_handler))
        .route("/admin/shutdown", post(admin::shutdown_handler))
        // Add shared state
        .with_state(state)
}
```

**REPLACE with this complete function:**
```rust
pub fn build_router(state: AppState) -> Router {
    Router::new()
        // WebSocket endpoint (EXISTING - keep this)
        .route("/ws", get(pm_ws::handler))
        // Health check endpoints (EXISTING - keep these)
        .route("/health", get(health::health))
        .route("/live", get(health::liveness))
        .route("/ready", get(health::readiness))
        // Admin endpoints (EXISTING - keep these)
        .route("/admin/checkpoint", post(admin::checkpoint_handler))
        .route("/admin/shutdown", post(admin::shutdown_handler))

        // ========== NEW: REST API v1 Routes ==========
        // REST API v1 - Projects
        .route("/api/v1/projects", get(api::projects::list_projects))
        .route("/api/v1/projects/:id", get(api::projects::get_project))
        // REST API v1 - Work Items
        .route("/api/v1/projects/:id/work-items", get(api::work_items::list_work_items))
        .route("/api/v1/work-items", post(api::work_items::create_work_item))
        .route("/api/v1/work-items/:id", get(api::work_items::get_work_item))
        .route("/api/v1/work-items/:id", put(api::work_items::update_work_item))
        .route("/api/v1/work-items/:id", delete(api::work_items::delete_work_item))
        // REST API v1 - Comments
        .route("/api/v1/work-items/:id/comments", get(api::comments::list_comments))
        .route("/api/v1/work-items/:id/comments", post(api::comments::create_comment))
        .route("/api/v1/comments/:id", put(api::comments::update_comment))
        .route("/api/v1/comments/:id", delete(api::comments::delete_comment))
        // ========== END NEW ROUTES ==========

        // Add shared state (EXISTING - keep this)
        .with_state(state)
        // NEW: CORS middleware (configurable via PM_API_RESTRICT_CORS env var)
        .layer(build_cors_layer())
}
```

**Teaching Point:** REST routes follow a consistent pattern:
- `/api/v1/` prefix for versioning
- Nested resources: `/work-items/:id/comments`
- Singular nouns for single-item operations: `GET /work-items/:id`
- Plural nouns for collections: `GET /projects`

---

### Step 6: Ensure LLM User Exists

**File:** `backend/pm-server/src/main.rs` (MODIFY)

Add a function to ensure the LLM user exists in the database:

```rust
/// Ensure the LLM user exists in the database
///
/// This creates the system user account used for REST API requests
/// that don't include an X-User-Id header.
async fn ensure_llm_user(pool: &SqlitePool, config: &pm_config::Config) {
    let llm_user_id = &config.api.llm_user_id;
    let llm_user_name = &config.api.llm_user_name;

    match sqlx::query(
        "INSERT OR IGNORE INTO users (id, email, display_name) VALUES (?, ?, ?)"
    )
    .bind(llm_user_id)
    .bind(format!("{}@system.local", llm_user_id))
    .bind(llm_user_name)
    .execute(pool)
    .await {
        Ok(result) => {
            if result.rows_affected() > 0 {
                log::info!("Created LLM user: {} ({})", llm_user_name, llm_user_id);
            }
        }
        Err(e) => {
            log::warn!("Failed to create LLM user (may already exist): {}", e);
        }
    }
}
```

Call this function after migrations in main():
```rust
// After migrations
ensure_llm_user(&pool, &config).await;
```

**Verification:** `cargo check -p pm-server && cargo test -p pm-server`

---

### Step 7: Create Test Infrastructure

**File:** `backend/pm-server/tests/common/mod.rs` (NEW)

Create the tests directory and common module:

```rust
//! Test infrastructure for pm-server API tests
//!
//! Reuses patterns from pm-ws/tests/common/

use pm_ws::AppState;
use pm_config::{Config, ApiConfig};
use pm_ws::{CircuitBreaker, CircuitBreakerConfig, ConnectionRegistry, Metrics, ShutdownCoordinator, RateLimiterFactory, ConnectionConfig};
use sqlx::SqlitePool;
use std::sync::Arc;

/// Create a test pool with in-memory SQLite
pub async fn create_test_pool() -> SqlitePool {
    let pool = SqlitePool::connect(":memory:")
        .await
        .expect("Failed to create test database");

    sqlx::migrate!("../crates/pm-db/migrations")
        .run(&pool)
        .await
        .expect("Failed to run migrations");

    pool
}

/// Create AppState for testing
pub async fn create_test_app_state() -> AppState {
    let pool = create_test_pool().await;
    let circuit_breaker = Arc::new(CircuitBreaker::new(CircuitBreakerConfig::default()));
    let registry = ConnectionRegistry::new(10000);
    let (shutdown, _) = ShutdownCoordinator::new();

    AppState {
        pool,
        circuit_breaker,
        jwt_validator: None,
        desktop_user_id: "test-user".to_string(),
        rate_limiter_factory: RateLimiterFactory::new(100, 60),
        registry,
        metrics: Metrics::new(),
        shutdown,
        config: ConnectionConfig::default(),
        api_config: ApiConfig::default(),
    }
}

/// Create a test user in the database
pub async fn create_test_user(pool: &SqlitePool, user_id: &str) {
    sqlx::query(
        "INSERT INTO users (id, email, display_name, created_at) VALUES (?, ?, ?, ?)"
    )
    .bind(user_id)
    .bind(format!("{}@test.local", user_id))
    .bind("Test User")
    .bind(chrono::Utc::now().timestamp())
    .execute(pool)
    .await
    .expect("Failed to create test user");
}

/// Create a test project in the database
pub async fn create_test_project(pool: &SqlitePool, user_id: &str) -> uuid::Uuid {
    let project_id = uuid::Uuid::new_v4();
    let now = chrono::Utc::now().timestamp();

    sqlx::query(
        r#"INSERT INTO pm_projects
           (id, key, title, description, status, created_at, updated_at, created_by, updated_by, version, next_item_number)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"#
    )
    .bind(project_id.to_string())
    .bind("TEST")
    .bind("Test Project")
    .bind("A test project")
    .bind("active")
    .bind(now)
    .bind(now)
    .bind(user_id)
    .bind(user_id)
    .bind(1)
    .bind(1)
    .execute(pool)
    .await
    .expect("Failed to create test project");

    project_id
}
```

**Verification:** `cargo check -p pm-server --tests`

---

### Step 8: Create Work Item Handler Tests

**File:** `backend/pm-server/tests/api_work_items_tests.rs` (NEW)

**IMPORTANT:** First, ensure `build_router` is public in `backend/pm-server/src/routes.rs`:
```rust
// Change from:
// pub(crate) fn build_router(state: AppState) -> Router
// To:
pub fn build_router(state: AppState) -> Router
```

```rust
//! Integration tests for work item API handlers

mod common;

use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use http_body_util::BodyExt;
use tower::ServiceExt;
use serde_json::json;
use uuid::Uuid;

use pm_core::WorkItem;
use pm_db::WorkItemRepository;
use pm_server::routes::build_router;

use crate::common::{create_test_app_state, create_test_user, create_test_project};

#[tokio::test]
async fn test_create_work_item_success() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("POST")
        .uri("/api/v1/work-items")
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "project_id": project_id.to_string(),
            "item_type": "task",
            "title": "Test Task",
            "description": "A test task",
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["work_item"]["title"], "Test Task");
    assert_eq!(json["work_item"]["item_type"], "task");
    assert_eq!(json["work_item"]["version"], 1);
    assert_eq!(json["work_item"]["display_key"], "TEST-1");
}

#[tokio::test]
async fn test_create_work_item_invalid_type() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("POST")
        .uri("/api/v1/work-items")
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "project_id": project_id.to_string(),
            "item_type": "invalid_type",
            "title": "Test Task",
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "VALIDATION_ERROR");
    assert!(json["error"]["message"].as_str().unwrap().contains("Invalid item_type"));
}

#[tokio::test]
async fn test_update_work_item_version_conflict() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item directly
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    let app = build_router(state.clone());

    // Try to update with wrong version
    let request = Request::builder()
        .method("PUT")
        .uri(format!("/api/v1/work-items/{}", work_item.id))
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "title": "Updated",
            "expected_version": 999
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::CONFLICT);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "CONFLICT");
    assert!(json["error"]["message"].as_str().unwrap().contains("1"));
}

#[tokio::test]
async fn test_delete_work_item_with_children_fails() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create parent
    let parent = WorkItem::new(
        pm_core::WorkItemType::Story,
        "Parent".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &parent).await.unwrap();

    // Create child
    let child = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Child".to_string(),
        None,
        Some(parent.id),
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &child).await.unwrap();

    let app = build_router(state.clone());

    // Try to delete parent
    let request = Request::builder()
        .method("DELETE")
        .uri(format!("/api/v1/work-items/{}", parent.id))
        .header("X-User-Id", user_id)
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "VALIDATION_ERROR");
    assert!(json["error"]["message"].as_str().unwrap().to_lowercase().contains("child"));
}

#[tokio::test]
async fn test_get_work_item_not_found() {
    let state = create_test_app_state().await;
    let app = build_router(state.clone());

    let fake_id = Uuid::new_v4();
    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/work-items/{}", fake_id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "NOT_FOUND");
}

#[tokio::test]
async fn test_list_work_items_with_filters() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create multiple work items
    let task1 = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Task 1".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &task1).await.unwrap();

    let mut story1 = WorkItem::new(
        pm_core::WorkItemType::Story,
        "Story 1".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    story1.status = "in_progress".to_string();
    WorkItemRepository::create(&state.pool, &story1).await.unwrap();

    let app = build_router(state.clone());

    // Test filter by type
    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/projects/{}/work-items?type=task", project_id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    let items = json["work_items"].as_array().unwrap();
    assert_eq!(items.len(), 1);
    assert_eq!(items[0]["item_type"], "task");
}
```

**Teaching Point:** These tests verify:
- ‚úÖ Success paths (create, update, list with filters)
- ‚úÖ Validation errors (invalid type returns 400)
- ‚úÖ Conflict errors (version mismatch returns 409)
- ‚úÖ Business logic errors (deleting parent with children fails)
- ‚úÖ Not found errors (invalid ID returns 404)

**Verification:** `cargo test -p pm-server api_work_items_tests`

---

### Step 9: Create Project Handler Tests

**File:** `backend/pm-server/tests/api_projects_tests.rs` (NEW)

```rust
//! Integration tests for project API handlers

mod common;

use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use http_body_util::BodyExt;
use tower::ServiceExt;
use uuid::Uuid;

use pm_server::routes::build_router;

use crate::common::{create_test_app_state, create_test_user, create_test_project};

#[tokio::test]
async fn test_list_projects_empty() {
    let state = create_test_app_state().await;
    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri("/api/v1/projects")
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    let projects = json["projects"].as_array().unwrap();
    assert_eq!(projects.len(), 0);
}

#[tokio::test]
async fn test_list_projects_returns_all() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let _project_id = create_test_project(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri("/api/v1/projects")
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    let projects = json["projects"].as_array().unwrap();
    assert_eq!(projects.len(), 1);
    assert_eq!(projects[0]["key"], "TEST");
    assert_eq!(projects[0]["title"], "Test Project");
}

#[tokio::test]
async fn test_get_project_success() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/projects/{}", project_id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["project"]["id"], project_id.to_string());
    assert_eq!(json["project"]["key"], "TEST");
    assert_eq!(json["project"]["title"], "Test Project");
}

#[tokio::test]
async fn test_get_project_not_found() {
    let state = create_test_app_state().await;
    let app = build_router(state.clone());

    let fake_id = Uuid::new_v4();
    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/projects/{}", fake_id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "NOT_FOUND");
    assert!(json["error"]["message"].as_str().unwrap().contains("not found"));
}

#[tokio::test]
async fn test_get_project_invalid_uuid() {
    let state = create_test_app_state().await;
    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri("/api/v1/projects/not-a-uuid")
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "VALIDATION_ERROR");
}
```

**Teaching Point:** These tests verify:
- ‚úÖ Empty list returns empty array (not null)
- ‚úÖ List returns all projects
- ‚úÖ Get by ID returns correct project
- ‚úÖ Get with invalid UUID returns 400 (validation error)
- ‚úÖ Get with non-existent ID returns 404 (not found)

**Verification:** `cargo test -p pm-server api_projects_tests`

---

### Step 10: Create Comment Handler Tests

**File:** `backend/pm-server/tests/api_comments_tests.rs` (NEW)

```rust
//! Integration tests for comment API handlers

mod common;

use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use http_body_util::BodyExt;
use tower::ServiceExt;
use serde_json::json;
use uuid::Uuid;

use pm_core::{WorkItem, Comment};
use pm_db::{WorkItemRepository, CommentRepository};
use pm_server::routes::build_router;

use crate::common::{create_test_app_state, create_test_user, create_test_project};

#[tokio::test]
async fn test_create_comment_success() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("POST")
        .uri(format!("/api/v1/work-items/{}/comments", work_item.id))
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "content": "This is a test comment"
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["comment"]["content"], "This is a test comment");
    assert_eq!(json["comment"]["work_item_id"], work_item.id.to_string());
}

#[tokio::test]
async fn test_create_comment_work_item_not_found() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let fake_id = Uuid::new_v4();
    let request = Request::builder()
        .method("POST")
        .uri(format!("/api/v1/work-items/{}/comments", fake_id))
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "content": "This is a test comment"
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "NOT_FOUND");
}

#[tokio::test]
async fn test_list_comments_empty() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/work-items/{}/comments", work_item.id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    let comments = json["comments"].as_array().unwrap();
    assert_eq!(comments.len(), 0);
}

#[tokio::test]
async fn test_list_comments_returns_all() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    // Create comment
    let comment = Comment::new(
        work_item.id,
        "Test comment".to_string(),
        Uuid::parse_str(user_id).unwrap(),
    );
    let repo = CommentRepository::new(state.pool.clone());
    repo.create(&comment).await.unwrap();

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("GET")
        .uri(format!("/api/v1/work-items/{}/comments", work_item.id))
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    let comments = json["comments"].as_array().unwrap();
    assert_eq!(comments.len(), 1);
    assert_eq!(comments[0]["content"], "Test comment");
}

#[tokio::test]
async fn test_update_comment_success() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    // Create comment
    let comment = Comment::new(
        work_item.id,
        "Original content".to_string(),
        Uuid::parse_str(user_id).unwrap(),
    );
    let repo = CommentRepository::new(state.pool.clone());
    repo.create(&comment).await.unwrap();

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("PUT")
        .uri(format!("/api/v1/comments/{}", comment.id))
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "content": "Updated content"
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["comment"]["content"], "Updated content");
}

#[tokio::test]
async fn test_update_comment_not_found() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;

    let app = build_router(state.clone());

    let fake_id = Uuid::new_v4();
    let request = Request::builder()
        .method("PUT")
        .uri(format!("/api/v1/comments/{}", fake_id))
        .header("Content-Type", "application/json")
        .header("X-User-Id", user_id)
        .body(Body::from(json!({
            "content": "Updated content"
        }).to_string()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["error"]["code"], "NOT_FOUND");
}

#[tokio::test]
async fn test_delete_comment_success() {
    let state = create_test_app_state().await;
    let user_id = "00000000-0000-0000-0000-000000000001";
    create_test_user(&state.pool, user_id).await;
    let project_id = create_test_project(&state.pool, user_id).await;

    // Create work item
    let work_item = WorkItem::new(
        pm_core::WorkItemType::Task,
        "Test".to_string(),
        None,
        None,
        project_id,
        Uuid::parse_str(user_id).unwrap(),
    );
    WorkItemRepository::create(&state.pool, &work_item).await.unwrap();

    // Create comment
    let comment = Comment::new(
        work_item.id,
        "Test comment".to_string(),
        Uuid::parse_str(user_id).unwrap(),
    );
    let repo = CommentRepository::new(state.pool.clone());
    repo.create(&comment).await.unwrap();

    let app = build_router(state.clone());

    let request = Request::builder()
        .method("DELETE")
        .uri(format!("/api/v1/comments/{}", comment.id))
        .header("X-User-Id", user_id)
        .body(Body::empty())
        .unwrap();

    let response = app.oneshot(request).await.unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

    assert_eq!(json["deleted_id"], comment.id.to_string());

    // Verify comment is soft-deleted
    let deleted_comment = repo.find_by_id(comment.id).await.unwrap();
    assert!(deleted_comment.is_none()); // Should not be returned after soft delete
}
```

**Teaching Point:** These tests verify:
- ‚úÖ Comment CRUD operations work correctly
- ‚úÖ Work item existence is validated
- ‚úÖ Empty lists return empty arrays
- ‚úÖ Not found returns 404
- ‚úÖ Soft delete works (comment not returned after deletion)

**Verification:** `cargo test -p pm-server api_comments_tests`

---

## Session 100.2 Completion Checklist

After completing all steps:

- [ ] `cargo check -p pm-server` passes
- [ ] `cargo test -p pm-server` passes (including integration tests)
- [ ] `cargo clippy -p pm-server` passes
- [ ] Server starts: `cargo run -p pm-server`
- [ ] Can test endpoints: `curl http://localhost:8080/api/v1/projects`
- [ ] CORS restrictive mode works: `PM_API_RESTRICT_CORS=true cargo run -p pm-server`

### Files Created (7)
- `pm-server/src/api/work_items.rs`
- `pm-server/src/api/projects.rs`
- `pm-server/src/api/comments.rs`
- `pm-server/tests/common/mod.rs` (test infrastructure)
- `pm-server/tests/api_work_items_tests.rs`
- `pm-server/tests/api_projects_tests.rs`
- `pm-server/tests/api_comments_tests.rs`

### Files Modified (3)
- `pm-server/src/api/mod.rs`
- `pm-server/src/routes.rs` (with configurable CORS)
- `pm-server/src/main.rs`

---

## Next Session

**Session 100.3** will implement:
- pm-cli crate setup (Cargo.toml)
- CLI entry point with clap commands
- HTTP client wrapper
- Justfile commands for building and running CLI

---

## Key Takeaways

1. **Broadcast After Every Mutation** - This is what makes the system real-time
2. **Reuse Validation Logic** - `MessageValidator` from pm-ws ensures consistency
3. **Optimistic Locking** - `expected_version` prevents lost updates
4. **Transaction Atomicity** - Multiple DB operations in a single transaction
5. **Error Consistency** - All handlers return `ApiError` for uniform JSON responses

---

## üîë Critical Patterns Learned (For Next Session)

### Repository Patterns (Inconsistent!)
```rust
// ‚úÖ WorkItemRepository - Static functions with executor parameter
WorkItemRepository::find_by_id(&state.pool, id).await?
WorkItemRepository::create(&mut *tx, &work_item).await?

// ‚úÖ ProjectRepository - Instance methods with owned pool
let repo = ProjectRepository::new(state.pool.clone());
let project = repo.find_by_id(id).await?

// ‚úÖ Transaction-only functions - Static with &mut Transaction
ProjectRepository::get_and_increment_work_item_number(&mut tx, project_id).await?
```

### ApiError Construction
```rust
// ‚úÖ CORRECT - Struct variants with named fields
ApiError::NotFound {
    message: format!("Resource {} not found", id),
    location: ErrorLocation::from(Location::caller()),
}

ApiError::Validation {
    message: "Invalid input".into(),
    field: Some("title".into()),
    location: ErrorLocation::from(Location::caller()),
}

// ‚ùå WRONG - Tuple-style construction (doesn't compile)
ApiError::NotFound(format!("Not found"))
```

### Required Imports
```rust
use std::panic::Location;
use error_location::ErrorLocation;
use axum::extract::ws::Message;  // For WebSocket broadcasts
use prost::Message as ProstMessage;  // For protobuf encoding
```

### WebSocket Broadcast Pattern (Copy-paste this!)
```rust
// After every mutation (create/update/delete):
let event = build_activity_log_created_event(&activity);
let bytes = event.encode_to_vec();
let message = Message::Binary(bytes.into());
if let Err(e) = state.registry.broadcast_activity_log_created(
    &project_id.to_string(),
    Some(&entity_id.to_string()),
    None,
    message,
).await {
    log::warn!("Failed to broadcast to WebSocket clients: {}", e);
    // This is OK - database succeeded, UI will refresh
}
```
