# Session 100.3: CLI Implementation ✅

**Parent Plan**: `100-Session-Plan.md`
**Prerequisite**: Sessions 100.1 and 100.2 completed
**Target**: ~40k tokens
**Status**: ✅ Complete (2026-02-05)

---

## Scope

This session implements the command-line interface for LLM integration:

1. **pm-cli Crate Setup** - Cargo.toml with dependencies
2. **CLI Entry Point** - Main with clap argument parsing
3. **HTTP Client** - Wrapper for REST API calls
4. **Justfile Commands** - Build and run commands

---

## Prerequisites Check

Before starting, verify Sessions 100.1 and 100.2 are complete:

```bash
# Server should start
cargo run -p pm-server &

# API endpoints should respond
curl http://localhost:8080/api/v1/projects
```

---

## Implementation Order

### Step 1: Create pm-cli Crate Structure

First, create the directory and Cargo.toml.

**File:** `backend/crates/pm-cli/Cargo.toml` (NEW)

```toml
[package]
name = "pm-cli"
version = "0.1.0"
edition = "2024"
description = "CLI for Blazor Agile Board - LLM integration"
authors = ["Your Name"]

[[bin]]
name = "pm"
path = "src/main.rs"

[dependencies]
clap = { workspace = true }
reqwest = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
tokio = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
wiremock = { workspace = true }
```

**Note:** Also add to root `Cargo.toml` under `[workspace.dependencies]`:
```toml
wiremock = "0.6"
```

**Verification:** `cargo check -p pm-cli` (will fail until we add source files)

**Teaching Point:** We use the workspace dependency system - all version numbers are defined in the root `Cargo.toml`. The crate just references them with `{ workspace = true }`.

---

### Step 2: Create HTTP Client

**File:** `backend/crates/pm-cli/src/client.rs` (NEW)

```rust
//! HTTP client wrapper for REST API calls
//!
//! This module provides a clean interface for calling the pm-server REST API.
//! All responses are returned as `serde_json::Value` for easy printing.

use reqwest::{Client, Method};
use serde::Serialize;
use serde_json::Value;
use thiserror::Error;

/// Errors that can occur during API calls
#[derive(Error, Debug)]
pub enum ClientError {
    #[error("HTTP request failed: {0}")]
    Http(#[from] reqwest::Error),

    #[error("API error: {message} (code: {code})")]
    Api { code: String, message: String },

    #[error("Failed to parse response: {0}")]
    Parse(String),
}

/// HTTP client for the pm-server REST API
pub struct PmClient {
    base_url: String,
    user_id: Option<String>,
    client: Client,
}

impl PmClient {
    /// Create a new client
    ///
    /// # Arguments
    /// * `base_url` - Server URL (e.g., "http://127.0.0.1:8080")
    /// * `user_id` - Optional user ID to include in X-User-Id header
    pub fn new(base_url: &str, user_id: Option<&str>) -> Self {
        Self {
            base_url: base_url.trim_end_matches('/').to_string(),
            user_id: user_id.map(String::from),
            client: Client::new(),
        }
    }

    /// Build a request with optional user ID header
    fn request(&self, method: Method, path: &str) -> reqwest::RequestBuilder {
        let url = format!("{}{}", self.base_url, path);
        let mut req = self.client.request(method, &url);

        if let Some(ref user_id) = self.user_id {
            req = req.header("X-User-Id", user_id);
        }

        req
    }

    /// Execute request and handle errors
    async fn execute(&self, req: reqwest::RequestBuilder) -> Result<Value, ClientError> {
        let response = req.send().await?;
        let status = response.status();
        let body: Value = response.json().await?;

        // Check for error response
        if !status.is_success() {
            if let Some(error) = body.get("error") {
                let code = error.get("code")
                    .and_then(|v| v.as_str())
                    .unwrap_or("UNKNOWN")
                    .to_string();
                let message = error.get("message")
                    .and_then(|v| v.as_str())
                    .unwrap_or("Unknown error")
                    .to_string();
                return Err(ClientError::Api { code, message });
            }
        }

        Ok(body)
    }

    // =========================================================================
    // Project Operations
    // =========================================================================

    /// List all projects
    pub async fn list_projects(&self) -> Result<Value, ClientError> {
        let req = self.request(Method::GET, "/api/v1/projects");
        self.execute(req).await
    }

    /// Get a project by ID
    pub async fn get_project(&self, id: &str) -> Result<Value, ClientError> {
        let req = self.request(Method::GET, &format!("/api/v1/projects/{}", id));
        self.execute(req).await
    }

    // =========================================================================
    // Work Item Operations
    // =========================================================================

    /// Get a work item by ID
    pub async fn get_work_item(&self, id: &str) -> Result<Value, ClientError> {
        let req = self.request(Method::GET, &format!("/api/v1/work-items/{}", id));
        self.execute(req).await
    }

    /// List work items in a project
    pub async fn list_work_items(
        &self,
        project_id: &str,
        item_type: Option<&str>,
        status: Option<&str>,
    ) -> Result<Value, ClientError> {
        let mut url = format!("/api/v1/projects/{}/work-items", project_id);

        // Build query string
        let mut params = vec![];
        if let Some(t) = item_type {
            params.push(format!("type={}", t));
        }
        if let Some(s) = status {
            params.push(format!("status={}", s));
        }
        if !params.is_empty() {
            url.push_str(&format!("?{}", params.join("&")));
        }

        let req = self.request(Method::GET, &url);
        self.execute(req).await
    }

    /// Create a new work item
    pub async fn create_work_item(
        &self,
        project_id: &str,
        item_type: &str,
        title: &str,
        description: Option<&str>,
        parent_id: Option<&str>,
        status: Option<&str>,
        priority: Option<&str>,
    ) -> Result<Value, ClientError> {
        #[derive(Serialize)]
        struct CreateRequest<'a> {
            project_id: &'a str,
            item_type: &'a str,
            title: &'a str,
            #[serde(skip_serializing_if = "Option::is_none")]
            description: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            parent_id: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            status: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            priority: Option<&'a str>,
        }

        let body = CreateRequest {
            project_id,
            item_type,
            title,
            description,
            parent_id,
            status,
            priority,
        };

        let req = self.request(Method::POST, "/api/v1/work-items")
            .json(&body);
        self.execute(req).await
    }

    /// Update a work item
    pub async fn update_work_item(
        &self,
        id: &str,
        title: Option<&str>,
        description: Option<&str>,
        status: Option<&str>,
        priority: Option<&str>,
        assignee_id: Option<&str>,
        sprint_id: Option<&str>,
        story_points: Option<i32>,
        expected_version: i32,
    ) -> Result<Value, ClientError> {
        #[derive(Serialize)]
        struct UpdateRequest<'a> {
            #[serde(skip_serializing_if = "Option::is_none")]
            title: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            description: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            status: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            priority: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            assignee_id: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            sprint_id: Option<&'a str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            story_points: Option<i32>,
            expected_version: i32,
        }

        let body = UpdateRequest {
            title,
            description,
            status,
            priority,
            assignee_id,
            sprint_id,
            story_points,
            expected_version,
        };

        let req = self.request(Method::PUT, &format!("/api/v1/work-items/{}", id))
            .json(&body);
        self.execute(req).await
    }

    /// Delete a work item
    pub async fn delete_work_item(&self, id: &str) -> Result<Value, ClientError> {
        let req = self.request(Method::DELETE, &format!("/api/v1/work-items/{}", id));
        self.execute(req).await
    }

    // =========================================================================
    // Comment Operations
    // =========================================================================

    /// List comments on a work item
    pub async fn list_comments(&self, work_item_id: &str) -> Result<Value, ClientError> {
        let req = self.request(
            Method::GET,
            &format!("/api/v1/work-items/{}/comments", work_item_id),
        );
        self.execute(req).await
    }

    /// Create a comment on a work item
    pub async fn create_comment(
        &self,
        work_item_id: &str,
        content: &str,
    ) -> Result<Value, ClientError> {
        #[derive(Serialize)]
        struct CreateCommentRequest<'a> {
            content: &'a str,
        }

        let body = CreateCommentRequest { content };
        let req = self.request(
            Method::POST,
            &format!("/api/v1/work-items/{}/comments", work_item_id),
        )
        .json(&body);
        self.execute(req).await
    }

    /// Update a comment
    pub async fn update_comment(
        &self,
        id: &str,
        content: &str,
    ) -> Result<Value, ClientError> {
        #[derive(Serialize)]
        struct UpdateCommentRequest<'a> {
            content: &'a str,
        }

        let body = UpdateCommentRequest { content };
        let req = self.request(Method::PUT, &format!("/api/v1/comments/{}", id))
            .json(&body);
        self.execute(req).await
    }

    /// Delete a comment
    pub async fn delete_comment(&self, id: &str) -> Result<Value, ClientError> {
        let req = self.request(Method::DELETE, &format!("/api/v1/comments/{}", id));
        self.execute(req).await
    }
}
```

**Teaching Point:** The client returns `serde_json::Value` rather than typed responses. This keeps the client simple and allows easy JSON printing. For production use, you might want strongly-typed response structs.

---

### Step 3: Create CLI Entry Point

**File:** `backend/crates/pm-cli/src/main.rs` (NEW)

```rust
//! pm - Blazor Agile Board CLI
//!
//! A command-line interface for managing work items, designed for LLM integration.
//!
//! # Examples
//!
//! ```bash
//! # List all projects
//! pm project list --pretty
//!
//! # Create a work item
//! pm work-item create --project-id <uuid> --type story --title "My task"
//!
//! # Update status
//! pm work-item update <id> --status done --version 1
//! ```

use clap::{Parser, Subcommand};
use std::process::ExitCode;

mod client;
use client::PmClient;

// =============================================================================
// CLI Structure
// =============================================================================

#[derive(Parser)]
#[command(name = "pm")]
#[command(about = "Blazor Agile Board CLI for LLM integration")]
#[command(version)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Server URL
    #[arg(long, default_value = "http://127.0.0.1:8080", global = true, env = "PM_SERVER_URL")]
    server: String,

    /// User ID to use for operations (optional, uses LLM user by default)
    #[arg(long, global = true, env = "PM_USER_ID")]
    user_id: Option<String>,

    /// Pretty-print JSON output
    #[arg(long, global = true)]
    pretty: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Project operations
    Project {
        #[command(subcommand)]
        action: ProjectCommands,
    },
    /// Work item operations
    WorkItem {
        #[command(subcommand)]
        action: WorkItemCommands,
    },
    /// Comment operations
    Comment {
        #[command(subcommand)]
        action: CommentCommands,
    },
}

// =============================================================================
// Project Commands
// =============================================================================

#[derive(Subcommand)]
enum ProjectCommands {
    /// List all projects
    List,
    /// Get a project by ID
    Get {
        /// Project ID (UUID)
        id: String,
    },
}

// =============================================================================
// Work Item Commands
// =============================================================================

#[derive(Subcommand)]
enum WorkItemCommands {
    /// Create a new work item
    Create {
        /// Project ID (UUID)
        #[arg(long)]
        project_id: String,

        /// Item type: epic, story, or task
        #[arg(long, value_parser = ["epic", "story", "task"])]
        r#type: String,

        /// Work item title
        #[arg(long)]
        title: String,

        /// Work item description
        #[arg(long)]
        description: Option<String>,

        /// Parent work item ID (UUID)
        #[arg(long)]
        parent_id: Option<String>,

        /// Initial status (default: backlog)
        #[arg(long)]
        status: Option<String>,

        /// Priority: low, medium, high, critical (default: medium)
        #[arg(long)]
        priority: Option<String>,
    },

    /// Get a work item by ID
    Get {
        /// Work item ID (UUID)
        id: String,
    },

    /// List work items in a project
    List {
        /// Project ID (UUID)
        project_id: String,

        /// Filter by type: epic, story, or task
        #[arg(long, value_parser = ["epic", "story", "task"])]
        r#type: Option<String>,

        /// Filter by status
        #[arg(long)]
        status: Option<String>,
    },

    /// Update a work item
    Update {
        /// Work item ID (UUID)
        id: String,

        /// New title
        #[arg(long)]
        title: Option<String>,

        /// New description
        #[arg(long)]
        description: Option<String>,

        /// New status: backlog, todo, in_progress, review, done, blocked
        #[arg(long)]
        status: Option<String>,

        /// New priority: low, medium, high, critical
        #[arg(long)]
        priority: Option<String>,

        /// Assignee user ID (UUID, or empty to unassign)
        #[arg(long)]
        assignee_id: Option<String>,

        /// Sprint ID (UUID, or empty to remove from sprint)
        #[arg(long)]
        sprint_id: Option<String>,

        /// Story points (0-100)
        #[arg(long)]
        story_points: Option<i32>,

        /// Expected version (required for optimistic locking)
        #[arg(long)]
        version: i32,
    },

    /// Delete a work item
    Delete {
        /// Work item ID (UUID)
        id: String,
    },
}

// =============================================================================
// Comment Commands
// =============================================================================

#[derive(Subcommand)]
enum CommentCommands {
    /// List comments on a work item
    List {
        /// Work item ID (UUID)
        work_item_id: String,
    },

    /// Create a comment on a work item
    Create {
        /// Work item ID (UUID)
        #[arg(long)]
        work_item_id: String,

        /// Comment content
        #[arg(long)]
        content: String,
    },

    /// Update a comment
    Update {
        /// Comment ID (UUID)
        id: String,

        /// New content
        #[arg(long)]
        content: String,
    },

    /// Delete a comment
    Delete {
        /// Comment ID (UUID)
        id: String,
    },
}

// =============================================================================
// Main
// =============================================================================

#[tokio::main]
async fn main() -> ExitCode {
    let cli = Cli::parse();
    let client = PmClient::new(&cli.server, cli.user_id.as_deref());

    let result = match cli.command {
        // Project commands
        Commands::Project { action } => match action {
            ProjectCommands::List => client.list_projects().await,
            ProjectCommands::Get { id } => client.get_project(&id).await,
        },

        // Work item commands
        Commands::WorkItem { action } => match action {
            WorkItemCommands::Create {
                project_id,
                r#type,
                title,
                description,
                parent_id,
                status,
                priority,
            } => {
                client.create_work_item(
                    &project_id,
                    &r#type,
                    &title,
                    description.as_deref(),
                    parent_id.as_deref(),
                    status.as_deref(),
                    priority.as_deref(),
                ).await
            }
            WorkItemCommands::Get { id } => client.get_work_item(&id).await,
            WorkItemCommands::List { project_id, r#type, status } => {
                client.list_work_items(&project_id, r#type.as_deref(), status.as_deref()).await
            }
            WorkItemCommands::Update {
                id,
                title,
                description,
                status,
                priority,
                assignee_id,
                sprint_id,
                story_points,
                version,
            } => {
                client.update_work_item(
                    &id,
                    title.as_deref(),
                    description.as_deref(),
                    status.as_deref(),
                    priority.as_deref(),
                    assignee_id.as_deref(),
                    sprint_id.as_deref(),
                    story_points,
                    version,
                ).await
            }
            WorkItemCommands::Delete { id } => client.delete_work_item(&id).await,
        },

        // Comment commands
        Commands::Comment { action } => match action {
            CommentCommands::List { work_item_id } => {
                client.list_comments(&work_item_id).await
            }
            CommentCommands::Create { work_item_id, content } => {
                client.create_comment(&work_item_id, &content).await
            }
            CommentCommands::Update { id, content } => {
                client.update_comment(&id, &content).await
            }
            CommentCommands::Delete { id } => client.delete_comment(&id).await,
        },
    };

    // Handle result
    match result {
        Ok(value) => {
            let output = if cli.pretty {
                serde_json::to_string_pretty(&value)
            } else {
                serde_json::to_string(&value)
            };

            match output {
                Ok(json) => {
                    println!("{}", json);
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("Error serializing response: {}", e);
                    ExitCode::FAILURE
                }
            }
        }
        Err(e) => {
            eprintln!("Error: {}", e);
            ExitCode::FAILURE
        }
    }
}
```

**Teaching Point:** Clap's derive macros make CLI argument parsing type-safe and self-documenting. The `#[arg]` attributes generate help text automatically. Environment variables (`env = "PM_SERVER_URL"`) provide configuration fallbacks.

---

### Step 4: Add Justfile Commands

**File:** `justfile` (MODIFY)

Add these commands in the "Rust Backend" section:

```just
# =============================================================================
# CLI Package
# =============================================================================

rust_cli := "pm-cli"

# Build CLI (debug)
build-rs-cli:
    cargo build -p {{rust_cli}}

# Build CLI (release)
build-rs-cli-release:
    cargo build -p {{rust_cli}} --release

# Run CLI with arguments
run-cli *ARGS:
    cargo run -p {{rust_cli}} -- {{ARGS}}

# Test CLI
test-rs-cli:
    cargo test -p {{rust_cli}}

# Check CLI
check-rs-cli:
    cargo check -p {{rust_cli}} {{cargo_all_targets}}

# Clippy CLI
clippy-rs-cli:
    cargo clippy -p {{rust_cli}} {{cargo_all_targets}} {{cargo_all_features}} -- -D warnings

# Watch CLI (rebuild on changes)
watch-rs-cli:
    cargo watch -p {{rust_cli}} -x check
```

**Verification:** `just build-rs-cli`

---

### Step 5: Create Client Unit Tests

**File:** `backend/crates/pm-cli/src/client.rs` (MODIFY - add tests at bottom)

Add `#[cfg(test)]` module at the end of the file:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_base_url_trailing_slash_trimmed() {
        let client = PmClient::new("http://localhost:8080/", None);
        assert_eq!(client.base_url, "http://localhost:8080");
    }

    #[test]
    fn test_base_url_no_trailing_slash() {
        let client = PmClient::new("http://localhost:8080", None);
        assert_eq!(client.base_url, "http://localhost:8080");
    }

    #[test]
    fn test_user_id_stored() {
        let client = PmClient::new("http://localhost:8080", Some("user-123"));
        assert_eq!(client.user_id, Some("user-123".to_string()));
    }

    #[test]
    fn test_user_id_none() {
        let client = PmClient::new("http://localhost:8080", None);
        assert!(client.user_id.is_none());
    }

    #[test]
    fn test_query_string_empty_params() {
        // Test that list_work_items builds correct URL with no filters
        let client = PmClient::new("http://localhost:8080", None);
        let req = client.request(Method::GET, "/api/v1/projects/abc/work-items");
        // Note: Can't easily inspect URL without sending, but this verifies no panic
        assert!(req.build().is_ok());
    }
}
```

**Verification:** `cargo test -p pm-cli client::tests`

---

### Step 6: Create CLI Integration Tests

**File:** `backend/crates/pm-cli/tests/cli_integration_tests.rs` (NEW)

**IMPORTANT:** First, make PmClient public in `backend/crates/pm-cli/src/client.rs`:
```rust
// Change from:
// pub(crate) struct PmClient
// To:
pub struct PmClient
```

```rust
//! Integration tests for the CLI using wiremock mock server

use wiremock::{
    Mock, MockServer, ResponseTemplate,
    matchers::{method, path, header, body_string_contains},
};
use serde_json::json;

// Import the client
use pm_cli::client::{PmClient, ClientError};

#[tokio::test]
async fn test_list_projects_success() {
    let mock_server = MockServer::start().await;

    Mock::given(method("GET"))
        .and(path("/api/v1/projects"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({
                "projects": [
                    {
                        "id": "00000000-0000-0000-0000-000000000001",
                        "key": "TEST",
                        "title": "Test Project",
                        "description": "A test project",
                        "created_at": 1704067200,
                        "updated_at": 1704067200
                    }
                ]
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.list_projects().await.unwrap();

    assert!(result["projects"].is_array());
    let projects = result["projects"].as_array().unwrap();
    assert_eq!(projects.len(), 1);
    assert_eq!(projects[0]["key"], "TEST");
    assert_eq!(projects[0]["title"], "Test Project");
}

#[tokio::test]
async fn test_get_project_not_found() {
    let mock_server = MockServer::start().await;

    Mock::given(method("GET"))
        .and(path("/api/v1/projects/00000000-0000-0000-0000-000000000001"))
        .respond_with(ResponseTemplate::new(404)
            .set_body_json(json!({
                "error": {
                    "code": "NOT_FOUND",
                    "message": "Project not found"
                }
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.get_project("00000000-0000-0000-0000-000000000001").await;

    match result {
        Err(ClientError::Api { code, message }) => {
            assert_eq!(code, "NOT_FOUND");
            assert!(message.contains("Project not found"));
        }
        _ => panic!("Expected Api error with NOT_FOUND code"),
    }
}

#[tokio::test]
async fn test_create_work_item_success() {
    let mock_server = MockServer::start().await;

    Mock::given(method("POST"))
        .and(path("/api/v1/work-items"))
        .and(body_string_contains("Test Task"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({
                "work_item": {
                    "id": "00000000-0000-0000-0000-000000000002",
                    "display_key": "TEST-1",
                    "item_type": "task",
                    "title": "Test Task",
                    "description": null,
                    "status": "backlog",
                    "priority": "medium",
                    "parent_id": null,
                    "project_id": "00000000-0000-0000-0000-000000000001",
                    "assignee_id": null,
                    "sprint_id": null,
                    "story_points": null,
                    "item_number": 1,
                    "position": 1,
                    "version": 1,
                    "created_at": 1704067200,
                    "updated_at": 1704067200,
                    "created_by": "00000000-0000-0000-0000-000000000001",
                    "updated_by": "00000000-0000-0000-0000-000000000001"
                }
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.create_work_item(
        "00000000-0000-0000-0000-000000000001",
        "task",
        "Test Task",
        None,
        None,
        None,
        None,
    ).await.unwrap();

    assert_eq!(result["work_item"]["title"], "Test Task");
    assert_eq!(result["work_item"]["item_type"], "task");
    assert_eq!(result["work_item"]["version"], 1);
}

#[tokio::test]
async fn test_create_work_item_validation_error() {
    let mock_server = MockServer::start().await;

    Mock::given(method("POST"))
        .and(path("/api/v1/work-items"))
        .respond_with(ResponseTemplate::new(400)
            .set_body_json(json!({
                "error": {
                    "code": "VALIDATION_ERROR",
                    "message": "Title is required",
                    "field": "title"
                }
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.create_work_item(
        "00000000-0000-0000-0000-000000000001",
        "task",
        "",
        None,
        None,
        None,
        None,
    ).await;

    match result {
        Err(ClientError::Api { code, message }) => {
            assert_eq!(code, "VALIDATION_ERROR");
            assert!(message.contains("Title"));
        }
        _ => panic!("Expected Api error with VALIDATION_ERROR"),
    }
}

#[tokio::test]
async fn test_update_work_item_conflict() {
    let mock_server = MockServer::start().await;

    Mock::given(method("PUT"))
        .and(path("/api/v1/work-items/00000000-0000-0000-0000-000000000001"))
        .respond_with(ResponseTemplate::new(409)
            .set_body_json(json!({
                "error": {
                    "code": "CONFLICT",
                    "message": "Version mismatch (current version: 5)"
                }
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.update_work_item(
        "00000000-0000-0000-0000-000000000001",
        Some("Updated"),
        None,
        None,
        None,
        None,
        None,
        None,
        999,
    ).await;

    match result {
        Err(ClientError::Api { code, message }) => {
            assert_eq!(code, "CONFLICT");
            assert!(message.contains("5"));
        }
        _ => panic!("Expected Api error with CONFLICT code"),
    }
}

#[tokio::test]
async fn test_list_work_items_with_filters() {
    let mock_server = MockServer::start().await;

    Mock::given(method("GET"))
        .and(path("/api/v1/projects/00000000-0000-0000-0000-000000000001/work-items"))
        .and(wiremock::matchers::query_param("type", "task"))
        .and(wiremock::matchers::query_param("status", "in_progress"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({
                "work_items": []
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.list_work_items(
        "00000000-0000-0000-0000-000000000001",
        Some("task"),
        Some("in_progress"),
    ).await.unwrap();

    assert!(result["work_items"].is_array());
}

#[tokio::test]
async fn test_user_id_header_sent() {
    let mock_server = MockServer::start().await;

    Mock::given(method("GET"))
        .and(path("/api/v1/projects"))
        .and(header("X-User-Id", "user-123"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({"projects": []})))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), Some("user-123"));
    let result = client.list_projects().await;

    assert!(result.is_ok());
    // If header wasn't sent, mock would reject the request
}

#[tokio::test]
async fn test_user_id_header_not_sent_when_none() {
    let mock_server = MockServer::start().await;

    // This mock ONLY matches if X-User-Id header is NOT present
    Mock::given(method("GET"))
        .and(path("/api/v1/projects"))
        .and(wiremock::matchers::header_exists("X-User-Id").not())
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({"projects": []})))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.list_projects().await;

    assert!(result.is_ok());
}

#[tokio::test]
async fn test_delete_work_item() {
    let mock_server = MockServer::start().await;

    Mock::given(method("DELETE"))
        .and(path("/api/v1/work-items/00000000-0000-0000-0000-000000000001"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({
                "deleted_id": "00000000-0000-0000-0000-000000000001"
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.delete_work_item("00000000-0000-0000-0000-000000000001").await.unwrap();

    assert_eq!(result["deleted_id"], "00000000-0000-0000-0000-000000000001");
}

#[tokio::test]
async fn test_create_comment() {
    let mock_server = MockServer::start().await;

    Mock::given(method("POST"))
        .and(path("/api/v1/work-items/00000000-0000-0000-0000-000000000001/comments"))
        .and(body_string_contains("Test comment"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({
                "comment": {
                    "id": "00000000-0000-0000-0000-000000000002",
                    "work_item_id": "00000000-0000-0000-0000-000000000001",
                    "content": "Test comment",
                    "created_at": 1704067200,
                    "updated_at": 1704067200,
                    "created_by": "00000000-0000-0000-0000-000000000003",
                    "updated_by": "00000000-0000-0000-0000-000000000003"
                }
            })))
        .mount(&mock_server)
        .await;

    let client = PmClient::new(&mock_server.uri(), None);
    let result = client.create_comment(
        "00000000-0000-0000-0000-000000000001",
        "Test comment",
    ).await.unwrap();

    assert_eq!(result["comment"]["content"], "Test comment");
}

#[tokio::test]
async fn test_http_request_error() {
    // Use an invalid URL that will fail to connect
    let client = PmClient::new("http://localhost:99999", None);
    let result = client.list_projects().await;

    match result {
        Err(ClientError::Http(_)) => {
            // Expected - connection failed
        }
        _ => panic!("Expected Http error for connection failure"),
    }
}
```

**Teaching Point:** These tests verify:
- ✅ Success responses are parsed correctly
- ✅ Error responses are converted to ClientError::Api
- ✅ HTTP errors are converted to ClientError::Http
- ✅ Query parameters are built correctly
- ✅ X-User-Id header is sent when provided
- ✅ X-User-Id header is NOT sent when None
- ✅ All HTTP methods work (GET/POST/PUT/DELETE)
- ✅ Request body serialization works

**Verification:** `cargo test -p pm-cli cli_integration_tests`

---

## Session 100.3 Completion Checklist ✅

After completing all steps:

- [x] `cargo check -p pm-cli` passes
- [x] `cargo build -p pm-cli` succeeds
- [x] `cargo test -p pm-cli` passes (12 tests: 4 unit + 8 integration)
- [x] `just build-rs-cli` works
- [x] `./target/debug/pm --help` shows help
- [x] `./target/debug/pm project list` returns JSON (with server running)

### Files Created (15 - Refactored into modules)
- `backend/crates/pm-cli/Cargo.toml` (with wiremock dev-dependency, pm-config dependency)
- `backend/crates/pm-cli/src/lib.rs` (library entry point for integration tests)
- `backend/crates/pm-cli/src/main.rs` (CLI orchestration)
- `backend/crates/pm-cli/src/cli.rs` (CLI struct definition)
- `backend/crates/pm-cli/src/commands.rs` (Commands enum)
- `backend/crates/pm-cli/src/project_commands.rs` (Project command definitions)
- `backend/crates/pm-cli/src/work_item_commands.rs` (Work item command definitions)
- `backend/crates/pm-cli/src/comment_commands.rs` (Comment command definitions)
- `backend/crates/pm-cli/src/client/mod.rs` (Client module exports)
- `backend/crates/pm-cli/src/client/client.rs` (HTTP client with 4 unit tests)
- `backend/crates/pm-cli/src/client/error.rs` (Error types with ErrorLocation on all variants)
- `backend/crates/pm-cli/tests/client_integration_tests.rs` (8 integration tests with wiremock)

### Files Modified (2)
- `Cargo.toml` (root) - Added wiremock 0.6.5 to workspace.dependencies, added pm-cli to workspace members
- `justfile` - Added 8 CLI commands (build, test, check, clippy, watch, run)

### Key Improvements Over Plan
1. **Better Error Handling** - ErrorLocation on ALL error variants (not just Generic)
2. **Config Integration** - Uses `pm_config::{DEFAULT_HOST, DEFAULT_PORT}` instead of hardcoded URL
3. **Modular Structure** - Split into separate command modules for maintainability
4. **Library Support** - Added lib.rs for proper integration test support

---

## Final Verification

With all three sessions complete, run the full verification:

```bash
# 1. Build everything
just check-backend
just build-rs-cli

# 2. Start the server (in one terminal)
cargo run -p pm-server

# 3. Start Blazor (in another terminal)
just dev

# 4. Test CLI commands (in a third terminal)
# List projects
./target/debug/pm project list --pretty

# Get a project ID from the output, then create a work item
./target/debug/pm work-item create \
  --project-id <uuid-from-above> \
  --type task \
  --title "Test from CLI" \
  --pretty

# Verify it appears in the Blazor UI instantly!

# List work items
./target/debug/pm work-item list <project-id> --pretty

# Update the work item (use the ID and version from create response)
./target/debug/pm work-item update <work-item-id> \
  --status in_progress \
  --version 1 \
  --pretty

# Add a comment
./target/debug/pm comment create \
  --work-item-id <work-item-id> \
  --content "Added via CLI" \
  --pretty

# Delete the work item
./target/debug/pm work-item delete <work-item-id> --pretty
```

---

## Session 100 Complete

With all three sub-sessions complete, you have:

1. **API Foundation** (100.1)
   - LLM user configuration
   - REST API error types with HTTP status codes
   - Axum extractors for user authentication
   - AppState extended with api_config

2. **REST API Handlers** (100.2)
   - Full CRUD for work items with WebSocket broadcast
   - Project list/get endpoints
   - Comment CRUD endpoints
   - RESTful route registration
   - LLM user initialization

3. **CLI Implementation** (100.3)
   - Type-safe CLI with clap derive macros
   - HTTP client wrapper
   - JSON output for LLM parsing
   - Build commands in justfile

---

## Key Takeaways from Session 100

1. **REST + WebSocket = Real-time CLI**
   - REST endpoints call the same broadcast code as WebSocket handlers
   - CLI changes appear instantly in Blazor UI

2. **Extractors Simplify Auth**
   - Axum extractors run before handlers
   - UserId falls back to LLM user when no header provided

3. **Optimistic Locking Prevents Lost Updates**
   - `expected_version` catches concurrent modifications
   - 409 Conflict response tells the client what happened

4. **Clap Derive = Self-Documenting CLI**
   - Types enforce valid arguments
   - Help text generated from attributes
   - Environment variables for configuration

5. **JSON Output for LLM Integration**
   - Consistent JSON format for all responses
   - Error responses include code and message
   - `--pretty` flag for human readability
