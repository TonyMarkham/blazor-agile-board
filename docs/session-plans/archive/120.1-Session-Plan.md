# Session 120.1: Port File Module & Config Changes ✅ COMPLETE

**Parent Plan**: `120-Session-Plan.md`
**Target**: ~25-35k tokens (actual: ~30k)
**Prerequisites**: ✅ `just check-backend` passed, ✅ `just test-backend` passed
**Status**: ✅ COMPLETE - All deliverables implemented and verified

---

## Scope

This session adds the port file discovery infrastructure to `pm-config`:

1. **Dependencies** - Add `serde_json`, `chrono`, `libc` to pm-config
2. **Port File Module** - Write, read, validate, remove port discovery files
3. **Config Changes** - Change DEFAULT_PORT to 0, allow port 0 in validation
4. **Tests** - Port file operations + port 0 validation + edge cases

---

## Config Directory Location

The port file is written to `<config_dir>/server.json` where `<config_dir>` is determined by `Config::config_dir()` (`pm-config/src/config.rs:80-90`):

1. `PM_CONFIG_DIR` environment variable if set
2. Otherwise: `<current_working_directory>/.pm/`

**Default location**: `.pm/server.json`

The `.server/` directory in the repo root is a **separate concern** — it holds the `config.toml` working copy. `Config::config_dir()` returns `.pm/`, not `.server/`.

---

## Teaching Notes

### What is port 0?

When you bind a TCP socket to port `0`, the operating system automatically assigns an available ephemeral port (typically in the 49152-65535 range). After binding, you call `listener.local_addr()` to find out which port was assigned. This is the standard way to avoid port conflicts when running multiple server instances.

### What is a port file?

A port file is a simple JSON file that a server writes after binding to a port. Other programs (like the CLI) read this file to discover the server's address. If the server crashes without cleaning up, the CLI checks if the PID in the file is still alive - if not, it removes the stale file.

### Why does this live in pm-config?

Both `pm-server` (writes the file) and `pm-cli` (reads the file) need this code. Since both already depend on `pm-config` for configuration, it's the natural shared location. It also reuses `Config::config_dir()` for the file path.

### Cross-platform PID checking

- **Unix (macOS/Linux)**: `kill(pid, 0)` via `libc` — probes process existence without sending a signal. Returns 0 if the process exists, -1 if not.
- **Windows**: `OpenProcess` + `GetExitCodeProcess` via raw FFI (`extern "system"`). Opens a handle to the process, checks if exit code is `STILL_ACTIVE` (259), then closes the handle. No extra crate needed — these are direct Windows API calls.
- **Other** (WASM, exotic): Fallback to assuming alive. The CLI will get a connection error if wrong.

---

## Implementation Order

### Step 1: Add Dependencies to pm-config

**File**: `backend/crates/pm-config/Cargo.toml`

These three crates are already in `[workspace.dependencies]` in the root `Cargo.toml`. We just need to reference them in pm-config.

Add to `[dependencies]`:
```toml
chrono = { workspace = true }
libc = { workspace = true }
serde_json = { workspace = true }
```

The full `[dependencies]` section becomes:
```toml
[dependencies]
chrono = { workspace = true }
dirs = { workspace = true }
error-location = { workspace = true }
libc = { workspace = true }
log = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
toml = { workspace = true }
uuid = { workspace = true }
```

**Verification**: `just check-rs-config`

---

### Step 2: Create Port File Module

**Create**: `backend/crates/pm-config/src/port_file.rs`

This module handles writing, reading, validating, and removing the port discovery file.

```rust
//! Port discovery file for multi-instance support.
//!
//! The server writes this file after binding to a port.
//! The CLI reads it to discover the server URL without manual --server flags.
//!
//! File location: `<config_dir>/server.json`
//!
//! ## Stale file detection
//!
//! If the server crashes without cleanup, the file remains. `read_live()`
//! checks whether the PID in the file is still running. If not, it removes
//! the stale file and returns `None`.
//!
//! ## Race condition protection
//!
//! `write()` checks for an existing live server before writing. If another
//! server is already running (same config directory), `write()` returns an
//! error instead of silently overwriting.

use crate::{Config, ConfigError, ConfigErrorResult};

use serde::{Deserialize, Serialize};

use std::path::PathBuf;

const PORT_FILENAME: &str = "server.json";

/// Information stored in the port discovery file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortFileInfo {
    /// Process ID of the server that wrote this file
    pub pid: u32,
    /// Port the server is listening on
    pub port: u16,
    /// Host the server is bound to
    pub host: String,
    /// ISO 8601 timestamp when the server started
    pub started_at: String,
    /// Server version for diagnostics (useful when sharing server.json for troubleshooting)
    pub version: String,
}

impl PortFileInfo {
    /// Write a port discovery file to the config directory.
    ///
    /// Called by the server after `TcpListener::bind()` succeeds.
    ///
    /// **Safety checks:**
    /// - Creates the config directory if it doesn't exist (safe to call before `Config::load()`)
    /// - Refuses to overwrite a live server's port file (returns error with PID/port info)
    /// - Automatically removes stale files from dead processes before writing
    pub fn write(port: u16, host: &str) -> ConfigErrorResult<PathBuf> {
        let path = Self::path()?;

        // Ensure config directory exists (safe to call before Config::load())
        if let Some(dir) = path.parent() {
            if !dir.exists() {
                std::fs::create_dir_all(dir).map_err(|e| ConfigError::Io {
                    path: dir.to_path_buf(),
                    source: e,
                })?;
            }
        }

        // Guard: refuse to overwrite a live server's port file.
        // Note: there is a small TOCTOU window between this check and the write
        // below, but for a local development tool the risk is negligible.
        // read_live() also auto-removes stale files from dead processes.
        if let Ok(Some(existing)) = Self::read_live() {
            return Err(ConfigError::config(format!(
                "Another pm-server is already running on port {} (PID {}). \
                 Stop it first or use a different config directory.",
                existing.port, existing.pid
            )));
        }

        let info = PortFileInfo {
            pid: std::process::id(),
            port,
            host: host.to_string(),
            started_at: chrono::Utc::now().to_rfc3339(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        };

        let content = serde_json::to_string_pretty(&info)
            .map_err(|e| ConfigError::config(format!("Failed to serialize port file: {e}")))?;

        std::fs::write(&path, content).map_err(|e| ConfigError::Io {
            path: path.clone(),
            source: e,
        })?;

        Ok(path)
    }

    /// Read the port discovery file from the config directory.
    ///
    /// Returns `Ok(None)` if the file does not exist.
    /// Returns `Err` if the file exists but cannot be read or parsed.
    pub fn read() -> ConfigErrorResult<Option<PortFileInfo>> {
        let path = Self::path()?;

        if !path.exists() {
            return Ok(None);
        }

        let content = std::fs::read_to_string(&path).map_err(|e| ConfigError::Io {
            path: path.clone(),
            source: e,
        })?;

        let info: PortFileInfo = serde_json::from_str(&content)
            .map_err(|e| ConfigError::config(format!("Invalid port file {}: {e}", path.display())))?;

        Ok(Some(info))
    }

    /// Read the port discovery file and verify the server process is still alive.
    ///
    /// Returns `Ok(None)` if:
    /// - The file does not exist
    /// - The file exists but the PID is no longer running (stale file removed)
    ///
    /// This is the primary method the CLI should use.
    pub fn read_live() -> ConfigErrorResult<Option<PortFileInfo>> {
        let info = match Self::read()? {
            Some(info) => info,
            None => return Ok(None),
        };

        if is_process_running(info.pid) {
            Ok(Some(info))
        } else {
            // Stale file - server died without cleanup
            log::debug!(
                "Removing stale port file (pid {} no longer running)",
                info.pid
            );
            let path = Self::path()?;
            std::fs::remove_file(&path).ok(); // Best-effort cleanup
            Ok(None)
        }
    }

    /// Delete the port discovery file.
    ///
    /// Called by the server on graceful shutdown.
    /// Silently succeeds if the file does not exist.
    pub fn remove() -> ConfigErrorResult<()> {
        let path = Self::path()?;
        if path.exists() {
            std::fs::remove_file(&path).map_err(|e| ConfigError::Io {
                path: path.clone(),
                source: e,
            })?;
        }
        Ok(())
    }

    /// Get the path to the port discovery file.
    ///
    /// Returns `<config_dir>/server.json`. Useful for error messages
    /// that need to tell the user where the port file is expected.
    pub fn path() -> ConfigErrorResult<PathBuf> {
        let config_dir = Config::config_dir()?;
        Ok(config_dir.join(PORT_FILENAME))
    }
}

/// Check if a process with the given PID is currently running.
///
/// Uses `kill(pid, 0)` on Unix (checks existence without sending a signal)
/// and `OpenProcess` + `GetExitCodeProcess` on Windows.
#[cfg(unix)]
fn is_process_running(pid: u32) -> bool {
    // SAFETY: kill with signal 0 only checks existence, no signal is sent.
    unsafe { libc::kill(pid as i32, 0) == 0 }
}

#[cfg(windows)]
fn is_process_running(pid: u32) -> bool {
    use std::ffi::c_void;

    const PROCESS_QUERY_LIMITED_INFORMATION: u32 = 0x1000;
    const STILL_ACTIVE: u32 = 259;

    extern "system" {
        fn OpenProcess(access: u32, inherit: i32, pid: u32) -> *mut c_void;
        fn GetExitCodeProcess(process: *mut c_void, exit_code: *mut u32) -> i32;
        fn CloseHandle(handle: *mut c_void) -> i32;
    }

    // SAFETY: OpenProcess returns null on failure (process doesn't exist or
    // access denied). GetExitCodeProcess checks if the process is still active.
    // CloseHandle releases the handle. No resources are leaked.
    unsafe {
        let handle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, pid);
        if handle.is_null() {
            return false;
        }

        let mut exit_code: u32 = 0;
        let success = GetExitCodeProcess(handle, &mut exit_code);
        CloseHandle(handle);

        success != 0 && exit_code == STILL_ACTIVE
    }
}

#[cfg(not(any(unix, windows)))]
fn is_process_running(_pid: u32) -> bool {
    // On exotic platforms (WASM, etc.), assume alive.
    // The CLI will get a connection error if the server is actually dead.
    true
}
```

**Key design decisions explained:**

1. **`read_live()` vs `read()`**: Two methods because tests need `read()` (to verify file contents without PID checks), while the CLI uses `read_live()` (which includes stale detection).

2. **Cross-platform PID check**: Unix uses `libc::kill(pid, 0)`. Windows uses `OpenProcess` + `GetExitCodeProcess` via raw FFI — no extra crate needed. The `#[cfg(not(any(unix, windows)))]` fallback only applies to truly exotic platforms (WASM, etc.).

3. **`env!("CARGO_PKG_VERSION")`**: Embeds pm-config's version at compile time. The version field is diagnostic — useful when users share `server.json` for troubleshooting (like `started_at`).

4. **Best-effort stale cleanup**: `std::fs::remove_file(&path).ok()` swallows errors. If the file can't be removed (permissions), the CLI still returns `None` and shows the "no server found" message — correct behavior.

5. **Race condition protection**: `write()` calls `read_live()` before writing. If another server is running in the same config directory, it returns an error with the existing PID and port. There's a small TOCTOU window between the check and the write, but for a local dev tool this is negligible.

6. **Directory creation safety**: `write()` calls `create_dir_all()` on the parent directory before writing. This makes it safe to call before `Config::load()` (which normally creates `.pm/`).

7. **`path()` is public**: The CLI needs the path for actionable error messages ("Checked: .pm/server.json").

**Verification**: `just check-rs-config`

---

### Step 3: Change DEFAULT_PORT and Export Port File

**File**: `backend/crates/pm-config/src/lib.rs`

Three changes to this file:

**Change 1** - Add module declaration (after existing `mod` block, around line 15):
```rust
mod port_file;
```

**Change 2** - Add re-export (after existing `pub use` block, around line 40):
```rust
pub use port_file::PortFileInfo;
```

**Change 3** - Change DEFAULT_PORT from 8000 to 0 (line 47):
```rust
pub const DEFAULT_PORT: u16 = 0;
```

The full updated constants block:
```rust
// =============================================================================
// Server Configuration
// =============================================================================

pub const DEFAULT_HOST: &str = "127.0.0.1";
pub const DEFAULT_PORT: u16 = 0;
const MIN_PORT: u16 = 1024;
const MIN_MAX_CONNECTIONS: usize = 1;
const MAX_MAX_CONNECTIONS: usize = 100000;
const DEFAULT_MAX_CONNECTIONS: usize = 10000;
```

**Why change the default?** The whole point of this feature is zero-config multi-repo support. With `DEFAULT_PORT = 0`, a new installation (no `config.toml`) automatically gets OS-assigned ports. Existing installations with `port = 8000` in their config are unaffected — the config file overrides the default.

**Verification**: `just check-rs-config`

---

### Step 4: Allow Port 0 in Validation

**File**: `backend/crates/pm-config/src/server_config.rs`

Update the `validate()` method to accept port 0 as a special "auto-assign" value.

**Find this code** (line 31):
```rust
        if self.port < MIN_PORT {
```

**Replace with:**
```rust
        // Port 0 means "auto-assign" - OS picks an available port.
        // Any other port must be >= MIN_PORT (1024).
        if self.port != 0 && self.port < MIN_PORT {
```

Also update the error message (lines 32-34):
```rust
            return Err(ConfigError::config(format!(
                "server.port must be >= {}, got {}",
                MIN_PORT, self.port
            )));
```

**Replace with:**
```rust
            return Err(ConfigError::config(format!(
                "server.port must be 0 (auto) or >= {}, got {}",
                MIN_PORT, self.port
            )));
```

The full updated `validate()` method:
```rust
impl ServerConfig {
    pub fn validate(&self) -> ConfigErrorResult<()> {
        // Port 0 means "auto-assign" - OS picks an available port.
        // Any other port must be >= MIN_PORT (1024).
        if self.port != 0 && self.port < MIN_PORT {
            return Err(ConfigError::config(format!(
                "server.port must be 0 (auto) or >= {}, got {}",
                MIN_PORT, self.port
            )));
        }

        if self.max_connections < MIN_MAX_CONNECTIONS || self.max_connections > MAX_MAX_CONNECTIONS
        {
            return Err(ConfigError::config(format!(
                "server.max_connections must be {}-{}, got {}",
                MIN_MAX_CONNECTIONS, MAX_MAX_CONNECTIONS, self.max_connections
            )));
        }

        Ok(())
    }
}
```

**Verification**: `just check-rs-config`

---

### Step 5: Add Port File Tests

**Create**: `backend/crates/pm-config/src/tests/port_file.rs`

```rust
use crate::port_file::PortFileInfo;
use crate::tests::{setup_config_dir, EnvGuard};

use googletest::assert_that;
use googletest::prelude::*;
use serial_test::serial;

// =========================================================================
// Write & Read Tests
// =========================================================================

#[test]
#[serial]
fn given_port_and_host_when_write_then_file_created_with_correct_fields() {
    // Given
    let (_temp, _guard) = setup_config_dir();

    // When
    let path = PortFileInfo::write(8080, "127.0.0.1").unwrap();

    // Then
    assert!(path.exists());
    let info = PortFileInfo::read().unwrap().unwrap();
    assert_that!(info.port, eq(8080));
    assert_that!(info.host, eq("127.0.0.1"));
    assert_that!(info.pid, eq(std::process::id()));
    assert!(!info.started_at.is_empty());
    assert!(!info.version.is_empty());
}

#[test]
#[serial]
fn given_no_port_file_when_read_then_returns_none() {
    // Given
    let (_temp, _guard) = setup_config_dir();

    // When
    let result = PortFileInfo::read().unwrap();

    // Then
    assert_that!(result, none());
}

// =========================================================================
// Read Live Tests (PID Liveness)
// =========================================================================

#[test]
#[serial]
fn given_port_file_with_current_pid_when_read_live_then_returns_some() {
    // Given
    let (_temp, _guard) = setup_config_dir();
    PortFileInfo::write(9000, "127.0.0.1").unwrap();

    // When - current process PID is definitely alive
    let result = PortFileInfo::read_live().unwrap();

    // Then
    assert!(result.is_some());
    let info = result.unwrap();
    assert_that!(info.port, eq(9000));
}

#[test]
#[serial]
fn given_port_file_with_dead_pid_when_read_live_then_returns_none_and_removes_file() {
    // Given - Write a port file, then overwrite it with a dead PID
    let (temp, _guard) = setup_config_dir();
    PortFileInfo::write(9000, "127.0.0.1").unwrap();

    // Overwrite with a PID that's (almost certainly) not running
    let stale_info = serde_json::json!({
        "pid": 999999,
        "port": 9000,
        "host": "127.0.0.1",
        "started_at": "2026-01-01T00:00:00Z",
        "version": "0.1.0"
    });
    let path = temp.path().join("server.json");
    std::fs::write(&path, serde_json::to_string_pretty(&stale_info).unwrap()).unwrap();
    assert!(path.exists());

    // When
    let result = PortFileInfo::read_live().unwrap();

    // Then
    assert_that!(result, none());
    // Stale file should be removed
    assert!(!path.exists());
}

#[test]
#[serial]
fn given_no_port_file_when_read_live_then_returns_none() {
    // Given
    let (_temp, _guard) = setup_config_dir();

    // When
    let result = PortFileInfo::read_live().unwrap();

    // Then
    assert_that!(result, none());
}

// =========================================================================
// Remove Tests
// =========================================================================

#[test]
#[serial]
fn given_port_file_exists_when_remove_then_file_deleted() {
    // Given
    let (temp, _guard) = setup_config_dir();
    PortFileInfo::write(8080, "127.0.0.1").unwrap();
    let path = temp.path().join("server.json");
    assert!(path.exists());

    // When
    PortFileInfo::remove().unwrap();

    // Then
    assert!(!path.exists());
}

#[test]
#[serial]
fn given_no_port_file_when_remove_then_succeeds() {
    // Given
    let (_temp, _guard) = setup_config_dir();

    // When
    let result = PortFileInfo::remove();

    // Then
    assert_that!(result, ok(anything()));
}

// =========================================================================
// Race Condition Protection Tests
// =========================================================================

#[test]
#[serial]
fn given_live_server_when_write_then_error() {
    // Given - a port file exists with the current (live) PID
    let (_temp, _guard) = setup_config_dir();
    PortFileInfo::write(8080, "127.0.0.1").unwrap();

    // When - try to write another port file while server is "running"
    let result = PortFileInfo::write(9090, "0.0.0.0");

    // Then - should error because existing server is still running
    assert_that!(result, err(anything()));
}

#[test]
#[serial]
fn given_stale_server_when_write_then_overwrites() {
    // Given - a port file with a dead PID
    let (temp, _guard) = setup_config_dir();
    let stale_info = serde_json::json!({
        "pid": 999999,
        "port": 8080,
        "host": "127.0.0.1",
        "started_at": "2026-01-01T00:00:00Z",
        "version": "0.1.0"
    });
    let path = temp.path().join("server.json");
    std::fs::write(&path, serde_json::to_string_pretty(&stale_info).unwrap()).unwrap();

    // When - write a new port file (stale should be auto-cleaned by read_live)
    let result = PortFileInfo::write(9090, "0.0.0.0");

    // Then - should succeed (stale file was cleaned before write)
    assert_that!(result, ok(anything()));
    let info = PortFileInfo::read().unwrap().unwrap();
    assert_that!(info.port, eq(9090));
    assert_that!(info.host, eq("0.0.0.0"));
}

// =========================================================================
// Edge Case Tests
// =========================================================================

#[test]
#[serial]
fn given_directory_not_exist_when_write_then_creates_directory() {
    // Given - PM_CONFIG_DIR points to a non-existent nested directory
    let temp = tempfile::TempDir::new().unwrap();
    let nested = temp.path().join("nested").join("config");
    let _guard = EnvGuard::set("PM_CONFIG_DIR", nested.to_str().unwrap());
    assert!(!nested.exists());

    // When
    let result = PortFileInfo::write(8080, "127.0.0.1");

    // Then
    assert_that!(result, ok(anything()));
    assert!(nested.exists());
    assert!(nested.join("server.json").exists());
}

#[test]
#[serial]
fn given_malformed_json_when_read_then_error() {
    // Given - a port file with invalid JSON
    let (temp, _guard) = setup_config_dir();
    let path = temp.path().join("server.json");
    std::fs::write(&path, "{ invalid json").unwrap();

    // When
    let result = PortFileInfo::read();

    // Then
    assert_that!(result, err(anything()));
}
```

**Verification**: `just test-rs-config`

---

### Step 6: Add Port 0 Validation Test

**File**: `backend/crates/pm-config/src/tests/server.rs`

Append these tests to the existing file (after the last test, around line 70):

```rust
#[test]
#[serial]
fn given_port_zero_when_validate_then_ok() {
    // Given - port 0 means OS auto-assign
    let (_temp, _guard) = setup_config_dir();
    let _port = EnvGuard::set("PM_SERVER_PORT", "0");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, ok(anything()));
}

#[test]
#[serial]
fn given_port_500_nonzero_below_min_when_validate_then_error() {
    // Given - port 500 is below MIN_PORT (1024) and not the special 0
    let (_temp, _guard) = setup_config_dir();
    let _port = EnvGuard::set("PM_SERVER_PORT", "500");

    // When
    let config = Config::load().unwrap();
    let result = config.validate();

    // Then
    assert_that!(result, err(anything()));
}
```

**Verification**: `just test-rs-config`

---

### Step 7: Register Port File Test Module

**File**: `backend/crates/pm-config/src/tests/mod.rs`

Add the module declaration in alphabetical order. The existing file has these modules:
```rust
mod api_config;
mod auth;
mod circuit_breaker;
mod config;
mod desktop_id;
mod edge_cases;
mod handler;
mod retry;
mod server;
mod validation;
mod web_socket;
```

Add `port_file` in alphabetical order (between `handler` and `retry`):
```rust
mod port_file;
```

**Verification**: `just test-rs-config`

---

## Session 120.1 Completion Checklist ✅

After completing all steps:

- [x] `just check-rs-config` passes ✅
- [x] `just test-rs-config` passes (14 tests, all existing + new tests) ✅
- [x] `just check-backend` passes (workspace compile check) ✅
- [x] `just clippy-rs-config` passes ✅

### Files Created (3) ✅

**Actual structure (refactored into module directory):**
- `pm-config/src/port_file/mod.rs` - Cross-platform PID liveness checking
- `pm-config/src/port_file/port_file_info.rs` - PortFileInfo struct and methods
- `pm-config/src/tests/port_file.rs` - 14 comprehensive tests

**Note:** The plan specified a single `port_file.rs` file, but implementation was refactored into a directory structure for better code organization and separation of concerns. This is an architectural improvement.

### Files Modified (5) ✅
- `pm-config/Cargo.toml` - Added chrono, libc, serde_json ✅
- `pm-config/src/lib.rs` - Module declaration, PortFileInfo re-export, DEFAULT_PORT = 0 ✅
- `pm-config/src/server_config.rs` - Port 0 validation exception ✅
- `pm-config/src/tests/mod.rs` - Registered port_file test module ✅
- `pm-config/src/tests/server.rs` - Added 2 port 0 validation tests ✅

### Implementation Summary

**What was delivered:**
- ✅ Port file discovery infrastructure (write, read, read_live, remove, path)
- ✅ PortFileInfo struct with 5 fields (pid, port, host, started_at, version)
- ✅ Cross-platform PID liveness detection (Unix/Windows/fallback)
- ✅ Stale file auto-cleanup on read_live()
- ✅ Race condition protection (refuse to overwrite live server)
- ✅ Configuration changes (DEFAULT_PORT = 0, port 0 validation)
- ✅ Comprehensive test coverage (14 tests: write/read, liveness, removal, race conditions, edge cases)
- ✅ Zero compiler warnings, all tests passing

---

## Next Session: 120.2

**Session 120.2** will integrate this infrastructure into the server and CLI:
- Update `pm-server/src/main.rs` to write the port file after binding and clean up on shutdown
- Update `pm-cli/src/main.rs` to auto-discover the server URL from the port file
- Update `pm-cli/src/cli.rs` with improved help text for --server flag
- Update `backend/config.example.toml` to document `port = 0` behavior
- Update `.server/config.toml` to change port from 8000 to 0

**Prerequisites for Session 120.2:**
- ✅ Session 120.1 complete (this file)
- This session provides the `pm-config` foundation; 120.2 integrates it
