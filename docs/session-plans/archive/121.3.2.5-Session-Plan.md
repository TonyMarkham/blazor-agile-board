# Session 121.3.2.5: Time Entry CRUD

**Status**: ✅ **COMPLETE**
**Parent Plan**: [121.3.2-Session-Plan.md](121.3.2-Session-Plan.md)
**Target**: ~25k tokens
**Prerequisites**: `just check-backend && just test-backend && just check-rs-cli` all pass

---

## Scope

Time entries have zero REST endpoints, zero CLI client methods, and zero CLI commands. The DB repository (`TimeEntryRepository`) already has full CRUD. This session adds the complete REST API module, CLI client methods, and CLI commands.

**Core model fields** (`pm-core/src/models/time_entry.rs`): `id`, `work_item_id`, `user_id`, `started_at`, `ended_at`, `duration_seconds`, `description`, `created_at`, `updated_at`, `deleted_at`

Note: No `version` field. Has running timer concept — `ended_at IS NULL` means timer is running. `TimeEntry::stop()` auto-computes `duration_seconds` from `started_at` to now.

**New REST endpoints**:

| Method | Path | Handler |
|--------|------|---------|
| `GET` | `/api/v1/work-items/{id}/time-entries` | `list_time_entries` |
| `GET` | `/api/v1/time-entries/{id}` | `get_time_entry` |
| `POST` | `/api/v1/time-entries` | `create_time_entry` |
| `PUT` | `/api/v1/time-entries/{id}` | `update_time_entry` |
| `DELETE` | `/api/v1/time-entries/{id}` | `delete_time_entry` |

---

## Implementation Order

### Step 1: Create Time Entry DTO

**Create**: `backend/pm-server/src/api/time_entries/time_entry_dto.rs`

```rust
use pm_core::TimeEntry;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct TimeEntryDto {
    pub id: String,
    pub work_item_id: String,
    pub user_id: String,
    pub started_at: i64,
    pub ended_at: Option<i64>,
    pub duration_seconds: Option<i32>,
    pub description: Option<String>,
    pub is_running: bool,
    pub created_at: i64,
    pub updated_at: i64,
}

impl From<TimeEntry> for TimeEntryDto {
    fn from(te: TimeEntry) -> Self {
        let is_running = te.is_running();
        Self {
            id: te.id.to_string(),
            work_item_id: te.work_item_id.to_string(),
            user_id: te.user_id.to_string(),
            started_at: te.started_at.timestamp(),
            ended_at: te.ended_at.map(|dt| dt.timestamp()),
            duration_seconds: te.duration_seconds,
            description: te.description,
            is_running,
            created_at: te.created_at.timestamp(),
            updated_at: te.updated_at.timestamp(),
        }
    }
}
```

---

### Step 2: Create Response Wrappers

**Create**: `backend/pm-server/src/api/time_entries/time_entry_response.rs`

```rust
use crate::TimeEntryDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct TimeEntryResponse {
    pub time_entry: TimeEntryDto,
}
```

**Create**: `backend/pm-server/src/api/time_entries/time_entry_list_response.rs`

```rust
use crate::TimeEntryDto;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct TimeEntryListResponse {
    pub time_entries: Vec<TimeEntryDto>,
}
```

---

### Step 3: Create Request DTOs

**Create**: `backend/pm-server/src/api/time_entries/create_time_entry_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct CreateTimeEntryRequest {
    pub work_item_id: String,
    /// Optional description of what is being worked on
    #[serde(default)]
    pub description: Option<String>,
}
```

Note: `started_at` auto-set to `Utc::now()`, `user_id` comes from X-User-Id header.

**Create**: `backend/pm-server/src/api/time_entries/update_time_entry_request.rs`

```rust
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct UpdateTimeEntryRequest {
    /// Set to true to stop the running timer
    #[serde(default)]
    pub stop: Option<bool>,
    /// Update description
    #[serde(default)]
    pub description: Option<String>,
}
```

---

### Step 4: Create Handler Functions

**Create**: `backend/pm-server/src/api/time_entries/time_entries.rs`

**`list_time_entries`** (`GET /api/v1/work-items/{id}/time-entries`):
- Parse work item UUID from path
- `TimeEntryRepository::find_by_work_item(id)` — ordered by started_at DESC
- Return `TimeEntryListResponse`

**`get_time_entry`** (`GET /api/v1/time-entries/{id}`):
- Parse UUID from path
- `TimeEntryRepository::find_by_id(id)`
- Return 404 if not found
- Return `TimeEntryResponse`

**`create_time_entry`** (`POST /api/v1/time-entries`):
- Parse `CreateTimeEntryRequest`
- Get user_id from `UserId` extractor
- Validate work item exists — also fetch it to get `project_id` for broadcasts
- Create `TimeEntry::new(work_item_id, user_id, description)` — auto-sets `started_at` to now
- Create `ActivityLog::created("time_entry", time_entry.id, user_id)`
- **Transaction**: `TimeEntryRepository::create()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, Some(work_item_id), None, ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_time_entry_created_response` (non-fatal)
- Return `TimeEntryResponse`

**`update_time_entry`** (`PUT /api/v1/time-entries/{id}`):
- Parse UUID, parse `UpdateTimeEntryRequest`
- Load time entry via `find_by_id()`
- Fetch work item to get `project_id` for broadcasts
- If `stop == Some(true)` and entry is running: call `entry.stop()` (computes `duration_seconds`)
- If `description` provided: update description
- Create `ActivityLog::updated("time_entry", time_entry.id, user_id, &[])`
- **Transaction**: `TimeEntryRepository::update()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, Some(work_item_id), None, ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_time_entry_updated_response` (non-fatal)
- Return `TimeEntryResponse`

**`delete_time_entry`** (`DELETE /api/v1/time-entries/{id}`):
- Parse UUID, load time entry
- Fetch work item to get `project_id` for broadcasts
- Create `ActivityLog::deleted("time_entry", time_entry.id, user_id)`
- **Transaction**: `TimeEntryRepository::delete()` + `ActivityLogRepository::create()` + commit
- **Broadcast**: `broadcast_activity_log_created(project_id, Some(work_item_id), None, ...)` (non-fatal)
- **Broadcast**: `broadcast_to_project(project_id, ...)` with `build_time_entry_deleted_response` (non-fatal)
- Return `DeleteResponse`

**Required**: All mutation handlers (create, update, delete) MUST write `ActivityLog` entries and broadcast via WebSocket, matching the pattern in `work_items.rs`:
1. Create `ActivityLog::created("time_entry", ...)` / `::updated(...)` / `::deleted(...)`
2. Write entity + activity log in same transaction
3. Broadcast `ActivityLogCreated` via `state.registry.broadcast_activity_log_created(project_id, Some(work_item_id), None, message)` (non-fatal) — get `project_id` from the work item
4. Broadcast entity event via `state.registry.broadcast_to_project(project_id, message)` using `build_time_entry_created_response` / `build_time_entry_updated_response` / `build_time_entry_deleted_response` from `pm_ws` (non-fatal)

---

### Step 5: Create Module File

**Create**: `backend/pm-server/src/api/time_entries/mod.rs`

```rust
pub(crate) mod create_time_entry_request;
pub(crate) mod time_entry_dto;
pub(crate) mod time_entry_list_response;
pub(crate) mod time_entry_response;
#[allow(clippy::module_inception)]
pub(crate) mod time_entries;
pub(crate) mod update_time_entry_request;
```

---

### Step 6: Update API Module + Re-exports + Routes

**File**: `backend/pm-server/src/api/mod.rs`

Add: `pub(crate) mod time_entries;`

**File**: `backend/pm-server/src/lib.rs`

Add re-exports:
```rust
time_entries::{
    time_entry_dto::TimeEntryDto,
    time_entry_response::TimeEntryResponse,
    time_entry_list_response::TimeEntryListResponse,
    create_time_entry_request::CreateTimeEntryRequest,
    update_time_entry_request::UpdateTimeEntryRequest,
    time_entries::{list_time_entries, get_time_entry, create_time_entry, update_time_entry, delete_time_entry},
},
```

**File**: `backend/pm-server/src/routes.rs`

Add to `build_router()`:
```rust
// REST API v1 - Time Entries
.route("/api/v1/work-items/{id}/time-entries", get(list_time_entries))
.route("/api/v1/time-entries", post(create_time_entry))
.route("/api/v1/time-entries/{id}", get(get_time_entry))
.route("/api/v1/time-entries/{id}", put(update_time_entry))
.route("/api/v1/time-entries/{id}", delete(delete_time_entry))
```

Update imports at top of `routes.rs`.

**Verification**: `just check-rs-server`

---

### Step 7: Add CLI Client Methods

**File**: `backend/crates/pm-cli/src/client/client.rs`

Add a Time Entry Operations section:

```rust
// =========================================================================
// Time Entry Operations
// =========================================================================

pub async fn list_time_entries(&self, work_item_id: &str) -> CliClientResult<Value> {
    let req = self.request(
        Method::GET,
        &format!("/api/v1/work-items/{}/time-entries", work_item_id),
    );
    self.execute(req).await
}

pub async fn get_time_entry(&self, id: &str) -> CliClientResult<Value> {
    let req = self.request(Method::GET, &format!("/api/v1/time-entries/{}", id));
    self.execute(req).await
}

pub async fn create_time_entry(
    &self,
    work_item_id: &str,
    description: Option<&str>,
) -> CliClientResult<Value> {
    #[derive(Serialize)]
    struct CreateRequest<'a> {
        work_item_id: &'a str,
        #[serde(skip_serializing_if = "Option::is_none")]
        description: Option<&'a str>,
    }

    let body = CreateRequest { work_item_id, description };
    let req = self.request(Method::POST, "/api/v1/time-entries").json(&body);
    self.execute(req).await
}

pub async fn update_time_entry(
    &self,
    id: &str,
    stop: Option<bool>,
    description: Option<&str>,
) -> CliClientResult<Value> {
    #[derive(Serialize)]
    struct UpdateRequest<'a> {
        #[serde(skip_serializing_if = "Option::is_none")]
        stop: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        description: Option<&'a str>,
    }

    let body = UpdateRequest { stop, description };
    let req = self
        .request(Method::PUT, &format!("/api/v1/time-entries/{}", id))
        .json(&body);
    self.execute(req).await
}

pub async fn delete_time_entry(&self, id: &str) -> CliClientResult<Value> {
    let req = self.request(Method::DELETE, &format!("/api/v1/time-entries/{}", id));
    self.execute(req).await
}
```

---

### Step 8: Add CLI Commands

**Create**: `backend/crates/pm-cli/src/time_entry_commands.rs`

```rust
use clap::Subcommand;

#[derive(Subcommand)]
pub enum TimeEntryCommands {
    /// List time entries for a work item
    List {
        /// Work item ID (UUID)
        work_item_id: String,
    },
    /// Get a time entry by ID
    Get {
        /// Time entry ID (UUID)
        id: String,
    },
    /// Start a new timer on a work item
    Create {
        /// Work item ID (UUID)
        #[arg(long)]
        work_item_id: String,
        /// What you're working on
        #[arg(long)]
        description: Option<String>,
    },
    /// Update a time entry (stop timer or edit description)
    Update {
        /// Time entry ID (UUID)
        id: String,
        /// Stop the running timer
        #[arg(long)]
        stop: bool,
        /// Update description
        #[arg(long)]
        description: Option<String>,
    },
    /// Delete a time entry
    Delete {
        /// Time entry ID (UUID)
        id: String,
    },
}
```

---

### Step 9: Wire Time Entry Commands

**File**: `backend/crates/pm-cli/src/commands.rs`

Add:
```rust
/// Time entry operations (start/stop timers)
TimeEntry {
    #[command(subcommand)]
    action: TimeEntryCommands,
},
```

Add import: `use crate::time_entry_commands::TimeEntryCommands;`

**File**: `backend/crates/pm-cli/src/main.rs`

Add `mod time_entry_commands;` and import `TimeEntryCommands`.

Add match arm:
```rust
Commands::TimeEntry { action } => match action {
    TimeEntryCommands::List { work_item_id } => {
        client.list_time_entries(&work_item_id).await
    }
    TimeEntryCommands::Get { id } => client.get_time_entry(&id).await,
    TimeEntryCommands::Create { work_item_id, description } => {
        client.create_time_entry(&work_item_id, description.as_deref()).await
    }
    TimeEntryCommands::Update { id, stop, description } => {
        let stop_flag = if stop { Some(true) } else { None };
        client.update_time_entry(&id, stop_flag, description.as_deref()).await
    }
    TimeEntryCommands::Delete { id } => client.delete_time_entry(&id).await,
},
```

**Verification**: `just check-rs-cli`

---

## Completion Checklist

After completing all steps:

- [ ] `just check-backend` passes
- [ ] `just clippy-backend` passes
- [ ] `just test-backend` passes
- [ ] `just check-rs-cli` passes

### Files Created (8)
- `backend/pm-server/src/api/time_entries/mod.rs`
- `backend/pm-server/src/api/time_entries/time_entry_dto.rs`
- `backend/pm-server/src/api/time_entries/time_entry_response.rs`
- `backend/pm-server/src/api/time_entries/time_entry_list_response.rs`
- `backend/pm-server/src/api/time_entries/create_time_entry_request.rs`
- `backend/pm-server/src/api/time_entries/update_time_entry_request.rs`
- `backend/pm-server/src/api/time_entries/time_entries.rs`
- `backend/crates/pm-cli/src/time_entry_commands.rs`

### Files Modified (6)
- `backend/pm-server/src/api/mod.rs` — add `time_entries` module
- `backend/pm-server/src/lib.rs` — re-export time entry types/handlers
- `backend/pm-server/src/routes.rs` — register 5 routes
- `backend/crates/pm-cli/src/client/client.rs` — add 5 client methods
- `backend/crates/pm-cli/src/commands.rs` — add TimeEntry variant
- `backend/crates/pm-cli/src/main.rs` — add `mod time_entry_commands`, wire commands

---

## Next Session

**Session 121.3.2.6** adds Bulk Sync Endpoints — reusing all DTOs created in 121.3.2.1–5.
