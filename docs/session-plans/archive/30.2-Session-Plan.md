# Session 30.2: Leaf Components

**Parent Plan**: `30-Session-Plan.md`
**Target**: ~35k tokens
**Prerequisites**: Session 30.1 complete (Services and ViewModels)

---

## Scope

This session implements the leaf-level UI components that all other components depend on. These are the smallest, most reusable building blocks of the UI:

1. **Imports Configuration** - Razor imports for components
2. **Banner Components** - OfflineBanner for connection state feedback
3. **Empty State** - EmptyState for zero-data scenarios
4. **Interactive Controls** - LoadingButton, DebouncedTextBox, ConfirmDialog
5. **Loading Skeleton** - ProjectDetailSkeleton for loading states
6. **Display Components** - WorkItemTypeIcon, WorkItemStatusBadge, PriorityBadge

All components follow accessibility best practices (ARIA attributes, keyboard navigation, screen reader support).

---

## Implementation Order

### Step 1: Create Component Imports

**Create**: `frontend/ProjectManagement.Components/_Imports.razor`

This file provides global using statements for all Razor components in the library.

```razor
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@using Radzen
@using Radzen.Blazor
@using ProjectManagement.Core.Models
@using ProjectManagement.Core.Interfaces
@using ProjectManagement.Core.Exceptions
@using ProjectManagement.Core.ViewModels
@using ProjectManagement.Services.State
@using ProjectManagement.Components.Shared
@using ProjectManagement.Components.WorkItems
```

**Verification**: This file doesn't compile on its own, but will be used by all subsequent components.

---

### Step 2: Create OfflineBanner Component

**Create**: `frontend/ProjectManagement.Components/Shared/OfflineBanner.razor`

Real-time connection state feedback for offline-first architecture. Automatically subscribes to AppState and shows appropriate UI for Disconnected/Reconnecting states.

```razor
@using ProjectManagement.Core.Models
@inject AppState AppState
@implements IDisposable

@if (_showBanner)
{
    <div class="offline-banner" role="alert" aria-live="polite">
        <RadzenIcon Icon="cloud_off" />
        <span>You're offline. Changes will sync when reconnected.</span>
        @if (_isReconnecting)
        {
            <RadzenProgressBarCircular ShowValue="false"
                                       Mode="ProgressBarMode.Indeterminate"
                                       Size="ProgressBarCircularSize.Small"
                                       Style="margin-left: auto;" />
        }
    </div>
}

@code {
    private bool _showBanner;
    private bool _isReconnecting;

    protected override void OnInitialized()
    {
        UpdateState(AppState.ConnectionState);
        AppState.OnConnectionStateChanged += HandleConnectionStateChanged;
    }

    private void HandleConnectionStateChanged(ConnectionState state)
    {
        UpdateState(state);
        InvokeAsync(StateHasChanged);
    }

    private void UpdateState(ConnectionState state)
    {
        _showBanner = state != ConnectionState.Connected;
        _isReconnecting = state == ConnectionState.Reconnecting;
    }

    public void Dispose()
    {
        AppState.OnConnectionStateChanged -= HandleConnectionStateChanged;
    }
}
```

**Key Features**:
- Automatically shows/hides based on `AppState.ConnectionState`
- ARIA live region for screen reader announcements
- Spinner during reconnection attempts
- Proper cleanup in `Dispose()`

---

### Step 3: Create EmptyState Component

**Create**: `frontend/ProjectManagement.Components/Shared/EmptyState.razor`

Generic empty state component for zero-data scenarios (empty lists, no search results, etc.). Fully customizable with icon, title, description, and action button.

```razor
<div class="empty-state" role="status">
    <RadzenIcon Icon="@Icon" class="empty-state-icon" />
    <h3 class="empty-state-title">@Title</h3>
    @if (!string.IsNullOrWhiteSpace(Description))
    {
        <p class="empty-state-description">@Description</p>
    }
    @if (ShowAction && OnAction.HasDelegate)
    {
        <RadzenButton Text="@ActionText"
                      Icon="@ActionIcon"
                      Click="@HandleAction"
                      ButtonStyle="ButtonStyle.Primary" />
    }
</div>

@code {
    /// <summary>Material icon name for the empty state illustration.</summary>
    [Parameter]
    public string Icon { get; set; } = "inbox";

    /// <summary>Main title text.</summary>
    [Parameter, EditorRequired]
    public string Title { get; set; } = "No items";

    /// <summary>Optional description text below the title.</summary>
    [Parameter]
    public string? Description { get; set; }

    /// <summary>Text for the action button.</summary>
    [Parameter]
    public string ActionText { get; set; } = "Create";

    /// <summary>Icon for the action button.</summary>
    [Parameter]
    public string ActionIcon { get; set; } = "add";

    /// <summary>Whether to show the action button.</summary>
    [Parameter]
    public bool ShowAction { get; set; } = true;

    /// <summary>Callback when the action button is clicked.</summary>
    [Parameter]
    public EventCallback OnAction { get; set; }

    private async Task HandleAction()
    {
        if (OnAction.HasDelegate)
        {
            await OnAction.InvokeAsync();
        }
    }
}
```

**Key Features**:
- Fully parameterized for reusability
- Optional action button with callback
- Semantic HTML with `role="status"`
- Conditional rendering for optional elements

---

### Step 4: Create LoadingButton Component

**Create**: `frontend/ProjectManagement.Components/Shared/LoadingButton.razor`

Smart button that handles loading states, offline detection, and accessibility. Automatically disables when offline or busy.

```razor
@using ProjectManagement.Core.Models

<RadzenButton Text="@DisplayText"
              Icon="@DisplayIcon"
              IsBusy="@IsBusy"
              Disabled="@IsDisabled"
              ButtonStyle="@ButtonStyle"
              Size="@Size"
              Variant="@Variant"
              Click="@HandleClick"
              title="@Tooltip"
              Style="@Style"
              @attributes="AdditionalAttributes" />

@code {
    /// <summary>Button text when not loading.</summary>
    [Parameter, EditorRequired]
    public string Text { get; set; } = "";

    /// <summary>Button text when loading.</summary>
    [Parameter]
    public string LoadingText { get; set; } = "Loading...";

    /// <summary>Button icon when not loading.</summary>
    [Parameter]
    public string Icon { get; set; } = "";

    /// <summary>Whether the button is in a loading state.</summary>
    [Parameter]
    public bool IsBusy { get; set; }

    /// <summary>Whether the button is disabled (independent of loading state).</summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>Current connection state - button is disabled when disconnected.</summary>
    [Parameter]
    public ConnectionState ConnectionState { get; set; } = ConnectionState.Connected;

    /// <summary>Visual style of the button.</summary>
    [Parameter]
    public ButtonStyle ButtonStyle { get; set; } = ButtonStyle.Primary;

    /// <summary>Size of the button.</summary>
    [Parameter]
    public ButtonSize Size { get; set; } = ButtonSize.Medium;

    /// <summary>Variant of the button (filled, outlined, text, etc.).</summary>
    [Parameter]
    public Variant Variant { get; set; } = Variant.Filled;

    /// <summary>Additional inline styles.</summary>
    [Parameter]
    public string? Style { get; set; }

    /// <summary>Click event callback.</summary>
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>Additional HTML attributes to pass through.</summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private bool IsConnected => ConnectionState == ConnectionState.Connected;
    private bool IsDisabled => IsBusy || Disabled || !IsConnected;
    private string DisplayText => IsBusy ? LoadingText : Text;
    private string DisplayIcon => IsBusy ? "" : Icon;

    private string Tooltip
    {
        get
        {
            if (!IsConnected) return "Offline - action unavailable";
            if (IsBusy) return "Please wait...";
            return Text;
        }
    }

    private async Task HandleClick(MouseEventArgs args)
    {
        if (!IsDisabled && OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(args);
        }
    }
}
```

**Key Features**:
- Offline detection via `ConnectionState` parameter
- Loading text and busy state management
- Smart tooltip based on state
- Attribute splatting for extensibility
- Guards against click when disabled

---

### Step 5: Create DebouncedTextBox Component

**Create**: `frontend/ProjectManagement.Components/Shared/DebouncedTextBox.razor`

Text input with built-in debouncing to reduce update frequency during rapid typing. Essential for search boxes and real-time validation.

```razor
@implements IDisposable

<RadzenTextBox Value="@_currentValue"
               Placeholder="@Placeholder"
               Style="@Style"
               Disabled="@Disabled"
               MaxLength="@MaxLength"
               Change="@HandleChange"
               @attributes="AdditionalAttributes" />

@code {
    /// <summary>The current value of the text box.</summary>
    [Parameter]
    public string Value { get; set; } = "";

    /// <summary>Callback when the value changes (after debounce).</summary>
    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    /// <summary>Placeholder text.</summary>
    [Parameter]
    public string Placeholder { get; set; } = "";

    /// <summary>Inline styles.</summary>
    [Parameter]
    public string Style { get; set; } = "";

    /// <summary>Whether the input is disabled.</summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>Maximum length of input.</summary>
    [Parameter]
    public int? MaxLength { get; set; }

    /// <summary>Debounce delay in milliseconds.</summary>
    [Parameter]
    public int DebounceMs { get; set; } = 300;

    /// <summary>Additional HTML attributes.</summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private string _currentValue = "";
    private CancellationTokenSource? _debounceCts;
    private bool _isDebouncing;

    protected override void OnParametersSet()
    {
        // Only update from external value if we're not in the middle of debouncing
        if (!_isDebouncing && _currentValue != Value)
        {
            _currentValue = Value;
        }
    }

    private async Task HandleChange(string newValue)
    {
        _currentValue = newValue;
        _isDebouncing = true;

        // Cancel any pending debounce
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();

        var token = _debounceCts.Token;

        try
        {
            await Task.Delay(DebounceMs, token);

            // Debounce completed successfully
            if (ValueChanged.HasDelegate)
            {
                await ValueChanged.InvokeAsync(newValue);
            }
        }
        catch (TaskCanceledException)
        {
            // Debounce was cancelled by new input - this is expected
        }
        finally
        {
            if (!token.IsCancellationRequested)
            {
                _isDebouncing = false;
                _debounceCts?.Dispose();
                _debounceCts = null;
            }
        }
    }

    public void Dispose()
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
    }
}
```

**Key Features**:
- Configurable debounce delay (default 300ms)
- Cancels pending updates on new input
- Prevents external updates during debounce period
- Proper cleanup with `IDisposable`
- Handles `TaskCanceledException` gracefully

---

### Step 6: Create ConfirmDialog Component

**Create**: `frontend/ProjectManagement.Components/Shared/ConfirmDialog.razor`

Reusable confirmation dialog with customizable buttons, warning message, and async callback support. Integrates with Radzen `DialogService`.

```razor
@inject DialogService DialogService

<RadzenStack Gap="1rem">
    <RadzenText TextStyle="TextStyle.Body1">@Message</RadzenText>

    @if (!string.IsNullOrWhiteSpace(WarningMessage))
    {
        <RadzenAlert AlertStyle="AlertStyle.Warning"
                     Shade="Shade.Light"
                     Size="AlertSize.Small"
                     AllowClose="false">
            @WarningMessage
        </RadzenAlert>
    }

    @if (ChildContent is not null)
    {
        @ChildContent
    }

    <RadzenStack Orientation="Orientation.Horizontal"
                 Gap="0.5rem"
                 JustifyContent="JustifyContent.End">
        <RadzenButton Text="@CancelText"
                      ButtonStyle="ButtonStyle.Light"
                      Click="@HandleCancel"
                      Disabled="@IsBusy" />
        <RadzenButton Text="@ConfirmText"
                      ButtonStyle="@ConfirmButtonStyle"
                      Click="@HandleConfirm"
                      IsBusy="@IsBusy" />
    </RadzenStack>
</RadzenStack>

@code {
    /// <summary>The main confirmation message.</summary>
    [Parameter, EditorRequired]
    public string Message { get; set; } = "";

    /// <summary>Optional warning message shown in an alert.</summary>
    [Parameter]
    public string? WarningMessage { get; set; }

    /// <summary>Text for the confirm button.</summary>
    [Parameter]
    public string ConfirmText { get; set; } = "Confirm";

    /// <summary>Text for the cancel button.</summary>
    [Parameter]
    public string CancelText { get; set; } = "Cancel";

    /// <summary>Style for the confirm button.</summary>
    [Parameter]
    public ButtonStyle ConfirmButtonStyle { get; set; } = ButtonStyle.Primary;

    /// <summary>Whether the dialog is in a busy/loading state.</summary>
    [Parameter]
    public bool IsBusy { get; set; }

    /// <summary>Optional additional content to display.</summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>Callback when confirm is clicked.</summary>
    [Parameter]
    public EventCallback OnConfirm { get; set; }

    /// <summary>Callback when cancel is clicked.</summary>
    [Parameter]
    public EventCallback OnCancel { get; set; }

    private async Task HandleConfirm()
    {
        if (OnConfirm.HasDelegate)
        {
            await OnConfirm.InvokeAsync();
        }
        else
        {
            DialogService.Close(true);
        }
    }

    private async Task HandleCancel()
    {
        if (OnCancel.HasDelegate)
        {
            await OnCancel.InvokeAsync();
        }
        else
        {
            DialogService.Close(false);
        }
    }
}
```

**Key Features**:
- Optional warning banner for destructive actions
- Customizable button text and styles
- Supports custom content via `ChildContent`
- Integrates with Radzen `DialogService`
- Button disabled during busy state

---

### Step 7: Create ProjectDetailSkeleton Component

**Create**: `frontend/ProjectManagement.Components/Shared/ProjectDetailSkeleton.razor`

Loading skeleton for project detail pages. Shows placeholder UI while data loads, improving perceived performance.

```razor
<div role="status" aria-label="Loading project details" aria-busy="true">
    <RadzenStack Gap="1rem">
        @* Header skeleton *@
        <RadzenRow AlignItems="AlignItems.Center">
            <RadzenColumn Size="12" SizeMD="8">
                <RadzenStack Orientation="Orientation.Horizontal"
                             AlignItems="AlignItems.Center"
                             Gap="0.5rem">
                    <RadzenSkeleton Shape="SkeletonShape.Circle" Width="32px" Height="32px" />
                    <RadzenSkeleton Width="250px" Height="32px" />
                </RadzenStack>
                <div class="mt-2">
                    <RadzenSkeleton Width="180px" Height="16px" />
                </div>
            </RadzenColumn>
            <RadzenColumn Size="12" SizeMD="4" class="text-end">
                <RadzenStack Orientation="Orientation.Horizontal"
                             Gap="0.5rem"
                             JustifyContent="JustifyContent.End">
                    <RadzenSkeleton Width="100px" Height="36px" />
                    <RadzenSkeleton Width="120px" Height="36px" />
                </RadzenStack>
            </RadzenColumn>
        </RadzenRow>

        @* Tabs skeleton *@
        <RadzenStack Orientation="Orientation.Horizontal" Gap="1rem" class="mt-2">
            <RadzenSkeleton Width="80px" Height="32px" />
            <RadzenSkeleton Width="80px" Height="32px" />
            <RadzenSkeleton Width="80px" Height="32px" />
        </RadzenStack>

        @* Content skeleton *@
        <RadzenRow class="mt-3">
            <RadzenColumn Size="12">
                <RadzenStack Gap="0.5rem">
                    @for (var i = 0; i < RowCount; i++)
                    {
                        <RadzenSkeleton Width="100%" Height="@($"{RowHeight}px")" />
                    }
                </RadzenStack>
            </RadzenColumn>
        </RadzenRow>
    </RadzenStack>

    <span class="visually-hidden">Loading project details...</span>
</div>

@code {
    /// <summary>Number of placeholder rows to display.</summary>
    [Parameter]
    public int RowCount { get; set; } = 5;

    /// <summary>Height of each placeholder row in pixels.</summary>
    [Parameter]
    public int RowHeight { get; set; } = 52;
}
```

**Key Features**:
- Matches actual project detail layout
- Configurable row count and height
- ARIA attributes for accessibility
- Hidden text for screen readers
- Responsive layout (mobile/desktop)

---

### Step 8: Create WorkItemTypeIcon Component

**Create**: `frontend/ProjectManagement.Components/WorkItems/WorkItemTypeIcon.razor`

Displays color-coded icon for work item types (Project, Epic, Story, Task). Consistent visual language across the app.

```razor
@using ProjectManagement.Core.Models

<span class="work-item-type-icon" title="@TypeName">
    <RadzenIcon Icon="@IconName" Style="@IconStyle" />
    <span class="visually-hidden">@TypeName</span>
</span>

@code {
    /// <summary>The work item type to display.</summary>
    [Parameter, EditorRequired]
    public WorkItemType Type { get; set; }

    /// <summary>Optional size override (e.g., "1.5rem", "24px").</summary>
    [Parameter]
    public string? Size { get; set; }

    private string TypeName => Type switch
    {
        WorkItemType.Project => "Project",
        WorkItemType.Epic => "Epic",
        WorkItemType.Story => "Story",
        WorkItemType.Task => "Task",
        _ => "Unknown"
    };

    private string IconName => Type switch
    {
        WorkItemType.Project => "folder",
        WorkItemType.Epic => "rocket_launch",
        WorkItemType.Story => "description",
        WorkItemType.Task => "task_alt",
        _ => "help_outline"
    };

    private string IconColor => Type switch
    {
        WorkItemType.Project => "var(--rz-primary)",
        WorkItemType.Epic => "#9c27b0",      // Purple
        WorkItemType.Story => "#2196f3",     // Blue
        WorkItemType.Task => "#4caf50",      // Green
        _ => "var(--rz-text-secondary-color)"
    };

    private string IconStyle
    {
        get
        {
            var style = $"color: {IconColor};";
            if (!string.IsNullOrEmpty(Size))
            {
                style += $" font-size: {Size};";
            }
            return style;
        }
    }
}
```

**Key Features**:
- Type-specific icons and colors
- Optional size parameter
- Hidden text for screen readers
- Tooltip with type name

---

### Step 9: Create WorkItemStatusBadge Component

**Create**: `frontend/ProjectManagement.Components/WorkItems/WorkItemStatusBadge.razor`

Displays status badge with appropriate color coding. Maps database status strings to human-readable labels.

```razor
<RadzenBadge BadgeStyle="@BadgeStyle"
             Text="@DisplayText"
             title="@($"Status: {DisplayText}")"
             IsPill="@IsPill" />

@code {
    /// <summary>The status value (e.g., "backlog", "in_progress", "done").</summary>
    [Parameter, EditorRequired]
    public string Status { get; set; } = "backlog";

    /// <summary>Whether to render as a pill shape.</summary>
    [Parameter]
    public bool IsPill { get; set; } = true;

    private BadgeStyle BadgeStyle => Status switch
    {
        "backlog" => BadgeStyle.Secondary,
        "todo" => BadgeStyle.Info,
        "in_progress" => BadgeStyle.Warning,
        "review" => BadgeStyle.Primary,
        "done" => BadgeStyle.Success,
        _ => BadgeStyle.Light
    };

    private string DisplayText => Status switch
    {
        "backlog" => "Backlog",
        "todo" => "To Do",
        "in_progress" => "In Progress",
        "review" => "Review",
        "done" => "Done",
        _ => Status
    };
}
```

**Key Features**:
- Status-specific colors (Secondary, Info, Warning, Primary, Success)
- Human-readable labels
- Pill shape by default
- Tooltip with full status text

---

### Step 10: Create PriorityBadge Component

**Create**: `frontend/ProjectManagement.Components/WorkItems/PriorityBadge.razor`

Displays priority with icon and optional label. Color-coded for quick visual scanning (Critical=Red, High=Orange, Medium=Blue, Low=Green).

```razor
<span class="priority-badge" title="@($"Priority: {DisplayText}")">
    <RadzenStack Orientation="Orientation.Horizontal"
                 AlignItems="AlignItems.Center"
                 Gap="0.25rem">
        <RadzenIcon Icon="@IconName" Style="@IconStyle" />
        @if (ShowLabel)
        {
            <span style="@LabelStyle">@DisplayText</span>
        }
    </RadzenStack>
</span>

@code {
    /// <summary>The priority value (e.g., "critical", "high", "medium", "low").</summary>
    [Parameter, EditorRequired]
    public string Priority { get; set; } = "medium";

    /// <summary>Whether to show the text label alongside the icon.</summary>
    [Parameter]
    public bool ShowLabel { get; set; } = true;

    /// <summary>Optional size for the icon.</summary>
    [Parameter]
    public string? Size { get; set; }

    private string IconName => Priority switch
    {
        "critical" => "priority_high",
        "high" => "keyboard_arrow_up",
        "medium" => "remove",
        "low" => "keyboard_arrow_down",
        _ => "remove"
    };

    private string IconColor => Priority switch
    {
        "critical" => "#d32f2f",  // Red
        "high" => "#f57c00",      // Orange
        "medium" => "#1976d2",    // Blue
        "low" => "#388e3c",       // Green
        _ => "var(--rz-text-secondary-color)"
    };

    private string IconStyle
    {
        get
        {
            var style = $"color: {IconColor};";
            if (!string.IsNullOrEmpty(Size))
            {
                style += $" font-size: {Size};";
            }
            return style;
        }
    }

    private string LabelStyle => $"color: {IconColor}; font-size: 0.875rem;";

    private string DisplayText => Priority switch
    {
        "critical" => "Critical",
        "high" => "High",
        "medium" => "Medium",
        "low" => "Low",
        _ => Priority
    };
}
```

**Key Features**:
- Priority-specific icons and colors
- Optional label display
- Custom size support
- Tooltip with priority level

---

## Session 30.2 Completion Checklist

After completing all steps:

- [ ] `dotnet build frontend/ProjectManagement.Components` passes
- [ ] `dotnet build frontend/ProjectManagement.sln` passes
- [ ] All components have proper ARIA attributes
- [ ] All components handle null/empty parameters gracefully
- [ ] All components implement `IDisposable` where needed (OfflineBanner, DebouncedTextBox)
- [ ] All components use semantic HTML and proper roles
- [ ] All interactive components have keyboard navigation support (via Radzen)

### Files Created (10 files)

**Components Project**:
1. `ProjectManagement.Components/_Imports.razor` - Global imports
2. `ProjectManagement.Components/Shared/OfflineBanner.razor` - Connection state banner
3. `ProjectManagement.Components/Shared/EmptyState.razor` - Zero-data state
4. `ProjectManagement.Components/Shared/LoadingButton.razor` - Smart button with loading
5. `ProjectManagement.Components/Shared/DebouncedTextBox.razor` - Debounced text input
6. `ProjectManagement.Components/Shared/ConfirmDialog.razor` - Confirmation dialog
7. `ProjectManagement.Components/Shared/ProjectDetailSkeleton.razor` - Loading skeleton
8. `ProjectManagement.Components/WorkItems/WorkItemTypeIcon.razor` - Type icon
9. `ProjectManagement.Components/WorkItems/WorkItemStatusBadge.razor` - Status badge
10. `ProjectManagement.Components/WorkItems/PriorityBadge.razor` - Priority badge

### Files Modified

None (all new files).

---

## Design Notes

### Accessibility

All components follow WCAG 2.1 Level AA guidelines:
- **Semantic HTML**: Proper use of `<button>`, `<div role="status">`, etc.
- **ARIA attributes**: `role`, `aria-label`, `aria-live`, `aria-busy`
- **Screen reader support**: Hidden text for context (`visually-hidden` class)
- **Keyboard navigation**: All Radzen components support keyboard by default
- **Focus management**: Radzen handles focus properly in dialogs/modals

### Offline-First Design

Components that depend on network state:
- **OfflineBanner**: Shows when `ConnectionState != Connected`
- **LoadingButton**: Disables when `ConnectionState != Connected`
- Both components use the same `ConnectionState` enum for consistency

### Debouncing Strategy

`DebouncedTextBox` uses cancellation token pattern:
1. Each keystroke cancels the previous debounce timer
2. Only the last value (after delay) triggers `ValueChanged`
3. Prevents external value updates during active typing
4. Properly disposes cancellation tokens

### Component Reusability

All components are designed for maximum reusability:
- **Parameterization**: Most behavior is controlled via `[Parameter]`
- **Attribute splatting**: `[Parameter(CaptureUnmatchedValues = true)]` for extensibility
- **Event callbacks**: Components don't assume specific parent behavior
- **Semantic defaults**: Sensible defaults reduce boilerplate

---

## Next Session

**Session 30.3: Composite Components** will implement higher-level components:
- WorkItemCard
- WorkItemForm
- WorkItemList
- SprintCard
- TimeEntryCard
- ActivityLogEntry

These components compose the leaf components from this session.
