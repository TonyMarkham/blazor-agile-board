# Session 41.3: Frontend Models & WebSocket

**Parent Plan**: `41-Session-Plan.md`
**Target**: ~30-40k tokens
**Prerequisites**: Session 41.2 complete, `cargo test --workspace` passes

---

## Scope

This session implements the C# models and WebSocket client extensions:

1. **C# Models** - ProjectStatus enum, Project record, DTOs
2. **WorkItemType Update** - Remove Project enum value
3. **IWebSocketClient** - Add Project events and operations
4. **WebSocketClient** - Implement Project methods
5. **ProtoConverter** - Add Project â†” proto conversions

---

## Implementation Order

### Step 1: Create ProjectStatus Enum

**Create**: `frontend/ProjectManagement.Core/Models/ProjectStatus.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Project lifecycle status.
/// </summary>
public enum ProjectStatus
{
    /// <summary>
    /// Project is active and accepting work.
    /// </summary>
    Active = 0,

    /// <summary>
    /// Project is archived (read-only, hidden from default views).
    /// </summary>
    Archived = 1
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 2: Create Project Model

**Create**: `frontend/ProjectManagement.Core/Models/Project.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// A project is a top-level organizational container for work items.
/// Unlike work items, projects have a unique key and can be archived.
/// </summary>
public sealed record Project
{
    /// <summary>
    /// Unique identifier.
    /// </summary>
    public required Guid Id { get; init; }

    /// <summary>
    /// Project title/name.
    /// </summary>
    public required string Title { get; init; }

    /// <summary>
    /// Optional description.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Unique short identifier (e.g., "PROJ", "WEBAPP").
    /// Immutable after creation.
    /// </summary>
    public required string Key { get; init; }

    /// <summary>
    /// Current lifecycle status.
    /// </summary>
    public required ProjectStatus Status { get; init; }

    /// <summary>
    /// Version for optimistic concurrency control.
    /// </summary>
    public required int Version { get; init; }

    /// <summary>
    /// When the project was created.
    /// </summary>
    public required DateTime CreatedAt { get; init; }

    /// <summary>
    /// When the project was last updated.
    /// </summary>
    public required DateTime UpdatedAt { get; init; }

    /// <summary>
    /// User who created the project.
    /// </summary>
    public required Guid CreatedBy { get; init; }

    /// <summary>
    /// User who last updated the project.
    /// </summary>
    public required Guid UpdatedBy { get; init; }

    /// <summary>
    /// When the project was soft-deleted (null if not deleted).
    /// </summary>
    public DateTime? DeletedAt { get; init; }

    /// <summary>
    /// Check if the project is deleted.
    /// </summary>
    public bool IsDeleted => DeletedAt.HasValue;

    /// <summary>
    /// Check if the project is archived.
    /// </summary>
    public bool IsArchived => Status == ProjectStatus.Archived;
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 3: Create Request DTOs

**Create**: `frontend/ProjectManagement.Core/Models/CreateProjectRequest.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to create a new project.
/// </summary>
public sealed record CreateProjectRequest
{
    /// <summary>
    /// Project title (1-200 characters).
    /// </summary>
    public required string Title { get; init; }

    /// <summary>
    /// Optional description (max 10000 characters).
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Unique project key (2-20 alphanumeric characters).
    /// Will be stored uppercase.
    /// </summary>
    public required string Key { get; init; }
}
```

**Create**: `frontend/ProjectManagement.Core/Models/UpdateProjectRequest.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request to update an existing project.
/// Only non-null fields will be updated.
/// </summary>
public sealed record UpdateProjectRequest
{
    /// <summary>
    /// ID of the project to update.
    /// </summary>
    public required Guid ProjectId { get; init; }

    /// <summary>
    /// Expected version for optimistic concurrency.
    /// </summary>
    public required int ExpectedVersion { get; init; }

    /// <summary>
    /// New title (null to keep current).
    /// </summary>
    public string? Title { get; init; }

    /// <summary>
    /// New description (null to keep current).
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// New status (null to keep current).
    /// </summary>
    public ProjectStatus? Status { get; init; }
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 4: Update WorkItemType

**Update**: `frontend/ProjectManagement.Core/Models/WorkItemType.cs`

Remove the `Project` enum value and update helper methods:

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Type of work item in the hierarchy.
/// Note: Project is now a separate entity, not a WorkItemType.
/// </summary>
public enum WorkItemType
{
    // Project = 1, -- REMOVED: Projects are now separate entities

    /// <summary>
    /// Large body of work, contains Stories and Tasks.
    /// </summary>
    Epic = 2,

    /// <summary>
    /// User-facing feature or requirement.
    /// </summary>
    Story = 3,

    /// <summary>
    /// Atomic unit of work.
    /// </summary>
    Task = 4
}

/// <summary>
/// Extension methods for WorkItemType.
/// </summary>
public static class WorkItemTypeExtensions
{
    /// <summary>
    /// Check if this type can have a parent work item.
    /// All work item types can have parents now (Projects are separate).
    /// </summary>
    public static bool CanHaveParent(this WorkItemType type) => true;

    /// <summary>
    /// Get allowed child types for a work item.
    /// </summary>
    public static IReadOnlyList<WorkItemType> AllowedChildTypes(this WorkItemType type) => type switch
    {
        WorkItemType.Epic => [WorkItemType.Story, WorkItemType.Task],
        WorkItemType.Story => [WorkItemType.Task],
        WorkItemType.Task => [],
        _ => []
    };

    /// <summary>
    /// Get display name for the type.
    /// </summary>
    public static string DisplayName(this WorkItemType type) => type switch
    {
        WorkItemType.Epic => "Epic",
        WorkItemType.Story => "Story",
        WorkItemType.Task => "Task",
        _ => type.ToString()
    };
}
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 5: Update IWebSocketClient

**Update**: `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs`

Add these members to the interface:

```csharp
// ============================================================
// Project Events
// ============================================================

/// <summary>
/// Fired when a project is created (by us or another user).
/// </summary>
event Action<Project>? OnProjectCreated;

/// <summary>
/// Fired when a project is updated (by us or another user).
/// </summary>
event Action<Project, IReadOnlyList<FieldChange>>? OnProjectUpdated;

/// <summary>
/// Fired when a project is deleted (by us or another user).
/// </summary>
event Action<Guid>? OnProjectDeleted;

// ============================================================
// Project Operations
// ============================================================

/// <summary>
/// Create a new project.
/// </summary>
Task<Project> CreateProjectAsync(CreateProjectRequest request, CancellationToken ct = default);

/// <summary>
/// Update an existing project.
/// </summary>
Task<Project> UpdateProjectAsync(UpdateProjectRequest request, CancellationToken ct = default);

/// <summary>
/// Delete a project (soft delete).
/// </summary>
Task DeleteProjectAsync(Guid projectId, int expectedVersion, CancellationToken ct = default);

/// <summary>
/// Get all projects.
/// </summary>
Task<IReadOnlyList<Project>> GetProjectsAsync(CancellationToken ct = default);
```

**Verification**: `dotnet build frontend/ProjectManagement.Core`

---

### Step 6: Update ProtoConverter

**Update**: `frontend/ProjectManagement.Services/WebSocket/ProtoConverter.cs`

Add these methods:

```csharp
// ============================================================
// Project Conversions
// ============================================================

/// <summary>
/// Convert proto Project to domain Project.
/// </summary>
public static Project ToDomain(Pm.Project proto) => new()
{
    Id = Guid.Parse(proto.Id),
    Title = proto.Title,
    Description = proto.HasDescription ? proto.Description : null,
    Key = proto.Key,
    Status = proto.Status switch
    {
        Pm.ProjectStatus.Active => ProjectStatus.Active,
        Pm.ProjectStatus.Archived => ProjectStatus.Archived,
        _ => ProjectStatus.Active
    },
    Version = proto.Version,
    CreatedAt = DateTimeOffset.FromUnixTimeSeconds(proto.CreatedAt).UtcDateTime,
    UpdatedAt = DateTimeOffset.FromUnixTimeSeconds(proto.UpdatedAt).UtcDateTime,
    CreatedBy = Guid.Parse(proto.CreatedBy),
    UpdatedBy = Guid.Parse(proto.UpdatedBy),
    DeletedAt = proto.HasDeletedAt
        ? DateTimeOffset.FromUnixTimeSeconds(proto.DeletedAt).UtcDateTime
        : null,
};

/// <summary>
/// Convert CreateProjectRequest to proto.
/// </summary>
public static Pm.CreateProjectRequest ToProto(CreateProjectRequest req) => new()
{
    Title = req.Title,
    Description = req.Description ?? "",
    Key = req.Key,
};

/// <summary>
/// Convert UpdateProjectRequest to proto.
/// </summary>
public static Pm.UpdateProjectRequest ToProto(UpdateProjectRequest req)
{
    var proto = new Pm.UpdateProjectRequest
    {
        ProjectId = req.ProjectId.ToString(),
        ExpectedVersion = req.ExpectedVersion,
    };

    if (req.Title is not null)
        proto.Title = req.Title;

    if (req.Description is not null)
        proto.Description = req.Description;

    if (req.Status.HasValue)
        proto.Status = req.Status.Value switch
        {
            ProjectStatus.Active => Pm.ProjectStatus.Active,
            ProjectStatus.Archived => Pm.ProjectStatus.Archived,
            _ => Pm.ProjectStatus.Active
        };

    return proto;
}

/// <summary>
/// Convert delete request to proto.
/// </summary>
public static Pm.DeleteProjectRequest ToDeleteProjectProto(Guid projectId, int expectedVersion) => new()
{
    ProjectId = projectId.ToString(),
    ExpectedVersion = expectedVersion,
};
```

**Verification**: `dotnet build frontend/ProjectManagement.Services`

---

### Step 7: Implement WebSocketClient Methods

**Update**: `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

Add the event declarations:

```csharp
// Events
public event Action<Project>? OnProjectCreated;
public event Action<Project, IReadOnlyList<FieldChange>>? OnProjectUpdated;
public event Action<Guid>? OnProjectDeleted;
```

Add the operation implementations:

```csharp
public async Task<Project> CreateProjectAsync(CreateProjectRequest request, CancellationToken ct = default)
{
    var message = new Pm.WebSocketMessage
    {
        MessageId = Guid.NewGuid().ToString(),
        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        CreateProjectRequest = ProtoConverter.ToProto(request),
    };

    var response = await SendRequestAsync(message, ct);

    if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
        throw new ServerRejectedException(response.Error.Code, response.Error.Message);

    if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.ProjectCreated)
        throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

    return ProtoConverter.ToDomain(response.ProjectCreated.Project);
}

public async Task<Project> UpdateProjectAsync(UpdateProjectRequest request, CancellationToken ct = default)
{
    var message = new Pm.WebSocketMessage
    {
        MessageId = Guid.NewGuid().ToString(),
        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        UpdateProjectRequest = ProtoConverter.ToProto(request),
    };

    var response = await SendRequestAsync(message, ct);

    if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
        throw new ServerRejectedException(response.Error.Code, response.Error.Message);

    if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.ProjectUpdated)
        throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

    return ProtoConverter.ToDomain(response.ProjectUpdated.Project);
}

public async Task DeleteProjectAsync(Guid projectId, int expectedVersion, CancellationToken ct = default)
{
    var message = new Pm.WebSocketMessage
    {
        MessageId = Guid.NewGuid().ToString(),
        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        DeleteProjectRequest = ProtoConverter.ToDeleteProjectProto(projectId, expectedVersion),
    };

    var response = await SendRequestAsync(message, ct);

    if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
        throw new ServerRejectedException(response.Error.Code, response.Error.Message);

    if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.ProjectDeleted)
        throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");
}

public async Task<IReadOnlyList<Project>> GetProjectsAsync(CancellationToken ct = default)
{
    var message = new Pm.WebSocketMessage
    {
        MessageId = Guid.NewGuid().ToString(),
        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        ListProjectsRequest = new Pm.ListProjectsRequest(),
    };

    var response = await SendRequestAsync(message, ct);

    if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
        throw new ServerRejectedException(response.Error.Code, response.Error.Message);

    if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.ProjectList)
        throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

    return response.ProjectList.Projects.Select(ProtoConverter.ToDomain).ToList();
}
```

Update the `HandleBroadcastEvent` method to add Project cases:

```csharp
// In HandleBroadcastEvent switch statement, add:
case Pm.WebSocketMessage.PayloadOneofCase.ProjectCreated:
    var createdProject = ProtoConverter.ToDomain(message.ProjectCreated.Project);
    OnProjectCreated?.Invoke(createdProject);
    break;

case Pm.WebSocketMessage.PayloadOneofCase.ProjectUpdated:
    var updatedProject = ProtoConverter.ToDomain(message.ProjectUpdated.Project);
    var projectChanges = message.ProjectUpdated.Changes
        .Select(c => new FieldChange(c.FieldName, c.OldValue, c.NewValue))
        .ToList();
    OnProjectUpdated?.Invoke(updatedProject, projectChanges);
    break;

case Pm.WebSocketMessage.PayloadOneofCase.ProjectDeleted:
    var deletedProjectId = Guid.Parse(message.ProjectDeleted.ProjectId);
    OnProjectDeleted?.Invoke(deletedProjectId);
    break;
```

**Verification**: `dotnet build frontend/ProjectManagement.Services`

---

## Session 41.3 Completion Checklist

After completing all steps:

- [ ] `dotnet build frontend/ProjectManagement.Core` passes
- [ ] `dotnet build frontend/ProjectManagement.Services` passes
- [ ] `dotnet build frontend/ProjectManagement.sln` passes
- [ ] No compiler warnings related to Project types

### Files Created (4)
- `Core/Models/ProjectStatus.cs`
- `Core/Models/Project.cs`
- `Core/Models/CreateProjectRequest.cs`
- `Core/Models/UpdateProjectRequest.cs`

### Files Modified (4)
- `Core/Models/WorkItemType.cs`
- `Core/Interfaces/IWebSocketClient.cs`
- `Services/WebSocket/WebSocketClient.cs`
- `Services/WebSocket/ProtoConverter.cs`

---

## Next Session

**Session 41.4** will implement:
- ProjectViewModel
- IProjectStore and ProjectStore
- AppState integration
- ProjectDialog component
- Page updates (Home, ProjectDetail, MainLayout)
- Frontend tests
