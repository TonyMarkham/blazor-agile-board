# Session 42.3: Tauri Service (JS Elimination)

**Parent Plan**: `42-Session-Plan-Overview.md`
**Prerequisite**: Session 42.2 completed
**Target**: ~35-40k tokens

---

## Teaching Focus

This session teaches:
- **C#/JavaScript interop** patterns in Blazor
- **Resource management** with event subscriptions
- **Graceful degradation** when APIs aren't available
- **Eliminating external dependencies** for simpler architecture

---

## Scope

1. **TauriService** - Type-safe C# wrapper for Tauri IPC
2. **DesktopConfigService** - Server lifecycle management
3. **Delete JavaScript** - Remove desktop-interop.js

---

## Prerequisites Check

Before starting, verify Session 42.2 is complete:

```bash
dotnet build frontend/ProjectManagement.sln
ls frontend/ProjectManagement.Services/Desktop/UserIdentityService.cs
ls frontend/ProjectManagement.Core/State/AppStartupState.cs
```

---

## Why Eliminate JavaScript?

The existing `desktop-interop.js` was 30 lines of JavaScript that:
1. Wrapped Tauri invoke calls
2. Managed event subscriptions
3. Provided type conversion

**Problems:**
- Two languages to maintain (C# + JS)
- No compile-time type safety for JS code
- Stack traces jump between browser console and Blazor logs
- Memory leaks from unclean event subscription cleanup

**Solution:**
- Call Tauri directly from C# via `IJSRuntime`
- Get compile-time type safety with C# models
- Proper resource management with `IAsyncDisposable`

---

## Implementation Order

### Step 1: Create TauriService with Complete Resource Management

**Create**: `frontend/ProjectManagement.Services/Desktop/TauriService.cs`

```csharp
using Microsoft.JSInterop;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace ProjectManagement.Services.Desktop;

/// <summary>
/// C# wrapper for Tauri IPC commands.
/// Replaces desktop-interop.js with type-safe C# calls.
/// Implements proper resource management and graceful degradation.
/// </summary>
public sealed class TauriService : IAsyncDisposable
{
    private readonly IJSRuntime _js;
    private readonly ILogger<TauriService> _logger;
    private readonly ConcurrentDictionary<string, IDisposable> _subscriptions = new();
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _disposed;
    private bool? _isDesktopCached;
    private bool _initialized;

    // Tauri API paths
    private const string TauriInvokePath = "__TAURI__.core.invoke";
    private const string TauriDetectionScript = "typeof window !== 'undefined' && typeof window.__TAURI__ !== 'undefined'";

    // Tauri command names
    private const string CommandGetServerStatus = "get_server_status";
    private const string CommandGetWebSocketUrl = "get_websocket_url";
    private const string CommandRestartServer = "restart_server";
    private const string CommandExportDiagnostics = "export_diagnostics";

    // Event names
    private const string EventServerStateChanged = "server-state-changed";

    // JS interop
    private const string JsUnlistenersGlobal = "__PM_UNLISTENERS__";
    private const string AssemblyName = "ProjectManagement.Services";
    private const string HandleEventMethod = "HandleTauriEvent";

    public TauriService(IJSRuntime js, ILogger<TauriService> logger)
    {
        _js = js ?? throw new ArgumentNullException(nameof(js));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Checks if running in Tauri desktop environment.
    /// Result is cached. Returns false on any error (graceful degradation).
    /// </summary>
    public async Task<bool> IsDesktopAsync()
    {
        if (_isDesktopCached.HasValue)
            return _isDesktopCached.Value;

        await _initLock.WaitAsync();
        try
        {
            if (_isDesktopCached.HasValue)
                return _isDesktopCached.Value;

            var exists = await _js.InvokeAsync<bool>(
                "eval",
                TauriDetectionScript
            );

            _isDesktopCached = exists;
            _logger.LogInformation("Desktop mode detected: {IsDesktop}", exists);
            return exists;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Tauri detection failed, assuming web mode");
            _isDesktopCached = false;
            return false;
        }
        finally
        {
            _initLock.Release();
        }
    }

    /// <summary>
    /// Gets current server status from Tauri backend.
    /// </summary>
    public async Task<ServerStatus> GetServerStatusAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();
        await EnsureDesktopAsync();

        return await InvokeTauriAsync<ServerStatus>(CommandGetServerStatus, ct);
    }

    /// <summary>
    /// Gets WebSocket URL for connecting to server.
    /// </summary>
    public async Task<string> GetWebSocketUrlAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();
        await EnsureDesktopAsync();

        return await InvokeTauriAsync<string>(CommandGetWebSocketUrl, ct);
    }

    /// <summary>
    /// Subscribes to server state change events.
    /// Returns subscription ID for unsubscribing.
    /// </summary>
    public async Task<string> SubscribeToServerStateAsync(
        Func<ServerStateEvent, Task> callback,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();
        await EnsureDesktopAsync();

        var subscriptionId = Guid.NewGuid().ToString();
        var handler = new TauriEventHandler<ServerStateEvent>(callback, _logger);
        var dotNetRef = DotNetObjectReference.Create(handler);

        try
        {
            // Register the listener and store unlisten function
            await _js.InvokeVoidAsync(
                "eval",
                ct,
                $@"
                (async () => {{
                    const unlisten = await window.__TAURI__.event.listen(
                        '{EventServerStateChanged}',
                        (event) => DotNet.invokeMethodAsync(
                            '{AssemblyName}',
                            '{HandleEventMethod}',
                            '{subscriptionId}',
                            event.payload
                        )
                    );
                    window.{JsUnlistenersGlobal} = window.{JsUnlistenersGlobal} || {{}};
                    window.{JsUnlistenersGlobal}['{subscriptionId}'] = unlisten;
                }})()
                "
            );

            var subscription = new TauriEventSubscription(
                subscriptionId,
                _js,
                () => _subscriptions.TryRemove(subscriptionId, out _),
                dotNetRef
            );

            _subscriptions[subscriptionId] = subscription;

            _logger.LogDebug("Created server state subscription: {Id}", subscriptionId);
            return subscriptionId;
        }
        catch
        {
            dotNetRef.Dispose();
            throw;
        }
    }

    /// <summary>
    /// Unsubscribes from server state events.
    /// </summary>
    public void Unsubscribe(string subscriptionId)
    {
        if (_subscriptions.TryRemove(subscriptionId, out var subscription))
        {
            subscription.Dispose();
            _logger.LogDebug("Removed subscription: {Id}", subscriptionId);
        }
    }

    /// <summary>
    /// Requests server restart.
    /// </summary>
    public async Task RestartServerAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();
        await EnsureDesktopAsync();

        await InvokeTauriVoidAsync(CommandRestartServer, ct);
        _logger.LogInformation("Server restart requested");
    }

    /// <summary>
    /// Exports diagnostics bundle and returns file path.
    /// </summary>
    public async Task<string> ExportDiagnosticsAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();
        await EnsureDesktopAsync();

        var path = await InvokeTauriAsync<string>(CommandExportDiagnostics, ct);
        _logger.LogInformation("Diagnostics exported to: {Path}", path);
        return path;
    }

    private async Task<T> InvokeTauriAsync<T>(string command, CancellationToken ct)
    {
        return await _js.InvokeAsync<T>(
            TauriInvokePath,
            ct,
            command
        );
    }

    private async Task InvokeTauriVoidAsync(string command, CancellationToken ct)
    {
        await _js.InvokeVoidAsync(
            TauriInvokePath,
            ct,
            command
        );
    }

    private async Task EnsureDesktopAsync()
    {
        if (!await IsDesktopAsync())
        {
            throw new InvalidOperationException(
                "This operation requires Tauri desktop environment");
        }
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(TauriService));
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        // Dispose all subscriptions
        foreach (var kvp in _subscriptions)
        {
            try
            {
                kvp.Value.Dispose();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error disposing subscription {Id}", kvp.Key);
            }
        }

        _subscriptions.Clear();
        _initLock.Dispose();

        _logger.LogDebug("TauriService disposed");
    }
}

/// <summary>
/// Handles Tauri event callbacks from JavaScript.
/// </summary>
internal sealed class TauriEventHandler<T>
{
    private readonly Func<T, Task> _callback;
    private readonly ILogger _logger;

    public TauriEventHandler(Func<T, Task> callback, ILogger logger)
    {
        _callback = callback;
        _logger = logger;
    }

    [JSInvokable]
    public async Task HandleEventAsync(T payload)
    {
        try
        {
            await _callback(payload);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in Tauri event handler");
        }
    }
}

/// <summary>
/// Manages cleanup of Tauri event subscription.
/// </summary>
internal sealed class TauriEventSubscription : IDisposable
{
    private readonly string _subscriptionId;
    private readonly IJSRuntime _js;
    private readonly Action _onDispose;
    private readonly IDisposable _dotNetRef;
    private bool _disposed;

    public TauriEventSubscription(
        string subscriptionId,
        IJSRuntime js,
        Action onDispose,
        IDisposable dotNetRef)
    {
        _subscriptionId = subscriptionId;
        _js = js;
        _onDispose = onDispose;
        _dotNetRef = dotNetRef;
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        // Fire-and-forget unlisten
        // Note: Uses hardcoded global name since this class doesn't have access to TauriService constants
        _ = Task.Run(async () =>
        {
            try
            {
                await _js.InvokeVoidAsync(
                    "eval",
                    $"window.__PM_UNLISTENERS__?.['{_subscriptionId}']?.()"
                );
            }
            catch { /* Best effort cleanup */ }
        });

        _dotNetRef.Dispose();
        _onDispose();
    }
}

/// <summary>
/// Server state event from Tauri backend.
/// </summary>
public sealed record ServerStateEvent
{
    public required string State { get; init; }
    public int? Port { get; init; }
    public string? Error { get; init; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Server status response from Tauri backend.
/// </summary>
public sealed record ServerStatus
{
    public required string State { get; init; }
    public int? Port { get; init; }
    public string? WebSocketUrl { get; init; }
    public bool IsHealthy { get; init; }
    public string? Error { get; init; }
}
```

**Key Patterns Demonstrated:**

1. **Graceful Degradation**: `IsDesktopAsync()` returns false on any error instead of crashing
2. **Resource Tracking**: `ConcurrentDictionary` tracks active subscriptions
3. **Proper Cleanup**: Each subscription cleans up its JS listener on dispose
4. **Type Safety**: C# records for `ServerStatus` and `ServerStateEvent`

---

### Step 2: Create DesktopConfigService with Retry Logic

**Create**: `frontend/ProjectManagement.Services/Desktop/DesktopConfigService.cs`

```csharp
using Microsoft.Extensions.Logging;

namespace ProjectManagement.Services.Desktop;

public interface IDesktopConfigService
{
    Task<bool> IsDesktopModeAsync();
    Task<string> GetWebSocketUrlAsync(CancellationToken ct = default);
    Task WaitForServerAsync(TimeSpan timeout, CancellationToken ct = default);
}

public sealed class DesktopConfigService : IDesktopConfigService, IAsyncDisposable
{
    private readonly TauriService _tauriService;
    private readonly ILogger<DesktopConfigService> _logger;
    private string? _serverStateSubscriptionId;
    private TaskCompletionSource<bool>? _serverReadyTcs;

    // Server state constants
    private const string ServerStateRunning = "running";
    private const string ServerStateFailed = "failed";

    public DesktopConfigService(
        TauriService tauriService,
        ILogger<DesktopConfigService> logger)
    {
        _tauriService = tauriService;
        _logger = logger;
    }

    public async Task<bool> IsDesktopModeAsync()
    {
        return await _tauriService.IsDesktopAsync();
    }

    public async Task<string> GetWebSocketUrlAsync(CancellationToken ct = default)
    {
        return await _tauriService.GetWebSocketUrlAsync(ct);
    }

    public async Task WaitForServerAsync(TimeSpan timeout, CancellationToken ct = default)
    {
        using var timeoutCts = new CancellationTokenSource(timeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, timeoutCts.Token);

        _serverReadyTcs = new TaskCompletionSource<bool>(
            TaskCreationOptions.RunContinuationsAsynchronously);

        try
        {
            // Check current status first
            var status = await _tauriService.GetServerStatusAsync(linkedCts.Token);
            if (status.State == ServerStateRunning && status.IsHealthy)
            {
                _logger.LogInformation("Server already running on port {Port}", status.Port);
                return;
            }

            // Subscribe to state changes
            _serverStateSubscriptionId = await _tauriService.SubscribeToServerStateAsync(
                OnServerStateChangedAsync,
                linkedCts.Token);

            // Wait for server ready
            using (linkedCts.Token.Register(() =>
            {
                if (timeoutCts.IsCancellationRequested)
                    _serverReadyTcs.TrySetException(new TimeoutException("Server startup timed out"));
                else
                    _serverReadyTcs.TrySetCanceled(ct);
            }))
            {
                await _serverReadyTcs.Task;
            }
        }
        finally
        {
            // Cleanup subscription
            if (_serverStateSubscriptionId != null)
            {
                _tauriService.Unsubscribe(_serverStateSubscriptionId);
                _serverStateSubscriptionId = null;
            }
        }
    }

    private Task OnServerStateChangedAsync(ServerStateEvent evt)
    {
        _logger.LogDebug("Server state changed: {State}", evt.State);

        switch (evt.State)
        {
            case ServerStateRunning:
                _serverReadyTcs?.TrySetResult(true);
                break;

            case ServerStateFailed:
                var error = new Exception(evt.Error ?? "Server failed to start");
                _serverReadyTcs?.TrySetException(error);
                break;
        }

        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (_serverStateSubscriptionId != null)
        {
            _tauriService.Unsubscribe(_serverStateSubscriptionId);
        }

        await _tauriService.DisposeAsync();
    }
}
```

**Key Patterns Demonstrated:**

1. **Linked Cancellation Tokens**: Combines user cancellation with timeout
2. **TaskCompletionSource**: Converts event-based API to async/await
3. **RunContinuationsAsynchronously**: Prevents deadlocks in callbacks
4. **Proper Cleanup**: Always unsubscribes, even on error

---

### Step 3: Register Services in DI

**File**: `frontend/ProjectManagement.Wasm/Program.cs`

Add service registrations:

```csharp
builder.Services.AddScoped<TauriService>();
builder.Services.AddScoped<IDesktopConfigService, DesktopConfigService>();
builder.Services.AddScoped<UserIdentityService>();
```

---

### Step 4: Delete JavaScript Files

**Delete**: `desktop/frontend/wwwroot/js/desktop-interop.js`

```bash
rm desktop/frontend/wwwroot/js/desktop-interop.js
# or
rmdir desktop/frontend/wwwroot/js  # if directory is now empty
```

---

### Step 5: Update index.html

**File**: `desktop/frontend/wwwroot/index.html`

Remove the script tag that loaded the JavaScript:

```html
<!-- REMOVE THIS LINE -->
<script src="js/desktop-interop.js"></script>
```

The only script remaining should be the Blazor bootstrap:

```html
<script src="_framework/blazor.webassembly.js"></script>
```

---

## Session 42.3 Completion Checklist

After completing all steps:

- [x] `dotnet build frontend/ProjectManagement.sln` passes
- [x] No JavaScript files in `wwwroot/js/`
- [x] `index.html` only loads `blazor.webassembly.js`
- [ ] `cd desktop && cargo tauri dev` - no JS errors in console (pending Session 42.4 - desktop app not ready)
- [x] Services registered in DI container

### Files Created (5)
- `frontend/ProjectManagement.Services/Desktop/TauriService.cs` (253 lines)
- `frontend/ProjectManagement.Services/Desktop/TauriEventSubscription.cs` (45 lines)
- `frontend/ProjectManagement.Services/Desktop/ServerStateEvent.cs` (11 lines)
- `frontend/ProjectManagement.Services/Desktop/IDesktopConfigService.cs` (7 lines)
- `frontend/ProjectManagement.Services/Desktop/DesktopConfigService.cs` (111 lines)

### Files Deleted (1)
- `frontend/ProjectManagement.Wasm/wwwroot/js/desktop-interop.js`

### Files Modified (3)
- `frontend/ProjectManagement.Services/Desktop/ServerStatus.cs` - Added Port and IsHealthy properties
- `frontend/ProjectManagement.Wasm/wwwroot/index.html` - Already clean (no changes needed)
- `frontend/ProjectManagement.Wasm/Program.cs` - Registered services with interfaces

### Completion Notes (2026-01-22)

**What was delivered:**
- ✅ Type-safe C# wrapper for Tauri IPC (zero JavaScript dependencies)
- ✅ Production-grade async disposal pattern (IAsyncDisposable throughout)
- ✅ Proper resource management with awaited cleanup (no fire-and-forget hacks)
- ✅ Interface-based DI registration for better testability
- ✅ Better file organization (extracted classes to separate files)
- ✅ WaitForServerAsync returns URL (Task<string> instead of void)
- ✅ All tests passing, build clean with 0 warnings

**Quality improvements beyond original plan:**
- Used `IAsyncDisposable` instead of `IDisposable` with fire-and-forget cleanup
- Properly awaited all JS cleanup instead of Task.Run hacks
- Extracted interface and helper classes to separate files for better organization
- Fixed return type of `WaitForServerAsync` to return WebSocket URL

**Verification:** ✅ Build succeeded (0 warnings, 0 errors), all tests passing

---

## Key Concepts Learned

1. **Direct Tauri Invocation** - Call `__TAURI__.core.invoke` directly from C#
2. **Event Subscription Cleanup** - Track subscriptions and clean up on dispose
3. **Graceful Degradation** - Return safe defaults when APIs aren't available
4. **TaskCompletionSource** - Bridge between event-based and async/await patterns

---

## Before/After Comparison

**Before (JavaScript):**
```javascript
// desktop-interop.js - 30 lines
window.DesktopInterop = {
    getServerStatus: () => window.__TAURI__.invoke('get_server_status'),
    // ... more wrappers
};
```

**After (C#):**
```csharp
// TauriService.cs - type-safe, disposable, with error handling
public async Task<ServerStatus> GetServerStatusAsync(CancellationToken ct = default)
{
    ThrowIfDisposed();
    await EnsureDesktopAsync();
    return await InvokeTauriAsync<ServerStatus>("get_server_status", ct);
}
```

**Benefits:**
- Compile-time type checking
- Proper async/await with cancellation
- Resource cleanup via IAsyncDisposable
- All code in one language

---

## Next Session

**Session 42.4** will implement:
- App.razor rewrite with state machine
- StartupScreen component
- UserRegistrationScreen component
- ErrorScreen component
