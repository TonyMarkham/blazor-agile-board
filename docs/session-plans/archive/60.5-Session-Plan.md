# Session 60.5: Tests & Integration Verification ✅

**Status**: Complete (2026-01-27)
**Parent Plan**: `60-Session-Plan.md`
**Prerequisite**: Sessions 60.1-60.4 completed
**Actual Usage**: ~66k tokens (initial + compacted continuation)

---

## Completion Summary

**Delivered:**
- ✅ 6 test files created (2 backend Rust, 4 frontend C#)
- ✅ 51 new tests implemented (21 backend, 30 frontend)
- ✅ All 649 tests passing (100% pass rate)
- ✅ 0 warnings, 0 errors across entire workspace
- ✅ Integration verification checklist provided

**Test Coverage:**
| Category | New Tests | Total Tests |
|----------|-----------|-------------|
| Backend time_entry_handler_tests.rs | 11 | 229 total backend |
| Backend dependency_handler_tests.rs | 10 | 229 total backend |
| Frontend TimeEntryConverterTests.cs | 8 | 50 total Core |
| Frontend DependencyConverterTests.cs | 5 | 50 total Core |
| Frontend TimeEntryStoreTests.cs | 7 | 93 total Services |
| Frontend DependencyStoreTests.cs | 10 | 93 total Services |
| **Session 60.5 Total** | **51** | **649 workspace** |

**Key Implementations:**
1. Backend integration tests using `dispatch()` pattern with `WebSocketMessage` wrappers
2. Protobuf optional field handling (Rust: `.is_some()`/`.is_none()`, C#: `Has*` properties)
3. Store tests with `Mock.Raise()` for WebSocket event simulation
4. AppState sealed class pattern (create real instance with mocked dependencies)
5. Async test pattern with `await Task.Delay()` for optimistic update testing

---

## Scope

This session implements comprehensive tests and verifies end-to-end integration:

1. **Backend Time Entry Tests** - Handler tests for timer operations
2. **Backend Dependency Tests** - Handler tests including cycle detection
3. **Frontend Converter Tests** - Proto conversion tests
4. **Frontend Store Tests** - State management tests with mocks
5. **Integration Verification** - Manual testing checklist

---

## Prerequisites Check

Before starting, verify all previous sessions are complete:

```bash
just check      # All code compiles
just build-frontend  # Frontend builds
```

Ensure these exist:
- `pm-ws/src/handlers/time_entry.rs` with 7 handlers
- `pm-ws/src/handlers/dependency.rs` with 3 handlers
- `TimeEntryStore.cs` and `DependencyStore.cs` implementations
- UI components: `TimerWidget.razor`, `BlockedIndicator.razor`

---

## Implementation Order

### Step 1: Create Time Entry Handler Tests

**Create**: `backend/crates/pm-ws/tests/time_entry_handler_tests.rs`

```rust
//! Tests for time entry handlers.
//!
//! Tests cover:
//! - Timer start/stop operations
//! - Atomic timer switching
//! - Owner-only enforcement
//! - Timestamp validation
//! - Pagination

use chrono::Utc;
use pm_core::{TimeEntry, WorkItem, WorkItemType};
use pm_db::{TimeEntryRepository, WorkItemRepository};
use pm_proto::{
    web_socket_message::Payload, CreateTimeEntryRequest, DeleteTimeEntryRequest,
    GetRunningTimerRequest, GetTimeEntriesRequest, StartTimerRequest, StopTimerRequest,
    WebSocketMessage,
};
use pm_ws::handlers::{context::HandlerContext, time_entry::*};
use sqlx::SqlitePool;
use std::sync::Arc;
use uuid::Uuid;

mod common;
use common::test_fixtures::*;

// =============================================================================
// Test Fixtures
// =============================================================================

async fn setup_test_db() -> SqlitePool {
    let pool = SqlitePool::connect(":memory:").await.unwrap();
    sqlx::migrate!("../pm-db/migrations").run(&pool).await.unwrap();
    pool
}

async fn create_test_project(pool: &SqlitePool, user_id: Uuid) -> WorkItem {
    let project = WorkItem::new_project("Test Project", user_id);
    WorkItemRepository::new(pool.clone()).create(&project).await.unwrap();
    project
}

async fn create_test_task(pool: &SqlitePool, project: &WorkItem, user_id: Uuid) -> WorkItem {
    let task = WorkItem::new_task("Test Task", project.id, project.id, user_id);
    WorkItemRepository::new(pool.clone()).create(&task).await.unwrap();
    task
}

fn create_test_context(pool: SqlitePool, user_id: Uuid) -> HandlerContext {
    HandlerContext::new(
        Uuid::new_v4().to_string(),
        user_id,
        pool,
        Arc::new(pm_ws::CircuitBreaker::new(Default::default())),
        "test-conn".to_string(),
    )
}

// =============================================================================
// StartTimer Tests
// =============================================================================

#[tokio::test]
async fn test_start_timer_creates_running_entry() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;
    let ctx = create_test_context(pool.clone(), user_id);

    let req = StartTimerRequest {
        work_item_id: task.id.to_string(),
        description: Some("Working on tests".to_string()),
    };

    // When
    let response = handle_start_timer(req, ctx).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::TimerStarted(started)) => {
            assert!(started.time_entry.is_some());
            let entry = started.time_entry.unwrap();
            assert_eq!(entry.work_item_id, task.id.to_string());
            assert_eq!(entry.user_id, user_id.to_string());
            assert!(entry.ended_at.is_none()); // Running
            assert_eq!(entry.description, Some("Working on tests".to_string()));
            assert!(started.stopped_entry.is_none()); // No previous timer
        }
        _ => panic!("Expected TimerStarted response"),
    }
}

#[tokio::test]
async fn test_start_timer_auto_stops_previous_timer() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task1 = create_test_task(&pool, &project, user_id).await;
    let task2 = create_test_task(&pool, &project, user_id).await;

    // Start first timer
    let ctx1 = create_test_context(pool.clone(), user_id);
    let req1 = StartTimerRequest {
        work_item_id: task1.id.to_string(),
        description: None,
    };
    let first_response = handle_start_timer(req1, ctx1).await.unwrap();
    let first_entry_id = match &first_response.payload {
        Some(Payload::TimerStarted(s)) => s.time_entry.as_ref().unwrap().id.clone(),
        _ => panic!("Expected TimerStarted"),
    };

    // When - Start second timer
    let ctx2 = create_test_context(pool.clone(), user_id);
    let req2 = StartTimerRequest {
        work_item_id: task2.id.to_string(),
        description: None,
    };
    let response = handle_start_timer(req2, ctx2).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::TimerStarted(started)) => {
            // New timer started
            assert!(started.time_entry.is_some());
            let new_entry = started.time_entry.unwrap();
            assert_eq!(new_entry.work_item_id, task2.id.to_string());
            assert!(new_entry.ended_at.is_none()); // Running

            // Previous timer stopped
            assert!(started.stopped_entry.is_some());
            let stopped = started.stopped_entry.unwrap();
            assert_eq!(stopped.id, first_entry_id);
            assert!(stopped.ended_at.is_some()); // Now stopped
            assert!(stopped.duration_seconds.is_some());
        }
        _ => panic!("Expected TimerStarted response"),
    }
}

#[tokio::test]
async fn test_start_timer_validates_work_item_exists() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let ctx = create_test_context(pool.clone(), user_id);

    let req = StartTimerRequest {
        work_item_id: Uuid::new_v4().to_string(), // Non-existent
        description: None,
    };

    // When
    let result = handle_start_timer(req, ctx).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("not found"));
}

// =============================================================================
// StopTimer Tests
// =============================================================================

#[tokio::test]
async fn test_stop_timer_calculates_duration() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;

    // Start a timer
    let ctx1 = create_test_context(pool.clone(), user_id);
    let start_req = StartTimerRequest {
        work_item_id: task.id.to_string(),
        description: None,
    };
    let start_response = handle_start_timer(start_req, ctx1).await.unwrap();
    let entry_id = match &start_response.payload {
        Some(Payload::TimerStarted(s)) => s.time_entry.as_ref().unwrap().id.clone(),
        _ => panic!("Expected TimerStarted"),
    };

    // Small delay to ensure measurable duration
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    // When - Stop the timer
    let ctx2 = create_test_context(pool.clone(), user_id);
    let stop_req = StopTimerRequest {
        time_entry_id: entry_id.clone(),
    };
    let response = handle_stop_timer(stop_req, ctx2).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::TimerStopped(stopped)) => {
            let entry = stopped.time_entry.unwrap();
            assert_eq!(entry.id, entry_id);
            assert!(entry.ended_at.is_some());
            assert!(entry.duration_seconds.is_some());
            assert!(entry.duration_seconds.unwrap() >= 0);
        }
        _ => panic!("Expected TimerStopped response"),
    }
}

#[tokio::test]
async fn test_stop_timer_owner_only() {
    // Given
    let pool = setup_test_db().await;
    let owner_id = Uuid::new_v4();
    let other_user_id = Uuid::new_v4();
    let project = create_test_project(&pool, owner_id).await;
    let task = create_test_task(&pool, &project, owner_id).await;

    // Owner starts timer
    let ctx1 = create_test_context(pool.clone(), owner_id);
    let start_req = StartTimerRequest {
        work_item_id: task.id.to_string(),
        description: None,
    };
    let start_response = handle_start_timer(start_req, ctx1).await.unwrap();
    let entry_id = match &start_response.payload {
        Some(Payload::TimerStarted(s)) => s.time_entry.as_ref().unwrap().id.clone(),
        _ => panic!("Expected TimerStarted"),
    };

    // When - Other user tries to stop
    let ctx2 = create_test_context(pool.clone(), other_user_id);
    let stop_req = StopTimerRequest {
        time_entry_id: entry_id,
    };
    let result = handle_stop_timer(stop_req, ctx2).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("another user"));
}

#[tokio::test]
async fn test_stop_timer_already_stopped_fails() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;

    // Start and stop a timer
    let ctx1 = create_test_context(pool.clone(), user_id);
    let start_req = StartTimerRequest {
        work_item_id: task.id.to_string(),
        description: None,
    };
    let start_response = handle_start_timer(start_req, ctx1).await.unwrap();
    let entry_id = match &start_response.payload {
        Some(Payload::TimerStarted(s)) => s.time_entry.as_ref().unwrap().id.clone(),
        _ => panic!("Expected TimerStarted"),
    };

    let ctx2 = create_test_context(pool.clone(), user_id);
    handle_stop_timer(StopTimerRequest { time_entry_id: entry_id.clone() }, ctx2)
        .await
        .unwrap();

    // When - Try to stop again
    let ctx3 = create_test_context(pool.clone(), user_id);
    let result = handle_stop_timer(StopTimerRequest { time_entry_id: entry_id }, ctx3).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("not running"));
}

// =============================================================================
// CreateTimeEntry Tests
// =============================================================================

#[tokio::test]
async fn test_create_manual_entry_validates_timestamps() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;
    let ctx = create_test_context(pool.clone(), user_id);

    let now = Utc::now().timestamp();
    let req = CreateTimeEntryRequest {
        work_item_id: task.id.to_string(),
        started_at: now - 3600, // 1 hour ago
        ended_at: now - 1800,   // 30 minutes ago
        description: Some("Manual entry".to_string()),
    };

    // When
    let response = handle_create_time_entry(req, ctx).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::TimeEntryCreated(created)) => {
            let entry = created.time_entry.unwrap();
            assert_eq!(entry.duration_seconds, Some(1800)); // 30 minutes
        }
        _ => panic!("Expected TimeEntryCreated response"),
    }
}

#[tokio::test]
async fn test_create_manual_entry_rejects_future_timestamps() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;
    let ctx = create_test_context(pool.clone(), user_id);

    let future = Utc::now().timestamp() + 3600; // 1 hour in future
    let req = CreateTimeEntryRequest {
        work_item_id: task.id.to_string(),
        started_at: future,
        ended_at: future + 1800,
        description: None,
    };

    // When
    let result = handle_create_time_entry(req, ctx).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("future"));
}

#[tokio::test]
async fn test_create_manual_entry_rejects_excessive_duration() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;
    let ctx = create_test_context(pool.clone(), user_id);

    let now = Utc::now().timestamp();
    let req = CreateTimeEntryRequest {
        work_item_id: task.id.to_string(),
        started_at: now - 100000, // More than 24 hours
        ended_at: now,
        description: None,
    };

    // When
    let result = handle_create_time_entry(req, ctx).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("24 hours") || err.to_string().contains("Duration"));
}

// =============================================================================
// GetTimeEntries Tests
// =============================================================================

#[tokio::test]
async fn test_get_time_entries_pagination() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id).await;

    // Create 5 entries
    let now = Utc::now().timestamp();
    for i in 0..5 {
        let ctx = create_test_context(pool.clone(), user_id);
        let req = CreateTimeEntryRequest {
            work_item_id: task.id.to_string(),
            started_at: now - (i + 1) * 7200,
            ended_at: now - i * 7200,
            description: Some(format!("Entry {}", i)),
        };
        handle_create_time_entry(req, ctx).await.unwrap();
    }

    // When - Get first page
    let ctx = create_test_context(pool.clone(), user_id);
    let req = GetTimeEntriesRequest {
        work_item_id: task.id.to_string(),
        limit: Some(2),
        offset: Some(0),
    };
    let response = handle_get_time_entries(req, ctx).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::TimeEntriesList(list)) => {
            assert_eq!(list.time_entries.len(), 2);
            assert_eq!(list.total_count, 5);
        }
        _ => panic!("Expected TimeEntriesList response"),
    }
}

// =============================================================================
// GetRunningTimer Tests
// =============================================================================

#[tokio::test]
async fn test_get_running_timer_returns_current_user_timer_only() {
    // Given
    let pool = setup_test_db().await;
    let user1 = Uuid::new_v4();
    let user2 = Uuid::new_v4();
    let project = create_test_project(&pool, user1).await;
    let task = create_test_task(&pool, &project, user1).await;

    // User1 starts a timer
    let ctx1 = create_test_context(pool.clone(), user1);
    let start_req = StartTimerRequest {
        work_item_id: task.id.to_string(),
        description: None,
    };
    handle_start_timer(start_req, ctx1).await.unwrap();

    // When - User2 checks for running timer
    let ctx2 = create_test_context(pool.clone(), user2);
    let response = handle_get_running_timer(GetRunningTimerRequest {}, ctx2).await.unwrap();

    // Then - User2 should have no running timer
    match response.payload {
        Some(Payload::RunningTimerResponse(r)) => {
            assert!(r.time_entry.is_none());
        }
        _ => panic!("Expected RunningTimerResponse"),
    }

    // And - User1 should have their timer
    let ctx1b = create_test_context(pool.clone(), user1);
    let response1 = handle_get_running_timer(GetRunningTimerRequest {}, ctx1b).await.unwrap();

    match response1.payload {
        Some(Payload::RunningTimerResponse(r)) => {
            assert!(r.time_entry.is_some());
        }
        _ => panic!("Expected RunningTimerResponse"),
    }
}
```

**Verification**: `just test-rs-ws`

---

### Step 2: Create Dependency Handler Tests

**Create**: `backend/crates/pm-ws/tests/dependency_handler_tests.rs`

```rust
//! Tests for dependency handlers.
//!
//! Tests cover:
//! - Dependency creation with validation
//! - Self-reference rejection
//! - Duplicate rejection
//! - Circular dependency detection
//! - Same-project enforcement
//! - Limit enforcement

use pm_core::{Dependency, DependencyType, WorkItem};
use pm_db::{DependencyRepository, WorkItemRepository};
use pm_proto::{
    web_socket_message::Payload, CreateDependencyRequest, DeleteDependencyRequest,
    DependencyType as ProtoDependencyType, GetDependenciesRequest, WebSocketMessage,
};
use pm_ws::handlers::{context::HandlerContext, dependency::*};
use sqlx::SqlitePool;
use std::sync::Arc;
use uuid::Uuid;

mod common;
use common::test_fixtures::*;

// =============================================================================
// Test Fixtures
// =============================================================================

async fn setup_test_db() -> SqlitePool {
    let pool = SqlitePool::connect(":memory:").await.unwrap();
    sqlx::migrate!("../pm-db/migrations").run(&pool).await.unwrap();
    pool
}

async fn create_test_project(pool: &SqlitePool, user_id: Uuid) -> WorkItem {
    let project = WorkItem::new_project("Test Project", user_id);
    WorkItemRepository::new(pool.clone()).create(&project).await.unwrap();
    project
}

async fn create_test_task(pool: &SqlitePool, project: &WorkItem, user_id: Uuid, name: &str) -> WorkItem {
    let task = WorkItem::new_task(name, project.id, project.id, user_id);
    WorkItemRepository::new(pool.clone()).create(&task).await.unwrap();
    task
}

fn create_test_context(pool: SqlitePool, user_id: Uuid) -> HandlerContext {
    HandlerContext::new(
        Uuid::new_v4().to_string(),
        user_id,
        pool,
        Arc::new(pm_ws::CircuitBreaker::new(Default::default())),
        "test-conn".to_string(),
    )
}

// =============================================================================
// CreateDependency Tests
// =============================================================================

#[tokio::test]
async fn test_create_dependency_success() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;
    let ctx = create_test_context(pool.clone(), user_id);

    let req = CreateDependencyRequest {
        blocking_item_id: task_a.id.to_string(),
        blocked_item_id: task_b.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };

    // When
    let response = handle_create_dependency(req, ctx).await.unwrap();

    // Then
    match response.payload {
        Some(Payload::DependencyCreated(created)) => {
            let dep = created.dependency.unwrap();
            assert_eq!(dep.blocking_item_id, task_a.id.to_string());
            assert_eq!(dep.blocked_item_id, task_b.id.to_string());
            assert_eq!(dep.dependency_type, ProtoDependencyType::Blocks as i32);
        }
        _ => panic!("Expected DependencyCreated response"),
    }
}

#[tokio::test]
async fn test_create_dependency_self_reference_rejected() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task = create_test_task(&pool, &project, user_id, "Task").await;
    let ctx = create_test_context(pool.clone(), user_id);

    let req = CreateDependencyRequest {
        blocking_item_id: task.id.to_string(),
        blocked_item_id: task.id.to_string(), // Same item!
        dependency_type: ProtoDependencyType::Blocks as i32,
    };

    // When
    let result = handle_create_dependency(req, ctx).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("cannot block itself"));
}

#[tokio::test]
async fn test_create_dependency_duplicate_rejected() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;

    // Create first dependency
    let ctx1 = create_test_context(pool.clone(), user_id);
    let req1 = CreateDependencyRequest {
        blocking_item_id: task_a.id.to_string(),
        blocked_item_id: task_b.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };
    handle_create_dependency(req1, ctx1).await.unwrap();

    // When - Try to create duplicate
    let ctx2 = create_test_context(pool.clone(), user_id);
    let req2 = CreateDependencyRequest {
        blocking_item_id: task_a.id.to_string(),
        blocked_item_id: task_b.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };
    let result = handle_create_dependency(req2, ctx2).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("already exists"));
}

#[tokio::test]
async fn test_create_dependency_circular_direct_rejected() {
    // Given: A blocks B
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;

    // A blocks B
    let ctx1 = create_test_context(pool.clone(), user_id);
    let req1 = CreateDependencyRequest {
        blocking_item_id: task_a.id.to_string(),
        blocked_item_id: task_b.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };
    handle_create_dependency(req1, ctx1).await.unwrap();

    // When - Try B blocks A (would create cycle)
    let ctx2 = create_test_context(pool.clone(), user_id);
    let req2 = CreateDependencyRequest {
        blocking_item_id: task_b.id.to_string(),
        blocked_item_id: task_a.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };
    let result = handle_create_dependency(req2, ctx2).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("Circular dependency"));
}

#[tokio::test]
async fn test_create_dependency_circular_indirect_rejected() {
    // Given: A blocks B, B blocks C
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;
    let task_c = create_test_task(&pool, &project, user_id, "Task C").await;

    // A blocks B
    let ctx1 = create_test_context(pool.clone(), user_id);
    handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_a.id.to_string(),
            blocked_item_id: task_b.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx1,
    )
    .await
    .unwrap();

    // B blocks C
    let ctx2 = create_test_context(pool.clone(), user_id);
    handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_b.id.to_string(),
            blocked_item_id: task_c.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx2,
    )
    .await
    .unwrap();

    // When - Try C blocks A (would create A→B→C→A cycle)
    let ctx3 = create_test_context(pool.clone(), user_id);
    let req = CreateDependencyRequest {
        blocking_item_id: task_c.id.to_string(),
        blocked_item_id: task_a.id.to_string(),
        dependency_type: ProtoDependencyType::Blocks as i32,
    };
    let result = handle_create_dependency(req, ctx3).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("Circular dependency"));
    // Error should include path information
    assert!(err.to_string().contains("→"));
}

#[tokio::test]
async fn test_create_dependency_relates_to_allows_bidirectional() {
    // Given: A relates_to B
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;

    // A relates_to B
    let ctx1 = create_test_context(pool.clone(), user_id);
    handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_a.id.to_string(),
            blocked_item_id: task_b.id.to_string(),
            dependency_type: ProtoDependencyType::RelatesTo as i32,
        },
        ctx1,
    )
    .await
    .unwrap();

    // When - B relates_to A (bidirectional is OK for RelatesTo)
    let ctx2 = create_test_context(pool.clone(), user_id);
    let result = handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_b.id.to_string(),
            blocked_item_id: task_a.id.to_string(),
            dependency_type: ProtoDependencyType::RelatesTo as i32,
        },
        ctx2,
    )
    .await;

    // Then - Should succeed (RelatesTo doesn't create cycles)
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_create_dependency_cross_project_rejected() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project1 = create_test_project(&pool, user_id).await;
    let project2 = create_test_project(&pool, user_id).await;
    let task1 = create_test_task(&pool, &project1, user_id, "Task in Project 1").await;
    let task2 = create_test_task(&pool, &project2, user_id, "Task in Project 2").await;
    let ctx = create_test_context(pool.clone(), user_id);

    let req = CreateDependencyRequest {
        blocking_item_id: task1.id.to_string(),
        blocked_item_id: task2.id.to_string(), // Different project!
        dependency_type: ProtoDependencyType::Blocks as i32,
    };

    // When
    let result = handle_create_dependency(req, ctx).await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("same project"));
}

#[tokio::test]
async fn test_create_dependency_limit_enforced() {
    // Given - Create many dependencies up to limit
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let blocked_task = create_test_task(&pool, &project, user_id, "Blocked Task").await;

    // Create 50 blocking tasks (at the limit)
    for i in 0..50 {
        let blocking_task = create_test_task(&pool, &project, user_id, &format!("Blocker {}", i)).await;
        let ctx = create_test_context(pool.clone(), user_id);
        handle_create_dependency(
            CreateDependencyRequest {
                blocking_item_id: blocking_task.id.to_string(),
                blocked_item_id: blocked_task.id.to_string(),
                dependency_type: ProtoDependencyType::Blocks as i32,
            },
            ctx,
        )
        .await
        .unwrap();
    }

    // When - Try to create 51st
    let extra_blocker = create_test_task(&pool, &project, user_id, "Extra Blocker").await;
    let ctx = create_test_context(pool.clone(), user_id);
    let result = handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: extra_blocker.id.to_string(),
            blocked_item_id: blocked_task.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx,
    )
    .await;

    // Then
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(err.to_string().contains("50") || err.to_string().contains("max"));
}

// =============================================================================
// DeleteDependency Tests
// =============================================================================

#[tokio::test]
async fn test_delete_dependency_success() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;

    // Create dependency
    let ctx1 = create_test_context(pool.clone(), user_id);
    let create_response = handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_a.id.to_string(),
            blocked_item_id: task_b.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx1,
    )
    .await
    .unwrap();

    let dep_id = match &create_response.payload {
        Some(Payload::DependencyCreated(c)) => c.dependency.as_ref().unwrap().id.clone(),
        _ => panic!("Expected DependencyCreated"),
    };

    // When
    let ctx2 = create_test_context(pool.clone(), user_id);
    let response = handle_delete_dependency(
        DeleteDependencyRequest {
            dependency_id: dep_id.clone(),
        },
        ctx2,
    )
    .await
    .unwrap();

    // Then
    match response.payload {
        Some(Payload::DependencyDeleted(deleted)) => {
            assert_eq!(deleted.dependency_id, dep_id);
            assert_eq!(deleted.blocking_item_id, task_a.id.to_string());
            assert_eq!(deleted.blocked_item_id, task_b.id.to_string());
        }
        _ => panic!("Expected DependencyDeleted response"),
    }
}

// =============================================================================
// GetDependencies Tests
// =============================================================================

#[tokio::test]
async fn test_get_dependencies_returns_both_directions() {
    // Given
    let pool = setup_test_db().await;
    let user_id = Uuid::new_v4();
    let project = create_test_project(&pool, user_id).await;
    let task_a = create_test_task(&pool, &project, user_id, "Task A").await;
    let task_b = create_test_task(&pool, &project, user_id, "Task B").await;
    let task_c = create_test_task(&pool, &project, user_id, "Task C").await;

    // A blocks B
    let ctx1 = create_test_context(pool.clone(), user_id);
    handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_a.id.to_string(),
            blocked_item_id: task_b.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx1,
    )
    .await
    .unwrap();

    // B blocks C
    let ctx2 = create_test_context(pool.clone(), user_id);
    handle_create_dependency(
        CreateDependencyRequest {
            blocking_item_id: task_b.id.to_string(),
            blocked_item_id: task_c.id.to_string(),
            dependency_type: ProtoDependencyType::Blocks as i32,
        },
        ctx2,
    )
    .await
    .unwrap();

    // When - Get dependencies for B
    let ctx3 = create_test_context(pool.clone(), user_id);
    let response = handle_get_dependencies(
        GetDependenciesRequest {
            work_item_id: task_b.id.to_string(),
        },
        ctx3,
    )
    .await
    .unwrap();

    // Then
    match response.payload {
        Some(Payload::DependenciesList(list)) => {
            // B is blocked by A
            assert_eq!(list.blocking.len(), 1);
            assert_eq!(list.blocking[0].blocking_item_id, task_a.id.to_string());

            // B blocks C
            assert_eq!(list.blocked.len(), 1);
            assert_eq!(list.blocked[0].blocked_item_id, task_c.id.to_string());
        }
        _ => panic!("Expected DependenciesList response"),
    }
}
```

**Verification**: `just test-rs-ws`

---

### Step 3: Create Frontend Converter Tests

**Create**: `frontend/ProjectManagement.Core.Tests/Converters/TimeEntryConverterTests.cs`

```csharp
using FluentAssertions;
using ProjectManagement.Core.Converters;
using ProjectManagement.Core.Models;
using Proto = ProjectManagement.Proto;

namespace ProjectManagement.Core.Tests.Converters;

public class TimeEntryConverterTests
{
    [Fact]
    public void ToDomain_ConvertsAllFields()
    {
        // Given
        var proto = new Proto.TimeEntry
        {
            Id = Guid.NewGuid().ToString(),
            WorkItemId = Guid.NewGuid().ToString(),
            UserId = Guid.NewGuid().ToString(),
            StartedAt = DateTimeOffset.UtcNow.AddHours(-1).ToUnixTimeSeconds(),
            EndedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            DurationSeconds = 3600,
            Description = "Test work",
            CreatedAt = DateTimeOffset.UtcNow.AddDays(-1).ToUnixTimeSeconds(),
            UpdatedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        };

        // When
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.Id.ToString().Should().Be(proto.Id);
        result.WorkItemId.ToString().Should().Be(proto.WorkItemId);
        result.UserId.ToString().Should().Be(proto.UserId);
        result.EndedAt.Should().NotBeNull();
        result.DurationSeconds.Should().Be(3600);
        result.Description.Should().Be("Test work");
        result.IsRunning.Should().BeFalse();
    }

    [Fact]
    public void ToDomain_HandlesNullOptionalFields()
    {
        // Given - Proto with no optional fields set
        var proto = new Proto.TimeEntry
        {
            Id = Guid.NewGuid().ToString(),
            WorkItemId = Guid.NewGuid().ToString(),
            UserId = Guid.NewGuid().ToString(),
            StartedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            CreatedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            UpdatedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        };

        // When
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.EndedAt.Should().BeNull();
        result.DurationSeconds.Should().BeNull();
        result.Description.Should().BeNull();
        result.DeletedAt.Should().BeNull();
        result.IsRunning.Should().BeTrue();
    }

    [Fact]
    public void ToProto_ConvertsAllFields()
    {
        // Given
        var entry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = Guid.NewGuid(),
            UserId = Guid.NewGuid(),
            StartedAt = DateTime.UtcNow.AddHours(-1),
            EndedAt = DateTime.UtcNow,
            DurationSeconds = 3600,
            Description = "Test",
            CreatedAt = DateTime.UtcNow.AddDays(-1),
            UpdatedAt = DateTime.UtcNow,
        };

        // When
        var result = ProtoConverter.ToProto(entry);

        // Then
        result.Id.Should().Be(entry.Id.ToString());
        result.HasEndedAt.Should().BeTrue();
        result.HasDurationSeconds.Should().BeTrue();
        result.DurationSeconds.Should().Be(3600);
        result.HasDescription.Should().BeTrue();
    }

    [Fact]
    public void RoundTrip_PreservesData()
    {
        // Given
        var original = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = Guid.NewGuid(),
            UserId = Guid.NewGuid(),
            StartedAt = new DateTime(2024, 1, 15, 10, 0, 0, DateTimeKind.Utc),
            EndedAt = new DateTime(2024, 1, 15, 11, 30, 0, DateTimeKind.Utc),
            DurationSeconds = 5400,
            Description = "Round trip test",
            CreatedAt = new DateTime(2024, 1, 15, 9, 0, 0, DateTimeKind.Utc),
            UpdatedAt = new DateTime(2024, 1, 15, 11, 30, 0, DateTimeKind.Utc),
        };

        // When
        var proto = ProtoConverter.ToProto(original);
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.Id.Should().Be(original.Id);
        result.WorkItemId.Should().Be(original.WorkItemId);
        result.DurationSeconds.Should().Be(original.DurationSeconds);
        result.Description.Should().Be(original.Description);
    }

    [Fact]
    public void ToDomain_ThrowsOnNull()
    {
        // Given
        Proto.TimeEntry? proto = null;

        // When/Then
        FluentActions.Invoking(() => ProtoConverter.ToDomain(proto!))
            .Should().Throw<ArgumentNullException>();
    }

    [Fact]
    public void TimeEntry_Elapsed_CalculatesCorrectly_ForStoppedEntry()
    {
        // Given
        var entry = new TimeEntry
        {
            StartedAt = DateTime.UtcNow.AddHours(-2),
            EndedAt = DateTime.UtcNow.AddHours(-1),
            DurationSeconds = 3600,
        };

        // When
        var elapsed = entry.Elapsed;

        // Then
        elapsed.TotalSeconds.Should().Be(3600);
    }

    [Fact]
    public void TimeEntry_IsRunning_TrueWhenNoEndedAt()
    {
        // Given
        var entry = new TimeEntry
        {
            StartedAt = DateTime.UtcNow,
            EndedAt = null,
            DeletedAt = null,
        };

        // Then
        entry.IsRunning.Should().BeTrue();
    }

    [Fact]
    public void TimeEntry_IsRunning_FalseWhenDeleted()
    {
        // Given
        var entry = new TimeEntry
        {
            StartedAt = DateTime.UtcNow,
            EndedAt = null,
            DeletedAt = DateTime.UtcNow, // Deleted
        };

        // Then
        entry.IsRunning.Should().BeFalse();
    }
}
```

**Create**: `frontend/ProjectManagement.Core.Tests/Converters/DependencyConverterTests.cs`

```csharp
using FluentAssertions;
using ProjectManagement.Core.Converters;
using ProjectManagement.Core.Models;
using Proto = ProjectManagement.Proto;

namespace ProjectManagement.Core.Tests.Converters;

public class DependencyConverterTests
{
    [Fact]
    public void ToDomain_ConvertsAllFields()
    {
        // Given
        var proto = new Proto.Dependency
        {
            Id = Guid.NewGuid().ToString(),
            BlockingItemId = Guid.NewGuid().ToString(),
            BlockedItemId = Guid.NewGuid().ToString(),
            DependencyType = Proto.DependencyType.Blocks,
            CreatedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            CreatedBy = Guid.NewGuid().ToString(),
        };

        // When
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.Id.ToString().Should().Be(proto.Id);
        result.BlockingItemId.ToString().Should().Be(proto.BlockingItemId);
        result.BlockedItemId.ToString().Should().Be(proto.BlockedItemId);
        result.Type.Should().Be(DependencyType.Blocks);
        result.DeletedAt.Should().BeNull();
    }

    [Fact]
    public void ToDomain_HandlesRelatesTo()
    {
        // Given
        var proto = new Proto.Dependency
        {
            Id = Guid.NewGuid().ToString(),
            BlockingItemId = Guid.NewGuid().ToString(),
            BlockedItemId = Guid.NewGuid().ToString(),
            DependencyType = Proto.DependencyType.RelatesTo,
            CreatedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            CreatedBy = Guid.NewGuid().ToString(),
        };

        // When
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.Type.Should().Be(DependencyType.RelatesTo);
    }

    [Fact]
    public void ToProto_ConvertsAllFields()
    {
        // Given
        var dep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = Guid.NewGuid(),
            Type = DependencyType.Blocks,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = Guid.NewGuid(),
        };

        // When
        var result = ProtoConverter.ToProto(dep);

        // Then
        result.Id.Should().Be(dep.Id.ToString());
        result.DependencyType.Should().Be(Proto.DependencyType.Blocks);
    }

    [Fact]
    public void RoundTrip_PreservesData()
    {
        // Given
        var original = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = Guid.NewGuid(),
            Type = DependencyType.RelatesTo,
            CreatedAt = new DateTime(2024, 1, 15, 10, 0, 0, DateTimeKind.Utc),
            CreatedBy = Guid.NewGuid(),
        };

        // When
        var proto = ProtoConverter.ToProto(original);
        var result = ProtoConverter.ToDomain(proto);

        // Then
        result.Id.Should().Be(original.Id);
        result.BlockingItemId.Should().Be(original.BlockingItemId);
        result.BlockedItemId.Should().Be(original.BlockedItemId);
        result.Type.Should().Be(original.Type);
    }

    [Fact]
    public void DependencyType_Conversion_AllValues()
    {
        // Test all enum values round-trip correctly
        ProtoConverter.ToDomain(Proto.DependencyType.Blocks).Should().Be(DependencyType.Blocks);
        ProtoConverter.ToDomain(Proto.DependencyType.RelatesTo).Should().Be(DependencyType.RelatesTo);

        ProtoConverter.ToProto(DependencyType.Blocks).Should().Be(Proto.DependencyType.Blocks);
        ProtoConverter.ToProto(DependencyType.RelatesTo).Should().Be(Proto.DependencyType.RelatesTo);
    }
}
```

**Verification**: `just test-cs-core`

---

### Step 4: Create Store Tests

**Create**: `frontend/ProjectManagement.Services.Tests/State/TimeEntryStoreTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using ProjectManagement.Core.Interfaces;
using ProjectManagement.Core.Models;
using ProjectManagement.Services.State;

namespace ProjectManagement.Services.Tests.State;

public class TimeEntryStoreTests
{
    private readonly Mock<IWebSocketClient> _mockClient;
    private readonly Mock<IAppState> _mockAppState;
    private readonly Mock<ILogger<TimeEntryStore>> _mockLogger;
    private readonly Guid _currentUserId = Guid.NewGuid();

    public TimeEntryStoreTests()
    {
        _mockClient = new Mock<IWebSocketClient>();
        _mockAppState = new Mock<IAppState>();
        _mockAppState.Setup(a => a.CurrentUserId).Returns(_currentUserId);
        _mockLogger = new Mock<ILogger<TimeEntryStore>>();
    }

    private TimeEntryStore CreateStore() =>
        new(_mockClient.Object, _mockAppState.Object, _mockLogger.Object);

    [Fact]
    public async Task StartTimerAsync_CreatesOptimisticEntry()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();
        var request = new StartTimerRequest { WorkItemId = workItemId };

        var serverEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow,
        };

        _mockClient
            .Setup(c => c.StartTimerAsync(request, It.IsAny<CancellationToken>()))
            .ReturnsAsync((serverEntry, null));

        // When
        var result = await store.StartTimerAsync(request);

        // Then
        result.Id.Should().Be(serverEntry.Id);
        store.GetRunningTimer().Should().NotBeNull();
        store.GetRunningTimer()!.Id.Should().Be(serverEntry.Id);
    }

    [Fact]
    public async Task StartTimerAsync_ServerFailure_RollsBack()
    {
        // Given
        var store = CreateStore();
        var request = new StartTimerRequest { WorkItemId = Guid.NewGuid() };

        _mockClient
            .Setup(c => c.StartTimerAsync(request, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new Exception("Server error"));

        // When/Then
        await FluentActions.Invoking(() => store.StartTimerAsync(request))
            .Should().ThrowAsync<Exception>();

        // Running timer should be null after rollback
        store.GetRunningTimer().Should().BeNull();
    }

    [Fact]
    public async Task StopTimerAsync_UpdatesRunningTimer()
    {
        // Given
        var store = CreateStore();
        var entryId = Guid.NewGuid();
        var workItemId = Guid.NewGuid();

        // First start a timer
        var runningEntry = new TimeEntry
        {
            Id = entryId,
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow,
        };

        _mockClient
            .Setup(c => c.StartTimerAsync(It.IsAny<StartTimerRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((runningEntry, null));

        await store.StartTimerAsync(new StartTimerRequest { WorkItemId = workItemId });

        // Setup stop response
        var stoppedEntry = runningEntry with
        {
            EndedAt = DateTime.UtcNow,
            DurationSeconds = 60,
        };

        _mockClient
            .Setup(c => c.StopTimerAsync(entryId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(stoppedEntry);

        // When
        var result = await store.StopTimerAsync(entryId);

        // Then
        result.EndedAt.Should().NotBeNull();
        result.DurationSeconds.Should().Be(60);
        store.GetRunningTimer().Should().BeNull();
    }

    [Fact]
    public void GetByWorkItem_FiltersDeleted()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();

        // Manually add entries (simulating server data)
        var activeEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow.AddHours(-1),
            EndedAt = DateTime.UtcNow,
            DurationSeconds = 3600,
        };

        var deletedEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow.AddHours(-2),
            EndedAt = DateTime.UtcNow.AddHours(-1),
            DurationSeconds = 3600,
            DeletedAt = DateTime.UtcNow, // Deleted
        };

        // Simulate adding via event handlers
        store.GetType()
            .GetMethod("HandleTimeEntryCreated", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!
            .Invoke(store, new object[] { activeEntry });

        store.GetType()
            .GetMethod("HandleTimeEntryCreated", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!
            .Invoke(store, new object[] { deletedEntry });

        // When
        var results = store.GetByWorkItem(workItemId);

        // Then - Only active entry should be returned
        results.Should().HaveCount(1);
        results[0].Id.Should().Be(activeEntry.Id);
    }

    [Fact]
    public void GetByWorkItem_OrdersByStartedAtDescending()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();

        var oldEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow.AddHours(-2),
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
        };

        var newEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            WorkItemId = workItemId,
            UserId = _currentUserId,
            StartedAt = DateTime.UtcNow.AddHours(-1),
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
        };

        // Add in wrong order
        store.GetType()
            .GetMethod("HandleTimeEntryCreated", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!
            .Invoke(store, new object[] { oldEntry });
        store.GetType()
            .GetMethod("HandleTimeEntryCreated", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!
            .Invoke(store, new object[] { newEntry });

        // When
        var results = store.GetByWorkItem(workItemId);

        // Then - Should be ordered most recent first
        results[0].Id.Should().Be(newEntry.Id);
        results[1].Id.Should().Be(oldEntry.Id);
    }

    [Fact]
    public void IsPending_ReflectsPendingState()
    {
        // Given
        var store = CreateStore();
        var entryId = Guid.NewGuid();

        // Initially not pending
        store.IsPending(entryId).Should().BeFalse();
    }

    [Fact]
    public void Dispose_UnsubscribesFromEvents()
    {
        // Given
        var store = CreateStore();

        // When
        store.Dispose();

        // Then - Should not throw when events fire
        _mockClient.Raise(c => c.OnTimerStarted += null!,
            new TimeEntry { Id = Guid.NewGuid() }, (TimeEntry?)null);
    }
}
```

**Create**: `frontend/ProjectManagement.Services.Tests/State/DependencyStoreTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using ProjectManagement.Core.Interfaces;
using ProjectManagement.Core.Models;
using ProjectManagement.Services.State;

namespace ProjectManagement.Services.Tests.State;

public class DependencyStoreTests
{
    private readonly Mock<IWebSocketClient> _mockClient;
    private readonly Mock<IAppState> _mockAppState;
    private readonly Mock<ILogger<DependencyStore>> _mockLogger;
    private readonly Guid _currentUserId = Guid.NewGuid();

    public DependencyStoreTests()
    {
        _mockClient = new Mock<IWebSocketClient>();
        _mockAppState = new Mock<IAppState>();
        _mockAppState.Setup(a => a.CurrentUserId).Returns(_currentUserId);
        _mockLogger = new Mock<ILogger<DependencyStore>>();
    }

    private DependencyStore CreateStore() =>
        new(_mockClient.Object, _mockAppState.Object, _mockLogger.Object);

    [Fact]
    public async Task CreateAsync_AddsToStore()
    {
        // Given
        var store = CreateStore();
        var request = new CreateDependencyRequest
        {
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = Guid.NewGuid(),
            Type = DependencyType.Blocks,
        };

        var serverDep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = request.BlockingItemId,
            BlockedItemId = request.BlockedItemId,
            Type = DependencyType.Blocks,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = _currentUserId,
        };

        _mockClient
            .Setup(c => c.CreateDependencyAsync(request, It.IsAny<CancellationToken>()))
            .ReturnsAsync(serverDep);

        // When
        var result = await store.CreateAsync(request);

        // Then
        result.Id.Should().Be(serverDep.Id);
        store.GetBlocking(request.BlockedItemId).Should().HaveCount(1);
    }

    [Fact]
    public async Task CreateAsync_ServerRejects_RollsBack()
    {
        // Given
        var store = CreateStore();
        var blockedItemId = Guid.NewGuid();
        var request = new CreateDependencyRequest
        {
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = blockedItemId,
            Type = DependencyType.Blocks,
        };

        _mockClient
            .Setup(c => c.CreateDependencyAsync(request, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new Exception("Circular dependency"));

        // When/Then
        await FluentActions.Invoking(() => store.CreateAsync(request))
            .Should().ThrowAsync<Exception>();

        // Store should be empty after rollback
        store.GetBlocking(blockedItemId).Should().BeEmpty();
    }

    [Fact]
    public void GetBlocking_ReturnsCorrectItems()
    {
        // Given
        var store = CreateStore();
        var blockedItemId = Guid.NewGuid();

        var blockingDep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = blockedItemId,
            Type = DependencyType.Blocks,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = _currentUserId,
        };

        // Add via event
        _mockClient.Raise(c => c.OnDependencyCreated += null!, blockingDep);

        // When
        var blocking = store.GetBlocking(blockedItemId);

        // Then
        blocking.Should().HaveCount(1);
        blocking[0].BlockingItemId.Should().Be(blockingDep.BlockingItemId);
    }

    [Fact]
    public void GetBlocked_ReturnsCorrectItems()
    {
        // Given
        var store = CreateStore();
        var blockingItemId = Guid.NewGuid();

        var dep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = blockingItemId,
            BlockedItemId = Guid.NewGuid(),
            Type = DependencyType.Blocks,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = _currentUserId,
        };

        _mockClient.Raise(c => c.OnDependencyCreated += null!, dep);

        // When
        var blocked = store.GetBlocked(blockingItemId);

        // Then
        blocked.Should().HaveCount(1);
        blocked[0].BlockedItemId.Should().Be(dep.BlockedItemId);
    }

    [Fact]
    public void IsBlocked_ReturnsTrueWhenHasBlockingDeps()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();

        var dep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = workItemId,
            Type = DependencyType.Blocks,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = _currentUserId,
        };

        _mockClient.Raise(c => c.OnDependencyCreated += null!, dep);

        // When/Then
        store.IsBlocked(workItemId).Should().BeTrue();
    }

    [Fact]
    public void IsBlocked_ReturnsFalseForRelatesToOnly()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();

        var dep = new Dependency
        {
            Id = Guid.NewGuid(),
            BlockingItemId = Guid.NewGuid(),
            BlockedItemId = workItemId,
            Type = DependencyType.RelatesTo, // Not Blocks
            CreatedAt = DateTime.UtcNow,
            CreatedBy = _currentUserId,
        };

        _mockClient.Raise(c => c.OnDependencyCreated += null!, dep);

        // When/Then
        store.IsBlocked(workItemId).Should().BeFalse();
    }

    [Fact]
    public void IsBlocked_ReturnsFalseWhenNoBlockingDeps()
    {
        // Given
        var store = CreateStore();
        var workItemId = Guid.NewGuid();

        // When/Then
        store.IsBlocked(workItemId).Should().BeFalse();
    }
}
```

**Verification**: `just test-cs-services`

---

## Session 60.5 Completion Checklist ✅

After completing all steps:

- [x] `just test-rs-ws` passes (new backend tests)
- [x] `just test-backend` passes (all backend tests)
- [x] `just test-cs-core` passes (new converter tests)
- [x] `just test-cs-services` passes (new store tests)
- [x] `just test-frontend` passes (all frontend tests)
- [x] `just test` passes (everything)

### Files Created (6) - All Complete ✅

| File | Purpose | Tests | Status |
|------|---------|-------|--------|
| `time_entry_handler_tests.rs` | Backend time entry integration tests | 11 | ✅ Complete |
| `dependency_handler_tests.rs` | Backend dependency integration tests | 10 | ✅ Complete |
| `TimeEntryConverterTests.cs` | Proto conversion tests for TimeEntry | 8 | ✅ Complete |
| `DependencyConverterTests.cs` | Proto conversion tests for Dependency | 5 | ✅ Complete |
| `TimeEntryStoreTests.cs` | Store unit tests with mocks | 7 | ✅ Complete |
| `DependencyStoreTests.cs` | Store unit tests with mocks | 10 | ✅ Complete |
| **Total** | **6 files, 51 tests** | **51** | **✅** |

---

## Integration Verification Checklist

After all tests pass, perform manual integration testing:

### Time Tracking

- [ ] Start timer on work item A → timer widget shows elapsed time updating every second
- [ ] Start timer on work item B → A's timer auto-stops (shows in response), B starts
- [ ] Stop B's timer → duration calculated correctly, timer widget updates
- [ ] Create manual time entry → appears in list with correct duration
- [ ] Edit time entry timestamps → duration recalculates
- [ ] Delete time entry → disappears from list

### Dependencies

- [ ] Create dependency: A blocks B → appears in B's dependency manager
- [ ] Verify A shows in B's "Blocked by" list
- [ ] Verify B shows in A's "Blocks" list
- [ ] Try creating B blocks A → circular dependency error with path shown
- [ ] BlockedIndicator appears on B in Kanban board
- [ ] Delete dependency → indicator disappears, lists update

### Real-Time Updates

- [ ] Open two browser windows
- [ ] Start timer in window 1 → appears in window 2
- [ ] Create dependency in window 1 → BlockedIndicator appears in window 2

### Error Handling

- [ ] Try to start timer on non-existent work item → proper error message
- [ ] Try to stop another user's timer → unauthorized error
- [ ] Try to create self-referential dependency → validation error
- [ ] Try to create cross-project dependency → validation error

---

## Final Verification

```bash
# Run all tests
just test

# Check for warnings
just lint

# Build everything
just check

# Run the app
just dev
```

---

## Session 60 Complete ✅

**Completion Date**: 2026-01-27
**Total Effort**: 5 sub-sessions (60.1 through 60.5)

With all five sub-sessions complete, you have:

1. **Protocol & Infrastructure** (60.1)
   - 20+ new protobuf message types
   - Validation constants and methods
   - Response builders and converters
   - Repository pagination and helpers

2. **Backend Handlers** (60.2)
   - Atomic timer start/stop operations
   - Owner-only mutation enforcement
   - BFS cycle detection for dependencies
   - Soft deletes with activity logging

3. **Frontend Models & WebSocket** (60.3)
   - Domain models with computed properties
   - Request DTOs for all operations
   - Proto converters with null safety
   - WebSocket interface and implementation

4. **Frontend State & UI** (60.4)
   - Optimistic update stores with rollback
   - Event-driven real-time updates
   - Timer widget with live elapsed time
   - Blocked indicator component

5. **Tests & Integration** (60.5)
   - 20 backend handler tests
   - 15+ frontend tests
   - Integration verification checklist

**Success Criteria Met:**
- One running timer per user (atomic operations)
- Circular dependency detection with path
- Owner-only time entry mutations
- Same-project dependency enforcement
- Real-time updates across clients
- Comprehensive test coverage
