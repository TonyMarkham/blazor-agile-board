# Session 70.2 (Revised): Frontend Polish - Toast Notifications & Activity UI

**Parent Plan**: `70-Session-Plan.md` (this is a consistency-aligned revision)
**Prerequisite**: Session 70.1 complete
**Target**: ~40-45k tokens
**Status**: ⏳ Pending

---

## Why This Revision Exists

The original 70.2 plan includes assumptions that conflict with the current codebase. This revised plan:

- Aligns WebSocket client methods to `SendRequestAsync` and broadcast handling via `HandleBroadcastEvent`.
- Splits Activity models into three files (per parent plan).
- Avoids `NotImplementedException` in production code (toast action support is fully implemented).
- Keeps all features intact (no scope reductions).

---

## Scope

This session implements user-facing polish with notifications and activity history UI:

1. **Activity Log Models** - C# models matching backend proto
2. **Proto Converters** - ActivityLog serialization/deserialization
3. **WebSocket Client Methods** - Activity query + real-time subscriptions
4. **Activity Feed Components** - Main feed, item rendering, skeleton loaders
5. **Toast Notification Service** - Queue management, severity levels, accessible action toasts
6. **Operation Spinner Component** - Loading states with ARIA

---

## Prerequisites Check

Before starting, verify:

```bash
just check-backend       # Backend from 70.1 compiles
just test-backend        # All backend tests pass
just restore-frontend    # NuGet packages restored
just build-frontend      # Frontend compiles
```

Ensure proto messages exist:
- `GetActivityLogRequest`, `ActivityLogList`, `ActivityLogEntry`, `ActivityLogCreated`
- Backend handler `handle_get_activity_log` implemented

---

## Dependency Order (Read Before Implementing)

- Activity Models → Proto Converters → WebSocket Methods → Activity Feed UI
- Toast Service → ActionToastHost → DI/Layouts
- Operation Spinner is independent (can be done anytime after Radzen is available)

---

## Implementation Order

### Part 1: Activity Log Models

#### Step 3.1: Create Activity Log Model

**Create**: `frontend/ProjectManagement.Core/Models/ActivityLog.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Activity log entry tracking changes to entities
/// </summary>
public sealed record ActivityLog
{
    public Guid Id { get; init; }
    public string EntityType { get; init; } = string.Empty;
    public Guid EntityId { get; init; }
    public string Action { get; init; } = string.Empty;
    public string? FieldName { get; init; }
    public string? OldValue { get; init; }
    public string? NewValue { get; init; }
    public Guid UserId { get; init; }
    public DateTime Timestamp { get; init; }
    public string? Comment { get; init; }
}
```

#### Step 3.2: Create Activity Log Page Model

**Create**: `frontend/ProjectManagement.Core/Models/ActivityLogPage.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Paginated list of activity log entries
/// </summary>
public sealed record ActivityLogPage
{
    public IReadOnlyList<ActivityLog> Entries { get; init; } = Array.Empty<ActivityLog>();
    public int TotalCount { get; init; }
    public bool HasMore { get; init; }
}
```

#### Step 3.3: Create Activity Log Request Model

**Create**: `frontend/ProjectManagement.Core/Models/GetActivityLogRequest.cs`

```csharp
namespace ProjectManagement.Core.Models;

/// <summary>
/// Request for activity log entries
/// </summary>
public sealed record GetActivityLogRequest
{
    public string EntityType { get; init; } = string.Empty;
    public Guid EntityId { get; init; }
    public int Limit { get; init; } = 50;
    public int Offset { get; init; } = 0;
}
```

**Verification**: `just build-cs-core`

---

### Part 2: Proto Converters

#### Step 4.1: Add Activity Log Converters

**File**: `frontend/ProjectManagement.Core/Converters/ProtoConverter.cs`

Add these methods to the `ProtoConverter` class:

```csharp
// Activity Log Converters

public static Proto.GetActivityLogRequest ToProto(GetActivityLogRequest request)
{
    ArgumentNullException.ThrowIfNull(request);

    return new Proto.GetActivityLogRequest
    {
        EntityType = request.EntityType,
        EntityId = request.EntityId.ToString(),
        Limit = request.Limit,
        Offset = request.Offset,
    };
}

public static ActivityLog FromProto(Proto.ActivityLogEntry proto)
{
    ArgumentNullException.ThrowIfNull(proto);

    return new ActivityLog
    {
        Id = Guid.Parse(proto.Id),
        EntityType = proto.EntityType,
        EntityId = Guid.Parse(proto.EntityId),
        Action = proto.Action,
        FieldName = proto.FieldName,
        OldValue = proto.OldValue,
        NewValue = proto.NewValue,
        UserId = Guid.Parse(proto.UserId),
        Timestamp = DateTimeOffset.FromUnixTimeSeconds(proto.Timestamp).UtcDateTime,
        Comment = proto.Comment,
    };
}

public static ActivityLogPage FromProto(Proto.ActivityLogList proto)
{
    ArgumentNullException.ThrowIfNull(proto);

    var entries = proto.Entries
        .Select(FromProto)
        .ToList()
        .AsReadOnly();

    return new ActivityLogPage
    {
        Entries = entries,
        TotalCount = proto.TotalCount,
        HasMore = proto.HasMore,
    };
}
```

**Add tests** in `frontend/ProjectManagement.Core.Tests/Converters/ProtoConverterTests.cs` (same as original plan, updated for split model files).

**Verification**: `just test-cs-core`

---

### Part 3: WebSocket Client Methods

#### Step 5.1: Add Activity Methods to Interface

**File**: `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs`

Add:

```csharp
Task<ActivityLogPage> GetActivityLogAsync(
    string entityType,
    Guid entityId,
    int limit = 50,
    int offset = 0,
    CancellationToken cancellationToken = default);

event Action<ActivityLog>? OnActivityLogCreated;
```

**Verification**: `just build-cs-core`

---

#### Step 5.2: Implement in WebSocket Client

**File**: `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`

Add event and method using the existing `SendRequestAsync` and broadcast handling pattern:

```csharp
public event Action<ActivityLog>? OnActivityLogCreated;

public async Task<ActivityLogPage> GetActivityLogAsync(
    string entityType,
    Guid entityId,
    int limit = 50,
    int offset = 0,
    CancellationToken cancellationToken = default)
{
    ArgumentException.ThrowIfNullOrEmpty(entityType);

    var request = new GetActivityLogRequest
    {
        EntityType = entityType,
        EntityId = entityId,
        Limit = limit,
        Offset = offset,
    };

    var message = new Pm.WebSocketMessage
    {
        MessageId = Guid.NewGuid().ToString(),
        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        GetActivityLogRequest = ProtoConverter.ToProto(request),
    };

    var response = await SendRequestAsync(message, cancellationToken);

    if (response.PayloadCase == Pm.WebSocketMessage.PayloadOneofCase.Error)
        throw new ServerRejectedException(response.Error.Code, response.Error.Message);

    if (response.PayloadCase != Pm.WebSocketMessage.PayloadOneofCase.ActivityLogList)
        throw new InvalidOperationException($"Unexpected response type: {response.PayloadCase}");

    return ProtoConverter.FromProto(response.ActivityLogList);
}
```

**Broadcast handling**: Add a new case in `HandleBroadcastEvent`:

```csharp
case Pm.WebSocketMessage.PayloadOneofCase.ActivityLogCreated:
    var entry = ProtoConverter.FromProto(message.ActivityLogCreated.Entry);
    OnActivityLogCreated?.Invoke(entry);
    break;
```

**Verification**: `just build-cs-services && just test-cs-services`

---

### Part 4: Activity Feed Components

#### Step 6.1: Create Activity Feed Component

**Create**: `frontend/ProjectManagement.Components/Activity/ActivityFeed.razor`

*(Use the original 70.2 markup and code; update only if compilation requires namespaced imports.)*

#### Step 6.2: Create Activity Item Component

**Create**: `frontend/ProjectManagement.Components/Activity/ActivityItem.razor`

*(Use the original 70.2 markup and code; no changes required.)*

#### Step 6.3: Create Skeleton Loader

**Create**: `frontend/ProjectManagement.Components/Activity/ActivityFeedSkeleton.razor`

*(Use the original 70.2 markup and code; no changes required.)*

#### Step 6.4: Add Activity Styles

**File**: `frontend/ProjectManagement.Components/wwwroot/css/app.css`

*(Use the original 70.2 activity styles; no changes required.)*

**Verification**: `just build-cs-components`

---

### Part 5: Toast Notification Service

#### Step 5.1: Create Toast Service Interface

**Create**: `frontend/ProjectManagement.Services/Notifications/IToastService.cs`

```csharp
namespace ProjectManagement.Services.Notifications;

/// <summary>
/// Toast notification service for user feedback
/// </summary>
public interface IToastService
{
    /// <summary>
    /// Show a success toast (default: 3 seconds)
    /// </summary>
    void ShowSuccess(string message, string? title = null, int? durationMs = null);

    /// <summary>
    /// Show an error toast (default: 5 seconds, bypasses queue limit)
    /// </summary>
    void ShowError(string message, string? title = null, int? durationMs = null);

    /// <summary>
    /// Show a warning toast (default: 4 seconds)
    /// </summary>
    void ShowWarning(string message, string? title = null, int? durationMs = null);

    /// <summary>
    /// Show an info toast (default: 3 seconds)
    /// </summary>
    void ShowInfo(string message, string? title = null, int? durationMs = null);

    /// <summary>
    /// Show a toast with an action button (e.g., "Undo")
    /// </summary>
    void ShowWithAction(
        string message,
        string actionText,
        Func<Task> onAction,
        int durationMs = 5000);

    /// <summary>
    /// Clear all active toasts
    /// </summary>
    void Clear();

    /// <summary>
    /// Number of currently visible toasts (for testing)
    /// </summary>
    int ActiveCount { get; }

    /// <summary>
    /// Active action toasts (rendered by ActionToastHost)
    /// </summary>
    IReadOnlyList<ActionToastRequest> ActionToasts { get; }

    /// <summary>
    /// Raised when action toasts change
    /// </summary>
    event Action? OnActionToastsChanged;

    /// <summary>
    /// Dismiss a single action toast
    /// </summary>
    void DismissActionToast(Guid id);
}
```

**Verification**: `just build-cs-services`

---

#### Step 5.2: Add Action Toast Model

**Create**: `frontend/ProjectManagement.Services/Notifications/ActionToastRequest.cs`

```csharp
namespace ProjectManagement.Services.Notifications;

/// <summary>
/// Represents a toast with an action button (e.g., "Undo")
/// </summary>
public sealed record ActionToastRequest
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Message { get; init; } = string.Empty;
    public string ActionText { get; init; } = string.Empty;
    public Func<Task> OnAction { get; init; } = () => Task.CompletedTask;
    public int DurationMs { get; init; } = 5000;
}
```

**Verification**: `just build-cs-services`

---

#### Step 5.3: Implement Toast Service

**Create**: `frontend/ProjectManagement.Services/Notifications/ToastService.cs`

```csharp
using Microsoft.Extensions.Logging;
using Radzen;

namespace ProjectManagement.Services.Notifications;

/// <summary>
/// Production-grade toast service with queue management
/// </summary>
public sealed class ToastService : IToastService, IDisposable
{
    private readonly NotificationService _radzen;
    private readonly ILogger<ToastService> _logger;
    private readonly object _lock = new();

    // Default durations by severity (configurable)
    public static class Defaults
    {
        public const int SuccessDurationMs = 3000;
        public const int ErrorDurationMs = 5000;
        public const int WarningDurationMs = 4000;
        public const int InfoDurationMs = 3000;
        public const int ActionDurationMs = 5000;
        public const int MaxConcurrentToasts = 3;
        public const int MaxActionToasts = 2;
    }

    private int _activeCount;
    public int ActiveCount => _activeCount;

    private readonly List<ActionToastRequest> _actionToasts = new();
    public IReadOnlyList<ActionToastRequest> ActionToasts => _actionToasts.AsReadOnly();
    public event Action? OnActionToastsChanged;

    public ToastService(NotificationService radzen, ILogger<ToastService> logger)
    {
        _radzen = radzen ?? throw new ArgumentNullException(nameof(radzen));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public void ShowSuccess(string message, string? title = null, int? durationMs = null)
    {
        ArgumentNullException.ThrowIfNull(message);
        Show(NotificationSeverity.Success, message, title ?? "Success", durationMs ?? Defaults.SuccessDurationMs);
    }

    public void ShowError(string message, string? title = null, int? durationMs = null)
    {
        ArgumentNullException.ThrowIfNull(message);

        // Errors always show, don't count against limit (important feedback)
        _logger.LogWarning("User error displayed: {Message}", message);

        _radzen.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Error,
            Summary = title ?? "Error",
            Detail = message,
            Duration = durationMs ?? Defaults.ErrorDurationMs,
            CloseOnClick = true,
        });
    }

    public void ShowWarning(string message, string? title = null, int? durationMs = null)
    {
        ArgumentNullException.ThrowIfNull(message);
        Show(NotificationSeverity.Warning, message, title ?? "Warning", durationMs ?? Defaults.WarningDurationMs);
    }

    public void ShowInfo(string message, string? title = null, int? durationMs = null)
    {
        ArgumentNullException.ThrowIfNull(message);
        Show(NotificationSeverity.Info, message, title ?? "Info", durationMs ?? Defaults.InfoDurationMs);
    }

    public void ShowWithAction(string message, string actionText, Func<Task> onAction, int durationMs = Defaults.ActionDurationMs)
    {
        ArgumentNullException.ThrowIfNull(message);
        ArgumentNullException.ThrowIfNull(actionText);
        ArgumentNullException.ThrowIfNull(onAction);

        ActionToastRequest request;

        lock (_lock)
        {
            if (_actionToasts.Count >= Defaults.MaxActionToasts)
            {
                _logger.LogDebug("Action toast suppressed (queue full): {Message}", message);
                return;
            }

            request = new ActionToastRequest
            {
                Message = message,
                ActionText = actionText,
                OnAction = onAction,
                DurationMs = durationMs,
            };

            _actionToasts.Add(request);
        }

        OnActionToastsChanged?.Invoke();
        _ = DismissAfterDelay(request.Id, durationMs);
    }

    public void DismissActionToast(Guid id)
    {
        lock (_lock)
        {
            var index = _actionToasts.FindIndex(t => t.Id == id);
            if (index >= 0)
            {
                _actionToasts.RemoveAt(index);
            }
        }

        OnActionToastsChanged?.Invoke();
    }

    private void Show(NotificationSeverity severity, string message, string title, int durationMs)
    {
        lock (_lock)
        {
            if (_activeCount >= Defaults.MaxConcurrentToasts)
            {
                _logger.LogDebug("Toast suppressed (queue full): {Message}", message);
                return;
            }
            _activeCount++;
        }

        _radzen.Notify(new NotificationMessage
        {
            Severity = severity,
            Summary = title,
            Detail = message,
            Duration = durationMs,
            CloseOnClick = true,
        });

        // Schedule decrement after duration
        _ = DecrementAfterDelay(durationMs);
    }

    private async Task DecrementAfterDelay(int delayMs)
    {
        await Task.Delay(delayMs).ConfigureAwait(false);
        lock (_lock)
        {
            _activeCount = Math.Max(0, _activeCount - 1);
        }
    }

    private async Task DismissAfterDelay(Guid id, int delayMs)
    {
        await Task.Delay(delayMs).ConfigureAwait(false);
        DismissActionToast(id);
    }

    public void Clear()
    {
        lock (_lock)
        {
            _activeCount = 0;
            _actionToasts.Clear();
        }

        OnActionToastsChanged?.Invoke();
    }

    public void Dispose()
    {
        Clear();
    }
}
```

**Verification**: `just build-cs-services`

---

#### Step 5.4: Action Toast Host Component

**Create**: `frontend/ProjectManagement.Components/Shared/ActionToastHost.razor`

```razor
@using ProjectManagement.Services.Notifications
@inject IToastService Toasts

<div class="action-toast-host" aria-live="polite" aria-label="Notifications">
    @foreach (var toast in Toasts.ActionToasts)
    {
        <div class="action-toast" role="status" @key="toast.Id">
            <span class="action-toast-message">@toast.Message</span>
            <RadzenButton Text="@toast.ActionText"
                          Size="ButtonSize.Small"
                          Variant="Variant.Text"
                          Click="@(async () => await HandleAction(toast))" />
            <RadzenButton Icon="close"
                          ButtonStyle="ButtonStyle.Light"
                          Size="ButtonSize.Small"
                          Click="@(() => Toasts.DismissActionToast(toast.Id))"
                          aria-label="Dismiss" />
        </div>
    }
</div>

@code {
    protected override void OnInitialized()
    {
        Toasts.OnActionToastsChanged += HandleActionToastsChanged;
    }

    private async Task HandleAction(ActionToastRequest toast)
    {
        try
        {
            await toast.OnAction();
        }
        finally
        {
            Toasts.DismissActionToast(toast.Id);
        }
    }

    private void HandleActionToastsChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        Toasts.OnActionToastsChanged -= HandleActionToastsChanged;
    }
}
```

**Add CSS** to `frontend/ProjectManagement.Components/wwwroot/css/app.css`:

```css
/* Action Toast Host */
.action-toast-host {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    z-index: 10000;
}

.action-toast {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    background: var(--rz-base-background-color, #fff);
    box-shadow: var(--rz-shadow-4, 0 2px 8px rgba(0,0,0,0.15));
    border: 1px solid var(--rz-base-200, #e0e0e0);
}

.action-toast-message {
    max-width: 320px;
}
```

**Add host to layout**: `frontend/ProjectManagement.Wasm/Layout/MainLayout.razor`

```razor
<ActionToastHost />
```

Place it near the existing `<RadzenNotification />` so toast systems are colocated.

**Verification**: `just build-cs-components`

---

#### Step 5.5: Register Toast Service

**Modify**: `frontend/ProjectManagement.Wasm/Program.cs`

Register the service with DI:

```csharp
builder.Services.AddScoped<IToastService, ToastService>();
```

**Verification**: `just build-frontend`

---

#### Step 5.6: Toast Service Tests

**Create**: `frontend/ProjectManagement.Services.Tests/Notifications/ToastServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using Moq;
using ProjectManagement.Services.Notifications;
using Radzen;
using Xunit;

namespace ProjectManagement.Services.Tests.Notifications;

public class ToastServiceTests
{
    private readonly Mock<NotificationService> _mockRadzen;
    private readonly ToastService _sut;

    public ToastServiceTests()
    {
        _mockRadzen = new Mock<NotificationService>();
        _sut = new ToastService(_mockRadzen.Object, NullLogger<ToastService>.Instance);
    }

    [Fact]
    public void ShowSuccess_RendersCorrectSeverity()
    {
        _sut.ShowSuccess("Operation succeeded");

        _mockRadzen.Verify(
            r => r.Notify(It.Is<NotificationMessage>(m =>
                m.Severity == NotificationSeverity.Success &&
                m.Detail == "Operation succeeded")),
            Times.Once);
    }

    [Fact]
    public void ShowError_BypassesQueueLimit()
    {
        for (int i = 0; i < ToastService.Defaults.MaxConcurrentToasts; i++)
            _sut.ShowInfo($"Message {i}");

        _sut.ShowError("Critical error");

        _mockRadzen.Verify(
            r => r.Notify(It.IsAny<NotificationMessage>()),
            Times.Exactly(ToastService.Defaults.MaxConcurrentToasts + 1));
    }

    [Fact]
    public void ShowInfo_RespectsQueueLimit()
    {
        for (int i = 0; i < ToastService.Defaults.MaxConcurrentToasts; i++)
            _sut.ShowInfo($"Message {i}");

        _sut.ShowInfo("This should be suppressed");

        _mockRadzen.Verify(
            r => r.Notify(It.IsAny<NotificationMessage>()),
            Times.Exactly(ToastService.Defaults.MaxConcurrentToasts));
    }

    [Fact]
    public async Task ActiveCount_DecrementsAfterDuration()
    {
        const int durationMs = 120;

        _sut.ShowSuccess("Test", durationMs: durationMs);
        _sut.ActiveCount.Should().Be(1);

        await Task.Delay(durationMs + 100);

        _sut.ActiveCount.Should().Be(0);
    }

    [Fact]
    public void ShowWithAction_AddsActionToast()
    {
        _sut.ShowWithAction("Undo delete", "Undo", () => Task.CompletedTask);

        _sut.ActionToasts.Should().HaveCount(1);
    }

    [Fact]
    public void DismissActionToast_RemovesItem()
    {
        _sut.ShowWithAction("Undo delete", "Undo", () => Task.CompletedTask);
        var toast = _sut.ActionToasts.Single();

        _sut.DismissActionToast(toast.Id);

        _sut.ActionToasts.Should().BeEmpty();
    }

    [Fact]
    public void Clear_ResetsActiveCountAndActionToasts()
    {
        _sut.ShowSuccess("Message 1");
        _sut.ShowWithAction("Undo delete", "Undo", () => Task.CompletedTask);

        _sut.Clear();

        _sut.ActiveCount.Should().Be(0);
        _sut.ActionToasts.Should().BeEmpty();
    }

    [Fact]
    public void Constructor_ThrowsOnNullDependencies()
    {
        var act1 = () => new ToastService(null!, NullLogger<ToastService>.Instance);
        act1.Should().Throw<ArgumentNullException>();

        var act2 = () => new ToastService(_mockRadzen.Object, null!);
        act2.Should().Throw<ArgumentNullException>();
    }
}
```

**Verification**: `just test-cs-services`

---

### Part 6: Operation Spinner Component

#### Step 6.1: Create Spinner Component

**Create**: `frontend/ProjectManagement.Components/Shared/OperationSpinner.razor`

```razor
@implements IDisposable

@* Overlay for blocking operations *@
<div class="operation-spinner @(IsVisible ? "visible" : "")"
     role="progressbar"
     aria-busy="@IsVisible"
     aria-valuetext="@(Message ?? "Loading")"
     aria-label="@(Message ?? "Loading")">
    <div class="spinner-content">
        <RadzenProgressBarCircular ShowValue="false" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.Large" />
        @if (!string.IsNullOrEmpty(Message))
        {
            <span class="spinner-message" aria-live="polite">@Message</span>
        }
    </div>
</div>

@code {
    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public string? Message { get; set; }

    private bool _previousVisible;

    protected override void OnParametersSet()
    {
        if (IsVisible != _previousVisible)
        {
            _previousVisible = IsVisible;
        }
    }

    public void Dispose()
    {
    }
}
```

**Add CSS** to `frontend/ProjectManagement.Components/wwwroot/css/app.css`:

```css
/* Operation Spinner Overlay */
.operation-spinner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    backdrop-filter: blur(2px);
}

.operation-spinner.visible {
    display: flex;
}

.spinner-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--rz-spacing-4, 1rem);
    background: var(--rz-base-background-color, white);
    padding: var(--rz-spacing-6, 1.5rem);
    border-radius: var(--rz-border-radius, 4px);
    box-shadow: var(--rz-shadow-8, 0 4px 20px rgba(0,0,0,0.15));
}

.spinner-message {
    font-size: var(--rz-body-font-size, 14px);
    color: var(--rz-text-color, #333);
    text-align: center;
}
```

**Verification**: `just build-cs-components`

---

## Session 70.2 Completion Checklist

- [ ] `just build-cs-services` passes
- [ ] `just build-cs-components` passes
- [ ] `just test-cs-services` passes (toast service tests)
- [ ] `just test-cs-core` passes (converter tests)
- [ ] Activity feed renders without errors
- [ ] Skeleton loader displays during initial load
- [ ] "Load more" button works with pagination
- [ ] Real-time activity updates prepend to list
- [ ] Keyboard shortcut (R) refreshes feed

---

## Files Created (12)

- `frontend/ProjectManagement.Services/Notifications/IToastService.cs`
- `frontend/ProjectManagement.Services/Notifications/ActionToastRequest.cs`
- `frontend/ProjectManagement.Services/Notifications/ToastService.cs`
- `frontend/ProjectManagement.Components/Shared/ActionToastHost.razor`
- `frontend/ProjectManagement.Components/Shared/OperationSpinner.razor`
- `frontend/ProjectManagement.Core/Models/ActivityLog.cs`
- `frontend/ProjectManagement.Core/Models/ActivityLogPage.cs`
- `frontend/ProjectManagement.Core/Models/GetActivityLogRequest.cs`
- `frontend/ProjectManagement.Components/Activity/ActivityFeed.razor`
- `frontend/ProjectManagement.Components/Activity/ActivityItem.razor`
- `frontend/ProjectManagement.Components/Activity/ActivityFeedSkeleton.razor`
- `frontend/ProjectManagement.Services.Tests/Notifications/ToastServiceTests.cs`

## Files Modified (6)

- `frontend/ProjectManagement.Core/Converters/ProtoConverter.cs`
- `frontend/ProjectManagement.Core/Interfaces/IWebSocketClient.cs`
- `frontend/ProjectManagement.Services/WebSocket/WebSocketClient.cs`
- `frontend/ProjectManagement.Components/wwwroot/css/app.css`
- `frontend/ProjectManagement.Wasm/Program.cs`
- `frontend/ProjectManagement.Wasm/Layout/MainLayout.razor`

---

## Next Session

**Session 70.3** will implement:
- Store toast integration (all 5 stores)
- Connection status component with latency display
- Activity sidebar in WorkItemDetail page
- Complete user documentation (5 markdown files)
- Project file updates (README, CLAUDE.md)
