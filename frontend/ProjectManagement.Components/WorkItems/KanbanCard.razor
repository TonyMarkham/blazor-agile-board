@using ProjectManagement.Components.Dependencies
@using ProjectManagement.Core.ViewModels
@using ProjectManagement.Core.Models
@inject IDependencyStore DependencyStore

<div class="kanban-card @CardCssClass"
     role="listitem"
     tabindex="0"
     aria-label="@AriaLabel"
     @onclick="HandleClick"
     @onclick:stopPropagation="true"
     @onkeydown="HandleKeyDown">

    <RadzenStack Gap="0.5rem">
        @* Header: Type + Title *@
        <RadzenStack Orientation="Orientation.Horizontal"
                     AlignItems="AlignItems.Start"
                     Gap="0.5rem">
            <WorkItemTypeIcon Type="@Item.ItemType" Size="1rem" />
            <span class="kanban-card-title">@Item.Title</span>
        </RadzenStack>

        @* Footer: Priority, Points, Edit *@
        <RadzenStack Orientation="Orientation.Horizontal"
                     Gap="0.5rem"
                     AlignItems="AlignItems.Center"
                     JustifyContent="JustifyContent.SpaceBetween">
            <RadzenStack Orientation="Orientation.Horizontal"
                         Gap="0.25rem"
                         AlignItems="AlignItems.Center">
                <PriorityBadge Priority="@Item.Priority" ShowLabel="false" />
                @if (Item.StoryPoints.HasValue)
                {
                    <RadzenBadge BadgeStyle="BadgeStyle.Info"
                                 Text="@Item.StoryPoints.Value.ToString()"
                                 title="Story Points" />
                }
                <BlockedIndicator WorkItemId="@Item.Id" />
            </RadzenStack>

            @if (Item.IsPendingSync)
            {
                <RadzenProgressBarCircular ShowValue="false"
                                           Mode="ProgressBarMode.Indeterminate"
                                           Size="ProgressBarCircularSize.ExtraSmall"
                                           title="Saving..." />
            }
            else
            {
                <RadzenButton Icon="edit"
                              ButtonStyle="ButtonStyle.Light"
                              Variant="Variant.Text"
                              Size="ButtonSize.ExtraSmall"
                              Click="@HandleEditClick"
                              Click:stopPropagation="true"
                              Disabled="@(!IsConnected)"
                              title="Edit"
                              aria-label="@($"Edit {Item.Title}")" />
            }
        </RadzenStack>
        
        @* Progress section for Epic/Story cards *@
        @if (Item.ShowProgress)
        {
            @if (Item.ItemType == WorkItemType.Epic)
            {
                @if (Item.StoryProgress?.HasChildren == true)
                {
                    <ChildProgressBar Progress="@Item.StoryProgress" Label="Stories" />
                }
                @if (Item.TaskProgress?.HasChildren == true)
                {
                    <ChildProgressBar Progress="@Item.TaskProgress" Label="Tasks" />
                }
            }
            else if (Item.ItemType == WorkItemType.Story)
            {
                @if (Item.TaskProgress?.HasChildren == true)
                {
                    <ChildProgressBar Progress="@Item.TaskProgress" Label="Tasks" />
                }
            }
        }
    </RadzenStack>
</div>

@code {
    [Parameter, EditorRequired]
    public WorkItemViewModel Item { get; set; } = null!;

    [Parameter]
    public bool IsConnected { get; set; } = true;

    [Parameter]
    public EventCallback<WorkItemViewModel> OnClick { get; set; }

    [Parameter]
    public EventCallback<WorkItemViewModel> OnEdit { get; set; }

    private string CardCssClass => Item.IsPendingSync ? "pending-sync" : "";

    private string AriaLabel
    {
        get
        {
            var label = $"{Item.ItemTypeDisplayName}: {Item.Title}, Priority: {Item.PriorityDisplayName}";

            if (Item.StoryPoints.HasValue)
            {
                label += $", {Item.StoryPoints} points";
            }

            if (Item.IsPendingSync)
            {
                label += " (saving)";
            }

            return label;
        }
    }

    private async Task HandleClick()
    {
        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(Item);
        }
    }

    private async Task HandleEditClick(MouseEventArgs e)
    {
        if (IsConnected && !Item.IsPendingSync && OnEdit.HasDelegate)
        {
            await OnEdit.InvokeAsync(Item);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (Item.IsPendingSync) return;

        switch (e.Key)
        {
            case "Enter":
                if (OnClick.HasDelegate)
                {
                    await OnClick.InvokeAsync(Item);
                }
                break;

            case "e" when e.CtrlKey && IsConnected:
                if (OnEdit.HasDelegate)
                {
                    await OnEdit.InvokeAsync(Item);
                }
                break;
        }
    }
}
