@using ProjectManagement.Core.ViewModels
@using ProjectManagement.Core.Models

<div class="kanban-card @CardCssClass"
     style="border: 2px solid @TypeColor;"
     role="listitem"
     tabindex="0"
     aria-label="@AriaLabel"
     @onclick="HandleClick"
     @onclick:stopPropagation="true"
     @onkeydown="HandleKeyDown">

    @* Row 1: Type icon + Key + Priority icon *@
    <div class="kanban-card-header">
        <WorkItemTypeIcon Type="@Item.ItemType" Size="1.1rem" />
        @if (!string.IsNullOrEmpty(ProjectKey))
        {
            <span class="kanban-card-key">@Item.GetDisplayKey(ProjectKey)</span>
        }
        <PriorityBadge Priority="@Item.Priority" ShowLabel="false" Size="1.1rem" />
    </div>

    @* Row 2: Title (single line, truncated) *@
    <div class="kanban-card-title">@Item.Title</div>
</div>

@code {
    [Parameter, EditorRequired]
    public WorkItemViewModel Item { get; set; } = null!;

    [Parameter]
    public bool IsConnected { get; set; } = true;

    [Parameter]
    public EventCallback<WorkItemViewModel> OnClick { get; set; }

    [Parameter]
    public EventCallback<WorkItemViewModel> OnEdit { get; set; }

    [Parameter]
    public string? ProjectKey { get; set; }

    private string CardCssClass => Item.IsPendingSync ? "pending-sync" : "";

    private string TypeColor => Item.ItemType switch
    {
        WorkItemType.Epic => "#9c27b0",
        WorkItemType.Story => "#2196f3",
        WorkItemType.Task => "#4caf50",
        _ => "var(--rz-border-color)"
    };

    private string AriaLabel
    {
        get
        {
            var id = !string.IsNullOrEmpty(ProjectKey) ? $"{Item.GetDisplayKey(ProjectKey)}: " : "";
            var label = $"{id}{Item.ItemTypeDisplayName}: {Item.Title}, Priority: {Item.PriorityDisplayName}";

            if (Item.StoryPoints.HasValue)
            {
                label += $", {Item.StoryPoints} points";
            }

            if (Item.IsPendingSync)
            {
                label += " (saving)";
            }

            return label;
        }
    }

    private async Task HandleClick()
    {
        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(Item);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (Item.IsPendingSync) return;

        switch (e.Key)
        {
            case "Enter":
                if (OnClick.HasDelegate)
                {
                    await OnClick.InvokeAsync(Item);
                }
                break;

            case "e" when e.CtrlKey && IsConnected:
                if (OnEdit.HasDelegate)
                {
                    await OnEdit.InvokeAsync(Item);
                }
                break;
        }
    }
}
